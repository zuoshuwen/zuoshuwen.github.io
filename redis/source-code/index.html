

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="后端技术、笔记、教程">
  <meta name="author" content="sown">
  <meta name="keywords" content="go,golang,技术,后端,php,linux,redis,kubernetes,k8s,nginx,docker,网络,算法,">
  <meta name="description" content="数据结构动态字符串、SDSchar* 的不足：  操作效率低：获取长度需遍历，O(N)复杂度 二进制不安全：无法存储包含 \0 的数据  SDS 的优势：  操作效率高：获取长度无需遍历，O(1)复杂度 二进制安全：因单独记录长度字段，所以可存储包含 \0 的数据 兼容 C 字符串函数，可直接使用字符串 API  另外 Redis 在操作 SDS 时，为了避免频繁操作字符串时，每次「申请、释放」内">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis源码剖析与实战">
<meta property="og:url" content="https://ilifes.com/redis/source-code/index.html">
<meta property="og:site_name" content="Sown">
<meta property="og:description" content="数据结构动态字符串、SDSchar* 的不足：  操作效率低：获取长度需遍历，O(N)复杂度 二进制不安全：无法存储包含 \0 的数据  SDS 的优势：  操作效率高：获取长度无需遍历，O(1)复杂度 二进制安全：因单独记录长度字段，所以可存储包含 \0 的数据 兼容 C 字符串函数，可直接使用字符串 API  另外 Redis 在操作 SDS 时，为了避免频繁操作字符串时，每次「申请、释放」内">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-06-16T00:00:00.000Z">
<meta property="article:modified_time" content="2021-10-10T07:13:28.993Z">
<meta property="article:author" content="sown">
<meta property="article:tag" content="源码">
<meta name="twitter:card" content="summary_large_image">
  
  <title>Redis源码剖析与实战 - Sown</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"ilifes.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"97f60cea7055dca81a77d34bd50655bf","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"ButetqzXxYeinA3YL6tt2SI5-gzGzoHsz","app_key":"IQfQbzCDGqirp6rGE7bmsnzS","server_url":"https://butetqzx.lc-cn-n1-shared.com","path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Sown</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                程序设计
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/datastruct-algorithm/a/">
                    <i class="iconfont icon-notebook"></i>
                    数据结构与算法
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/design-pattern/a/">
                    <i class="iconfont icon-notebook"></i>
                    设计模式
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/program/a/">
                    <i class="iconfont icon-notebook"></i>
                    方案
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                编程
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/netprogram/a/">
                    <i class="iconfont icon-notebook"></i>
                    网络编程
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/golang/a/">
                    <i class="iconfont icon-notebook"></i>
                    Go
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/ios/a/">
                    <i class="iconfont icon-notebook"></i>
                    iOS
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/html5/a/">
                    <i class="iconfont icon-notebook"></i>
                    H5
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/applet/a/">
                    <i class="iconfont icon-notebook"></i>
                    小程序
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                架构
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/distributed/a/">
                    <i class="iconfont icon-notebook"></i>
                    分布式
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/microservices/a/">
                    <i class="iconfont icon-notebook"></i>
                    微服务
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/example/a/">
                    <i class="iconfont icon-notebook"></i>
                    方案设计
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/microservices/a/">
                    <i class="iconfont icon-notebook"></i>
                    架构模式
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/ddd/a/">
                    <i class="iconfont icon-notebook"></i>
                    领域驱动设计
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                开源学习
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/redis/a/">
                    <i class="iconfont icon-notebook"></i>
                    Redis
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/mysql/a/">
                    <i class="iconfont icon-notebook"></i>
                    MySQL
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/etcd/a/">
                    <i class="iconfont icon-notebook"></i>
                    Etcd
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                数据
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/datadev/a/">
                    <i class="iconfont icon-notebook"></i>
                    数据开发
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/datanal/a/">
                    <i class="iconfont icon-notebook"></i>
                    数据分析
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/images/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Redis源码剖析与实战">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-06-16 08:00" pubdate>
        2021年6月16日 早上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      25k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      79 分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Redis源码剖析与实战</h1>
            
            <div class="markdown-body">
              <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="动态字符串、SDS"><a href="#动态字符串、SDS" class="headerlink" title="动态字符串、SDS"></a>动态字符串、SDS</h2><p>char* 的不足：</p>
<ul>
<li>操作效率低：获取长度需遍历，O(N)复杂度</li>
<li>二进制不安全：无法存储包含 \0 的数据</li>
</ul>
<p>SDS 的优势：</p>
<ul>
<li>操作效率高：获取长度无需遍历，O(1)复杂度</li>
<li>二进制安全：因单独记录长度字段，所以可存储包含 \0 的数据</li>
<li>兼容 C 字符串函数，可直接使用字符串 API</li>
</ul>
<p>另外 Redis 在操作 SDS 时，为了避免频繁操作字符串时，每次「申请、释放」内存的开销，还做了这些优化：</p>
<ul>
<li>内存预分配：SDS 扩容，会多申请一些内存（小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容）</li>
<li>多余内存不释放：SDS 缩容，不释放多余的内存，下次使用可直接复用这些内存</li>
</ul>
<p>这种策略，是以多占一些内存的方式，换取「追加」操作的速度。</p>
<p>这个内存预分配策略，详细逻辑可以看 sds.c 的 sdsMakeRoomFor 函数。</p>
<p>课后题：SDS 字符串在 Redis 内部模块实现中也被广泛使用，你能在 Redis server 和客户端的实现中，找到使用 SDS 字符串的地方么？</p>
<ol>
<li>Redis 中所有 key 的类型就是 SDS（详见 db.c 的 dbAdd 函数）</li>
<li>Redis Server 在读取 Client 发来的请求时，会先读到一个缓冲区中，这个缓冲区也是 SDS（详见 server.h 中 struct client 的 querybuf 字段）</li>
<li>写操作追加到 AOF 时，也会先写到 AOF 缓冲区，这个缓冲区也是 SDS （详见 server.h 中 struct client 的 aof_buf 字段）</li>
</ol>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><ol>
<li><p>Redis 中的 dict 数据结构，采用「链式哈希」的方式存储，当哈希冲突严重时，会开辟一个新的哈希表，翻倍扩容，并采用「渐进式 rehash」的方式迁移数据</p>
</li>
<li><p>所谓「渐进式 rehash」是指，把很大块迁移数据的开销，平摊到多次小的操作中，目的是降低主线程的性能影响</p>
</li>
<li><p>Redis 中凡是需要 O(1) 时间获取 k-v 数据的场景，都使用了 dict 这个数据结构，也就是说 dict 是 Redis 中重中之重的「底层数据结构」</p>
</li>
<li><p>dict 封装好了友好的「增删改查」API，并在适当时机「自动扩容、缩容」，这给上层数据类型（Hash/Set/Sorted Set）、全局哈希表的实现提供了非常大的便利</p>
</li>
<li><p>例如，Redis 中每个 DB 存放数据的「全局哈希表、过期key」都用到了 dict：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// server.h</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span> &#123;</span>
   dict *dict; <span class="hljs-comment">// 全局哈希表，数据键值对存在这</span>
   dict *expires; <span class="hljs-comment">// 过期 key + 过期时间 存在这</span>
   ...
&#125;</code></pre></div></li>
<li><p>「全局哈希表」在触发渐进式 rehash 的情况有 2 个：</p>
</li>
</ol>
<ul>
<li>增删改查哈希表时：每次迁移 1 个哈希桶（文章提到的 dict.c 中的 _dictRehashStep 函数）</li>
<li>定时 rehash：如果 dict 一直没有操作，无法渐进式迁移数据，那主线程会默认每间隔 100ms 执行一次迁移操作。这里一次会以 100 个桶为基本单位迁移数据，并限制如果一次操作耗时超时 1ms 就结束本次任务，待下次再次触发迁移（文章没提到这个，详见 dict.c 的 dictRehashMilliseconds 函数）</li>
</ul>
<p>（注意：定时 rehash 只会迁移全局哈希表中的数据，不会定时迁移 Hash/Set/Sorted Set 下的哈希表的数据，这些哈希表只会在操作数据时做实时的渐进式 rehash）</p>
<ol start="7">
<li>dict 在负载因子超过 1 时（used: bucket size &gt;= 1），会触发 rehash。但如果 Redis 正在 RDB 或 AOF rewrite，为避免父进程大量写时复制，会暂时关闭触发 rehash。但这里有个例外，如果负载因子超过了 5（哈希冲突已非常严重），依旧会强制做 rehash（重点）</li>
<li>dict 在 rehash 期间，查询旧哈希表找不到结果，还需要在新哈希表查询一次</li>
</ol>
<p>课后题：Hash 函数会影响 Hash 表的查询效率及哈希冲突情况，那么，你能从 Redis 的源码中，找到 Hash 表使用的是哪一种 Hash 函数吗？</p>
<p>找到 dict.c 的 dictFind 函数，可以看到查询一个 key 在哈希表的位置时，调用了 dictHashKey 计算 key 的哈希值：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-function">dictEntry *<span class="hljs-title">dictFind</span><span class="hljs-params">(dict *d, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key)</span> </span>&#123;
   <span class="hljs-comment">// 计算 key 的哈希值</span>
   h = dictHashKey(d, key);
   ...
&#125;</code></pre></div>

<p>继续跟代码可以看到 dictHashKey 调用了 struct dict 下 dictType 的 hashFunction 函数：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// dict.h</span>
dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)</code></pre></div>

<p>而这个 hashFunction 是在初始化一个 dict 时，才会指定使用哪个哈希函数的。</p>
<p>当 Redis Server 在启动时会创建「全局哈希表」：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 初始化 db 下的全局哈希表</span>
<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; server.dbnum; j++) &#123;
   <span class="hljs-comment">// dbDictType 中指定了哈希函数</span>
   server.db[j].dict = dictCreate(&amp;dbDictType,<span class="hljs-literal">NULL</span>);
...
&#125;</code></pre></div>

<p>这个 dbDictType struct 指定了具体的哈希函数，跟代码进去能看到，使用了 SipHash 算法，具体实现逻辑在 siphash.c。</p>
<p>（SipHash 哈希算法是在 Redis 4.0 才开始使用的，3.0-4.0 使用的是 MurmurHash2 哈希算法，3.0 之前是 DJBX33A 哈希算法）</p>
<h2 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h2><ol>
<li>要想理解 Redis 数据类型的设计，必须要先了解 redisObject。</li>
</ol>
<p>Redis 的 key 是 String 类型，但 value 可以是很多类型（String/List/Hash/Set/ZSet等），所以 Redis 要想存储多种数据类型，就要设计一个通用的对象进行封装，这个对象就是 redisObject。</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// server.h</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span>
   <span class="hljs-keyword">unsigned</span> type:<span class="hljs-number">4</span>;
   <span class="hljs-keyword">unsigned</span> encoding:<span class="hljs-number">4</span>;
   <span class="hljs-keyword">unsigned</span> lru:LRU_BITS;
   <span class="hljs-keyword">int</span> refcount;
   <span class="hljs-keyword">void</span> *ptr;
&#125; robj;</code></pre></div>

<p>其中，最重要的 2 个字段：</p>
<ul>
<li>type：面向用户的数据类型（String/List/Hash/Set/ZSet等）</li>
<li>encoding：每一种数据类型，可以对应不同的底层数据结构来实现（SDS/ziplist/intset/hashtable/skiplist等）</li>
</ul>
<p>例如 String，可以用 embstr（嵌入式字符串，redisObject 和 SDS 一起分配内存），也可以用 rawstr（redisObject 和 SDS 分开存储）实现。</p>
<p>又或者，当用户写入的是一个「数字」时，底层会转成 long 来存储，节省内存。</p>
<p>同理，Hash/Set/ZSet 在数据量少时，采用 ziplist 存储，否则就转为 hashtable 来存。</p>
<p>所以，redisObject 的作用在于：</p>
<ul>
<li>为多种数据类型提供统一的表示方式</li>
<li>同一种数据类型，底层可以对应不同实现，节省内存</li>
<li>支持对象共享和引用计数，共享对象存储一份，可多次使用，节省内存</li>
</ul>
<p>redisObject 更像是连接「上层数据类型」和「底层数据结构」之间的桥梁。</p>
<ol start="2">
<li>关于 String 类型的实现，底层对应 3 种数据结构：</li>
</ol>
<ul>
<li>embstr：小于 44 字节，嵌入式存储，redisObject 和 SDS 一起分配内存，只分配 1 次内存</li>
<li>rawstr：大于 44 字节，redisObject 和 SDS 分开存储，需分配 2 次内存</li>
<li>long：整数存储（小于 10000，使用共享对象池存储，但有个前提：Redis 没有设置淘汰策略，详见 object.c 的 tryObjectEncoding 函数）</li>
</ul>
<ol start="3">
<li>ziplist 的特点：</li>
</ol>
<ul>
<li>连续内存存储：每个元素紧凑排列，内存利用率高</li>
<li>变长编码：存储数据时，采用变长编码（满足数据长度的前提下，尽可能少分配内存）</li>
<li>寻找元素需遍历：存放太多元素，性能会下降（适合少量数据存储）</li>
<li>级联更新：更新、删除元素，会引发级联更新（因为内存连续，前面数据膨胀/删除了，后面要跟着一起动）</li>
</ul>
<p>List、Hash、Set、ZSet 底层都用到了 ziplist。</p>
<ol start="4">
<li>intset 的特点：</li>
</ol>
<ul>
<li>Set 存储如果都是数字，采用 intset 存储</li>
<li>变长编码：数字范围不同，intset 会选择 int16/int32/int64 编码（intset.c 的 _intsetValueEncoding 函数）</li>
<li>有序：intset 在存储时是有序的，这意味着查找一个元素，可使用「二分查找」（intset.c 的 intsetSearch 函数）</li>
<li>编码升级/降级：添加、更新、删除元素，数据范围发生变化，会引发编码长度升级或降级</li>
</ul>
<p>课后题：SDS 判断是否使用嵌入式字符串的条件是 44 字节，你知道为什么是 44 字节吗？</p>
<p>嵌入式字符串会把 redisObject 和 SDS 一起分配内存，那在存储时结构是这样的：</p>
<ul>
<li>redisObject：16 个字节</li>
<li>SDS：sdshdr8（3 个字节）+ SDS 字符数组（N 字节 + \0 结束符 1 个字节）</li>
</ul>
<p>Redis 规定嵌入式字符串最大以 64 字节存储，所以 N = 64 - 16(redisObject) - 3(sdshr8) - 1(\0)， N = 44 字节。</p>
<h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><ol>
<li>ZSet 当数据比较少时，采用 ziplist 存储，每个 member/score 元素紧凑排列，节省内存</li>
<li>当数据超过阈值（zset-max-ziplist-entries、zset-max-ziplist-value）后，转为 hashtable + skiplist 存储，降低查询的时间复杂度</li>
<li>hashtable 存储 member-&gt;score 的关系，所以 ZSCORE 的时间复杂度为 O(1)</li>
<li>skiplist 是一个「有序链表 + 多层索引」的结构，把查询元素的复杂度降到了 O(logN)，服务于 ZRANGE/ZREVRANGE 这类命令</li>
<li>skiplist 的多层索引，采用「随机」的方式来构建，也就是说每次添加一个元素进来，要不要对这个元素建立「多层索引」？建立「几层索引」？都要通过「随机数」的方式来决定</li>
<li>每次随机一个 0-1 之间的数，如果这个数小于 0.25（25% 概率），那就给这个元素加一层指针，持续随机直到大于 0.25 结束，最终确定这个元素的层数（层数越高，概率越低，且限制最多 64 层，详见 t_zset.c 的 zslRandomLevel 函数）</li>
<li>这个预设「概率」决定了一个跳表的内存占用和查询复杂度：概率设置越低，层数越少，元素指针越少，内存占用也就越少，但查询复杂会变高，反之亦然。这也是 skiplist 的一大特点，可通过控制概率，进而控制内存和查询效率</li>
<li>skiplist 新插入一个节点，只需修改这一层前后节点的指针，不影响其它节点的层数，降低了操作复杂度（相比平衡二叉树的再平衡，skiplist 插入性能更优）</li>
</ol>
<p>关于 Redis 的 ZSet 为什么用 skiplist 而不用平衡二叉树实现的问题，原因是：</p>
<ul>
<li>skiplist 更省内存：25% 概率的随机层数，可通过公式计算出 skiplist 平均每个节点的指针数是 1.33 个，平衡二叉树每个节点指针是 2 个（左右子树）</li>
<li>skiplist 遍历更友好：skiplist 找到大于目标元素后，向后遍历链表即可，平衡树需要通过中序遍历方式来完成，实现也略复杂</li>
<li>skiplist 更易实现和维护：扩展 skiplist 只需要改少量代码即可完成，平衡树维护起来较复杂</li>
</ul>
<p>课后题：在使用跳表和哈希表相结合的双索引机制时，在获得高效范围查询和单点查询的同时，你能想到有哪些不足之处么？</p>
<p>这种发挥「多个数据结构」的优势，来完成某个功能的场景，最大的特点就是「空间换时间」，所以内存占用多是它的不足。</p>
<p>不过也没办法，想要高效率查询，就得牺牲内存，鱼和熊掌不可兼得。</p>
<p>不过 skiplist 在实现时，Redis 作者应该也考虑到这个问题了，就是上面提到的这个「随机概率」，Redis 后期维护可以通过调整这个概率，进而达到「控制」查询效率和内存平衡的结果。当然，这个预设值是固定写死的，不可配置，应该是 Redis 作者经过测试和权衡后的设定，我们这里只需要知晓原理就好。</p>
<h2 id="ZipList、QuickList、ListPack"><a href="#ZipList、QuickList、ListPack" class="headerlink" title="ZipList、QuickList、ListPack"></a>ZipList、QuickList、ListPack</h2><ol>
<li>ziplist 设计的初衷就是「节省内存」，在存储数据时，把内存利用率发挥到了极致：</li>
</ol>
<ul>
<li>数字按「整型」编码存储，比直接当字符串存内存占用少</li>
<li>数据「长度」字段，会根据内容的大小选择最小的长度编码</li>
<li>甚至对于极小的数据，干脆把内容直接放到了「长度」字段中（前几个位表示长度，后几个位存数据）</li>
</ul>
<ol start="2">
<li>但 ziplist 的劣势也很明显：</li>
</ol>
<ul>
<li>寻找元素只能挨个遍历，存储过长数据，查询性能很低</li>
<li>每个元素中保存了「上一个」元素的长度（为了方便反向遍历），这会导致上一个元素内容发生修改，长度超过了原来的编码长度，下一个元素的内容也要跟着变，重新分配内存，进而就有可能再次引起下一级的变化，一级级更新下去，频繁申请内存</li>
</ul>
<ol start="3">
<li>想要缓解 ziplist 的问题，比较简单直接的方案就是，多个数据项，不再用一个 ziplist 来存，而是分拆到多个 ziplist 中，每个 ziplist 用指针串起来，这样修改其中一个数据项，即便发生级联更新，也只会影响这一个 ziplist，其它 ziplist 不受影响，这种方案就是 quicklist：</li>
</ol>
<p>qucklist: ziplist1(也叫quicklistNode) &lt;-&gt; ziplist2 &lt;-&gt; ziplist3 &lt;-&gt; …</p>
<ol start="4">
<li>List 数据类型底层实现，就是用的 quicklist，因为它是一个链表，所以 LPUSH/LPOP/RPUSH/RPOP 的复杂度是 O(1)</li>
<li>List 中每个 ziplist 节点可以存的元素个数/总大小，可以通过 list-max-ziplist-size 配置：</li>
</ol>
<ul>
<li>正数：ziplist 最多包含几个数据项</li>
<li>负数：取值 -1 ~ -5，表示每个 ziplist 存储最大的字节数，默认 -2，每个ziplist 8KB</li>
</ul>
<p>ziplist 超过上述任一配置，添加新元素就会新建 ziplist 插入到链表中。</p>
<ol start="6">
<li>List 因为更多是两头操作，为了节省内存，还可以把中间的 ziplist「压缩」，具体可看 list-compress-depth 配置项，默认配置不压缩</li>
<li>要想彻底解决 ziplist 级联更新问题，本质上要修改 ziplist 的存储结构，也就是不要让每个元素保存「上一个」元素的长度即可，所以才有了 listpack</li>
<li>listpack 每个元素项不再保存上一个元素的长度，而是优化元素内字段的顺序，来保证既可以从前也可以向后遍历</li>
<li>listpack 是为了替代 ziplist 为设计的，但因为 List/Hash/Set/ZSet 都严重依赖 ziplist，所以这个替换之路很漫长，目前只有 Stream 数据类型用到了 listpack</li>
</ol>
<h2 id="Radix-Tree"><a href="#Radix-Tree" class="headerlink" title="Radix Tree"></a>Radix Tree</h2><p>作为有序索引，Radix Tree 也能提供范围查询，和我们日常使用的 B+ 树，以及第5讲中介绍的跳表相比，你觉得 Radix Tree 有什么优势和不足么？</p>
<ol>
<li>Radix Tree 优势</li>
</ol>
<ul>
<li>本质上是前缀树，所以存储有「公共前缀」的数据时，比 B+ 树、跳表节省内存</li>
<li>没有公共前缀的数据项，压缩存储，value 用 listpack 存储，也可以节省内存</li>
<li>查询复杂度是 O(K)，只与「目标长度」有关，与总数据量无关</li>
<li>这种数据结构也经常用在搜索引擎提示、文字自动补全等场景</li>
</ul>
<p>Stream 在存消息时，推荐使用默认自动生成的「时间戳+序号」作为消息 ID，不建议自己指定消息 ID，这样才能发挥 Radix Tree 公共前缀的优势。</p>
<ol start="2">
<li>Radix Tree 不足</li>
</ol>
<ul>
<li>如果数据集公共前缀较少，会导致内存占用多</li>
<li>增删节点需要处理其它节点的「分裂、合并」，跳表只需调整前后指针即可</li>
<li>B+ 树、跳表范围查询友好，直接遍历链表即可，Radix Tree 需遍历树结构</li>
<li>实现难度高比 B+ 树、跳表复杂</li>
</ul>
<p>每种数据结构都是在面对不同问题场景下，才被设计出来的，结合各自场景中的数据特点，使用优势最大的数据结构才是正解。</p>
<h1 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h1><h2 id="Redis-Server"><a href="#Redis-Server" class="headerlink" title="Redis Server"></a>Redis Server</h2><p>Redis 启动流程，主要的工作有：</p>
<ol>
<li>初始化前置操作（设置时区、随机种子）</li>
<li>初始化 Server 的各种默认配置（server.c 的 initServerConfig 函数），默认配置见 server.h 中的 CONFIG_DEFAULT_XXX，比较典型的配置有：</li>
</ol>
<ul>
<li>默认端口</li>
<li>定时任务频率</li>
<li>数据库数量</li>
<li>AOF 刷盘策略</li>
<li>淘汰策略</li>
<li>数据结构转换阈值</li>
<li>主从复制参数</li>
</ul>
<ol start="3">
<li>加载配置启动参数，覆盖默认配置（config.c 的 loadServerConfig 函数）：</li>
</ol>
<ul>
<li>解析命令行参数</li>
<li>解析配置文件</li>
</ul>
<ol start="3">
<li>初始化 Server（server.c 的 initServer 函数），例如会初始化：</li>
</ol>
<ul>
<li>共享对象池</li>
<li>客户端链表</li>
<li>从库链表</li>
<li>监听端口</li>
<li>全局哈希表</li>
<li>LRU 池</li>
<li>注册定时任务函数</li>
<li>注册监听请求函数</li>
</ul>
<ol start="4">
<li>启动事件循环（ae.c 的 aeMain 函数）</li>
</ol>
<ul>
<li>处理请求</li>
<li>处理定时任务</li>
</ul>
<p>这里补充一下，初始化 Server 完成后，Redis 还会启动 3 类后台线程（server.c 的 InitServerLast 函数），协助主线程工作（异步释放 fd、AOF 每秒刷盘、lazyfree）。</p>
<p>课后题：Redis 源码的 main 函数在调用 initServer 函数之前，会执行如下的代码片段，你知道这个代码片段的作用是什么吗？</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;
   ...
   server.supervised = redisIsSupervised(server.supervised_mode);
   <span class="hljs-keyword">int</span> background = server.daemonize &amp;&amp; !server.supervised;
   <span class="hljs-keyword">if</span> (background) daemonize();
   ...
&#125;</code></pre></div>

<p>Redis 可以配置以守护进程的方式启动（配置文件 daemonize = yes），也可以把 Redis 托管给 upstart 或 systemd 来启动 / 停止（supervised = upstart|systemd|auto）。</p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><ol>
<li>单线程服务器模型，面临的最大的问题就是，一个线程如何处理多个客户端请求？解决这种问题的办法就是「IO 多路复用」。它本质上是应用层不用维护多个客户端的连接状态，而是把它们「托管」给了操作系统，操作系统维护这些连接的状态变化，之后应用层只管问操作系统，哪些 socket 有数据可读/可写就好了，大大简化了应用层的复杂度</li>
<li>IO 多路复用机制要想高效使用，一般还需要把 socket 设置成「非阻塞」模式，即 socket 没有数据可读/可写时，应用层去 read/write socket 也不会阻塞住（内核会返回指定错误，应用层可继续重试），这样应用层就可以去处理其它业务逻辑，不会阻塞影响性能</li>
<li>为什么 Redis 要使用「单线程」处理客户端请求？本质上是因为，Redis 操作的是内存，操作内存数据是极快的，所以 Redis 的瓶颈不在 CPU，优化的重点就在网络 IO 上，高效的 IO 多路复用机制，正好可以满足这种需求，模型简单，性能也极高</li>
<li>但成也萧何败也萧何，因为 Redis 处理请求是「单线程」，所以如果有任意请求在 Server 端发生耗时（例如操作 bigkey，或一次请求数据过多），就会导致后面的请求发生「排队」，业务端就会感知到延迟增大，性能下降</li>
<li>基于此，Redis 又做了很多优化：一些耗时的操作，不再放在主线程处理，而是丢到后台线程慢慢执行。例如，异步关闭 fd，异步释放内存、后台 AOF 刷盘这些操作。所以 Redis Server 其实是「多线程」的，只不过最核心的处理请求逻辑是单线程的，这点一定要区分开</li>
</ol>
<p>课后题：在 Redis 事件驱动框架代码中，分别使用了 Linux 系统上的 select 和 epoll 两种机制，你知道为什么 Redis 没有使用 poll 这一机制吗？</p>
<p>首先要明确一点，select 并不是只有 Linux 才支持的，Windows 平台也支持。</p>
<p>而 Redis 针对不同操作系统，会选择不同的 IO 多路复用机制来封装事件驱动框架，具体代码见 ae.c。</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// ae.c</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HAVE_EVPORT</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ae_evport.c&quot;</span> <span class="hljs-comment">// Solaris</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HAVE_EPOLL</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ae_epoll.c&quot;</span> <span class="hljs-comment">// Linux</span></span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HAVE_KQUEUE</span>
        <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ae_kqueue.c&quot;</span> <span class="hljs-comment">// MacOS</span></span>
        <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ae_select.c&quot;</span> <span class="hljs-comment">// Windows</span></span>
        <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre></div>

<p>仔细看上面的代码逻辑，先判断了 Solaris/Linux/MacOS 系统，选择对应的多路复用模型，最后剩下的系统都用 select 模型。</p>
<p>所以我理解，select 并不是为 Linux 服务的，而是在 Windows 下使用的。</p>
<p>因为 epoll 性能优于 select 和 poll，所以 Linux 平台下，Redis 直接会选择 epoll。而 Windows 不支持 epoll 和 poll，所以会用 select 模型。</p>
<h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><ol>
<li><p>为了高效处理网络 IO 的「连接事件」、「读事件」、「写事件」，演化出了 Reactor 模型</p>
</li>
<li><p>Reactor 模型主要有 reactor、acceptor、handler 三类角色：</p>
</li>
</ol>
<ul>
<li>reactor：分配事件</li>
<li>acceptor：接收连接请求</li>
<li>handler：处理业务逻辑</li>
</ul>
<ol start="3">
<li>Reactor 模型又分为 3 类：</li>
</ol>
<ul>
<li>单 Reactor 单线程：accept -&gt; read -&gt; 处理业务逻辑 -&gt; write 都在一个线程</li>
<li>单 Reactor 多线程：accept/read/write 在一个线程，处理业务逻辑在另一个线程</li>
<li>多 Reactor 多线程 / 进程：accept 在一个线程/进程，read/处理业务逻辑/write 在另一个线程/进程</li>
</ul>
<ol start="4">
<li>Redis 6.0 以下版本，属于单 Reactor 单线程模型，监听请求、读取数据、处理请求、写回数据都在一个线程中执行，这样会有 3 个问题：</li>
</ol>
<ul>
<li>单线程无法利用多核</li>
<li>处理请求发生耗时，会阻塞整个线程，影响整体性能</li>
<li>并发请求过高，读取/写回数据存在瓶颈</li>
</ul>
<ol start="5">
<li>针对问题 3，Redis 6.0 进行了优化，引入了 IO 多线程，把读写请求数据的逻辑，用多线程处理，提升并发性能，但处理请求的逻辑依旧是单线程处理</li>
</ol>
<p>课后题：除了 Redis，你还了解什么软件系统使用了 Reactor 模型吗？</p>
<p>Netty、Memcached 采用多 Reactor 多线程模型。</p>
<p>Nginx 采用多 Reactor 多进程模型，不过与标准的多 Reactor 多进程模型有些许差异。Nginx 的主进程只用来初始化 socket，不会 accept 连接，而是由子进程 accept 连接，之后这个连接的所有处理都在子进程中完成。</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ol>
<li>Redis 事件循环主要处理两类事件：文件事件、时间事件</li>
</ol>
<ul>
<li>文件事件包括：client 发起新连接、client 向 server 写数据、server 向 client 响应数据</li>
<li>时间事件：Redis 的各种定时任务（主线程中执行）</li>
</ul>
<ol start="2">
<li>Redis 在启动时，会创建 aeEventLoop，初始化 epoll 对象，监听端口，之后会注册文件事件、时间事件：</li>
</ol>
<ul>
<li>文件事件：把 listen socket fd 注册到 epoll 中，回调函数是 acceptTcpHandler（新连接事件）</li>
<li>时间事件：把 serverCron 函数注册到 aeEventLoop 中，并指定执行频率</li>
</ul>
<ol start="3">
<li>Redis Server 启动后，会启动一个死循环，持续处理事件（ae.c 的 aeProcessEvents 函数）</li>
<li>有文件事件（网络 IO)，则优先处理。例如，client 到 server 的新连接，会调用 acceptTcpHandler 函数，之后会注册读事件 readQueryFromClient 函数，client 发给 server 的数据，都会在这个函数处理，这个函数会解析 client 的数据，找到对应的 cmd 函数执行</li>
<li>cmd 逻辑执行完成后，server 需要写回数据给 client，会先把响应数据写到对应 client 的 内存 buffer 中，在下一次处理 IO 事件之前，Redis 会把每个 client 的 buffer 数据写到 client 的 socket 中，给 client 响应</li>
<li>如果响应给 client 的数据过多，则会分多次发送，待发送的数据会暂存到 buffer，然后会向 epoll 注册回调函数 sendReplyToClient，待 socket 可写时，继续调用回调函数向 client 写回剩余数据</li>
<li>在这个死循环中处理每次事件时，都会先检查一下，时间事件是否需要执行，因为之前已经注册好了时间事件的回调函数 + 执行频率，所以在执行 aeApiPoll 时，timeout 就是定时任务的周期，这样即使没有 IO 事件，epoll_wait 也可以正常返回，此时就可以执行一次定时任务 serverCron 函数，这样就可以在一个线程中就完成 IO 事件 + 定时任务的处理</li>
</ol>
<p>课后题：Redis 在调用 aeApiCreate、aeApiAddEvent 这些函数时，是根据什么条件来决定，具体调用哪个文件中的 IO 多路复用函数的？</p>
<p>在 ae.c 中，根据不同平台，首先定义好了要导入的封装好的 IO 多路复用函数，每个平台对应的文件中都定义了 aeApiCreate、aeApiAddEvent 这类函数，在执行时就会执行对应平台的函数逻辑。</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// ae.c</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HAVE_EVPORT</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ae_evport.c&quot;</span> <span class="hljs-comment">// Solaris</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HAVE_EPOLL</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ae_epoll.c&quot;</span> <span class="hljs-comment">// Linux</span></span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HAVE_KQUEUE</span>
        <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ae_kqueue.c&quot;</span> <span class="hljs-comment">// MacOS</span></span>
        <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ae_select.c&quot;</span> <span class="hljs-comment">// Windows</span></span>
        <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre></div>


<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><ol>
<li>很多人认为 Redis 是单线程，这个描述是不准确的。准确来说 Redis 只有在处理「客户端请求」时，是单线程的。但整个 Redis Server 并不是单线程的，还有后台线程在辅助处理一些工作</li>
<li>Redis 选择单线程处理请求，是因为 Redis 操作的是「内存」，加上设计了「高效」的数据结构，所以操作速度极快，利用 IO 多路复用机制，单线程依旧可以有非常高的性能</li>
<li>但如果一个请求发生耗时，单线程的缺点就暴露出来了，后面的请求都要「排队」等待，所以 Redis 在启动时会启动一些「后台线程」来辅助工作，目的是把耗时的操作，放到后台处理，避免主线程操作耗时影响整体性能</li>
<li>例如关闭 fd、AOF 刷盘、释放 key 的内存，这些耗时操作，都可以放到后台线程中处理，对主逻辑没有任何影响</li>
<li>后台线程处理这些任务，就相当于一个消费者，生产者（主线程）把耗时任务丢到队列中（链表），消费者不停轮询这个队列，拿出任务就去执行对应的方法即可：</li>
</ol>
<ul>
<li>BIO_CLOSE_FILE：close(fd)</li>
<li>BIO_AOF_FSYNC：fsync(fd)</li>
<li>BIO_LAZY_FREE：free(obj) / free(dict) / free(skiplist)</li>
</ul>
<p>课后题：Redis 后台任务使用 bio_job 结构体来描述，该结构体用了三个指针变量来表示任务参数，如果我们创建的任务，所需要的参数大于 3 个，你有什么应对方法来传参么？</p>
<p>最直接的方法就是，把参数换成数组类型，这样就可以传递任意数量参数了。因为这里 Redis 的后台任务都比较简单，最多 3 个参数就足够满足需求，所以 job 直接写死了 3 个参数变量，这样做的好处是维护起来简单直接。</p>
<h2 id="多IO线程"><a href="#多IO线程" class="headerlink" title="多IO线程"></a>多IO线程</h2><ol>
<li>Redis 6.0 之前，处理客户端请求是单线程，这种模型的缺点是，只能用到「单核」CPU。如果并发量很高，那么在读写客户端数据时，容易引发性能瓶颈，所以 Redis 6.0 引入了多 IO 线程解决这个问题</li>
<li>配置文件开启 io-threads N 后，Redis Server 启动时，会启动 N - 1 个 IO 线程（主线程也算一个 IO 线程），这些 IO 线程执行的逻辑是 networking.c 的 IOThreadMain 函数。但默认只开启多线程「写」client socket，如果要开启多线程「读」，还需配置 io-threads-do-reads = yes</li>
<li>Redis 在读取客户端请求时，判断如果开启了 IO 多线程，则把这个 client 放到 clients_pending_read 链表中（postponeClientRead 函数），之后主线程在处理每次事件循环之前，把链表数据轮询放到 IO 线程的链表（io_threads_list）中</li>
<li>同样地，在写回响应时，是把 client 放到 clients_pending_write 中（prepareClientToWrite 函数），执行事件循环之前把数据轮询放到 IO 线程的链表（io_threads_list）中</li>
<li>主线程把 client 分发到 IO 线程时，自己也会读写客户端 socket（主线程也要分担一部分读写操作），之后「等待」所有 IO 线程完成读写，再由主线程「串行」执行后续逻辑</li>
<li>每个 IO 线程，不停地从 io_threads_list 链表中取出 client，并根据指定类型读、写 client socket</li>
<li>IO 线程在处理读、写 client 时有些许差异，如果 write_client_pedding &lt; io_threads * 2，则直接由「主线程」负责写，不再交给 IO 线程处理，从而节省 CPU 消耗</li>
<li>Redis 官方建议，服务器最少 4 核 CPU 才建议开启 IO 多线程，4 核 CPU 建议开 2-3 个 IO 线程，8 核 CPU 开 6 个 IO 线程，超过 8 个线程性能提升不大</li>
<li>Redis 官方表示，开启多 IO 线程后，性能可提升 1 倍。当然，如果 Redis 性能足够用，没必要开 IO 线程</li>
</ol>
<p>课后题：为什么 startThreadedIO / stopThreadedIO 要执行加解锁？</p>
<p>既然涉及到加锁操作，必然是为了「互斥」从而控制某些逻辑。可以在代码中检索这个锁变量，看存在哪些逻辑对 io_threads_mutex 操作了加解锁。</p>
<p>跟踪代码可以看到，在 networking.c 的 IOThreadMain 函数，也对这个变量进行了加解锁操作，那就说明 startThreadedIO / stopThreadedIO 函数，可以控制 IOThreadMain 里逻辑的执行，IOThreadMain 代码如下。</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">IOThreadMain</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *myid)</span> </span>&#123;
    ...
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;
    ...
    <span class="hljs-comment">/* Give the main thread a chance to stop this thread. */</span>
    <span class="hljs-keyword">if</span> (io_threads_pending[id] == <span class="hljs-number">0</span>) &#123;
    pthread_mutex_lock(&amp;io_threads_mutex[id]);
    pthread_mutex_unlock(&amp;io_threads_mutex[id]);
    <span class="hljs-keyword">continue</span>;
    &#125;
    <span class="hljs-comment">// 读写 client socket</span>
    <span class="hljs-comment">// ...</span>
&#125;</code></pre></div>

<p>这个函数正是 IO 多线程的主逻辑。</p>
<p>从注释可以看到，这是为了给主线程停止 IO 线程的的机会。也就是说，这里的目的是为了让主线程可以控制 IO 线程的开启 / 暂停。</p>
<p>因为每次 IO 线程在执行时必须先拿到锁，才能执行后面的逻辑，如果主线程执行了 stopThreadedIO，就会先拿到锁，那么 IOThreadMain 函数在执行时就会因为拿不到锁阻塞「等待」，这就达到了 stop IO 线程的目的。</p>
<p>同样地，调用 startThreadedIO 函数后，会释放锁，IO 线程就可以拿到锁，继续「恢复」执行。</p>
<h2 id="分布式的原子性"><a href="#分布式的原子性" class="headerlink" title="分布式的原子性"></a>分布式的原子性</h2><ol>
<li>无论是 IO 多路复用，还是 Redis 6.0 的多 IO 线程，Redis 执行具体命令的主逻辑依旧是「单线程」的</li>
<li>执行命令是单线程，本质上就保证了每个命令必定是「串行」执行的，前面请求处理完成，后面请求才能开始处理</li>
<li>所以 Redis 在实现分布式锁时，内部不需要考虑加锁问题，直接在主线程中判断 key 是否存在即可，实现起来非常简单</li>
</ol>
<p>课后题：如果将命令处理过程中的命令执行也交给多 IO 线程执行，除了对原子性会有影响，还会有什么好处和坏处？</p>
<p>好处：</p>
<ul>
<li>每个请求分配给不同的线程处理，一个请求处理慢，并不影响其它请求</li>
<li>请求操作的 key 越分散，性能会变高（并行处理比串行处理性能高）</li>
<li>可充分利用多核 CPU 资源</li>
</ul>
<p>坏处：</p>
<ul>
<li>操作同一个 key 需加锁，加锁会影响性能，如果是热点 key，性能下降明显</li>
<li>多线程上下文切换存在性能损耗</li>
<li>多线程开发和调试不友好</li>
</ul>
<h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><ol>
<li>实现一个严格的 LRU 算法，需要额外的内存构建 LRU 链表，同时维护链表也存在性能开销，Redis 对于内存资源和性能要求极高，所以没有采用严格 LRU 算法，而是采用「近似」LRU 算法实现数据淘汰策略</li>
<li>触发数据淘汰的时机，是每次处理「请求」时判断的。也就是说，执行一个命令之前，首先要判断实例内存是否达到 maxmemory，是的话则先执行数据淘汰，再执行具体的命令</li>
<li>淘汰数据时，会「持续」判断 Redis 内存是否下降到了 maxmemory 以下，不满足的话会继续淘汰数据，直到内存下降到 maxmemory 之下才会停止</li>
<li>可见，如果发生大量淘汰的情况，那么处理客户端请求就会发生「延迟」，影响性能</li>
<li>Redis 计算实例内存时，不会把「主从复制」的缓冲区计算在内，也就是说不管一个实例后面挂了多少个从库，主库不会把主从复制所需的「缓冲区」内存，计算到实例内存中，即这部分内存增加，不会对数据淘汰产生影响</li>
<li>但如果 Redis 内存已达到 maxmemory，要谨慎执行 MONITOR 命令，因为 Redis Server 会向执行 MONITOR 的 client 缓冲区填充数据，这会导致缓冲区内存增长，进而引发数据淘汰</li>
</ol>
<p>课后题：为什么键值对的 LRU 时钟值，不是直接通过调用 getLRUClock 函数来获取？</p>
<p>本质上是为了性能。</p>
<p>Redis 这种对性能要求极高的数据库，在系统调用上的优化也做到了极致。</p>
<p>获取机器时钟本质上也是一个「系统调用」，对于 Redis 这种动不动每秒上万的 QPS，如果每次都触发一次系统调用，这么频繁的操作也是一笔不小的开销。</p>
<p>所以，Redis 用一个定时任务（serverCron 函数），以固定频率触发系统调用获取机器时钟，然后把机器时钟挂到 server 的全局变量下，这相当于维护了一个「本地缓存」，当需要获取时钟时，直接从全局变量获取即可，节省了大量的系统调用开销。</p>
<h2 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h2><ol>
<li>LFU 是在 Redis 4.0 新增的淘汰策略，它涉及的巧妙之处在于，其复用了 redisObject 结构的 lru 字段，把这个字段「一分为二」，保存最后访问时间和访问次数</li>
<li>key 的访问次数不能只增不减，它需要根据时间间隔来做衰减，才能达到 LFU 的目的</li>
<li>每次在访问一个 key 时，会「懒惰」更新这个 key 的访问次数：先衰减访问次数，再更新访问次数</li>
<li>衰减访问次数，会根据时间间隔计算，间隔时间越久，衰减越厉害</li>
<li>因为 redisObject lru 字段宽度限制，这个访问次数是有上限的（8 bit 最大值 255），所以递增访问次数时，会根据「当前」访问次数和「概率」的方式做递增，访问次数越大，递增因子越大，递增概率越低</li>
<li>Redis 实现的 LFU 算法也是「近似」LFU，是在性能和内存方面平衡的结果</li>
</ol>
<p>课后题：LFU 算法在初始化键值对的访问次数时，会将访问次数设置为 LFU_INIT_VAL，默认值是 5 次。如果 LFU_INIT_VAL 设置为 1，会发生什么情况？</p>
<p>如果开启了 LFU，那在写入一个新 key 时，需要初始化访问时间、访问次数（createObject 函数），如果访问次数初始值太小，那这些新 key 的访问次数，很有可能在短时间内就被「衰减」为 0，那就会面临马上被淘汰的风险。</p>
<p>新 key 初始访问次数 LFU_INIT_VAL = 5，就是为了避免一个 key 在创建后，不会面临被立即淘汰的情况发生。</p>
<h2 id="Lazy-Free"><a href="#Lazy-Free" class="headerlink" title="Lazy Free"></a>Lazy Free</h2><ol>
<li>lazy-free 是 4.0 新增的功能，默认是关闭的，需要手动开启</li>
<li>开启 lazy-free 时，有多个「子选项」可以控制，分别对应不同场景下，是否开启异步释放内存：</li>
</ol>
<ul>
<li>lazyfree-lazy-expire：key 在过期删除时尝试异步释放内存</li>
<li>lazyfree-lazy-eviction：内存达到 maxmemory 并设置了淘汰策略时尝试异步释放内存</li>
<li>lazyfree-lazy-server-del：执行 RENAME/MOVE 等命令或需要覆盖一个 key 时，Redis 内部删除旧 key 尝试异步释放内存</li>
<li>replica-lazy-flush：主从全量同步，从库清空数据库时异步释放内存</li>
</ul>
<ol start="3">
<li>即使开启了 lazy-free，但如果执行的是 DEL 命令，则还是会同步释放 key 内存，只有使用 UNLINK 命令才「可能」异步释放内存</li>
<li>Redis 6.0 版本新增了一个新的选项 lazyfree-lazy-user-del，打开后执行 DEL 就与 UNLINK 效果一样了</li>
<li>最关键的一点，开启 lazy-free 后，除 replica-lazy-flush 之外，其它选项都只是「可能」异步释放 key 的内存，并不是说每次释放 key 内存都是丢到后台线程的</li>
<li>开启 lazy-free 后，Redis 在释放一个 key 内存时，首先会评估「代价」，如果代价很小，那么就直接在「主线程」操作了，「没必要」放到后台线程中执行（不同线程传递数据也会有性能消耗）</li>
<li>什么情况才会真正异步释放内存？这和 key 的类型、编码方式、元素数量都有关系（详见 lazyfreeGetFreeEffort 函数）：</li>
</ol>
<ul>
<li>当 Hash/Set 底层采用哈希表存储（非 ziplist/int 编码存储）时，并且元素数量超过 64 个</li>
<li>当 ZSet 底层采用跳表存储（非 ziplist 编码存储）时，并且元素数量超过 64 个</li>
<li>当 List 链表节点数量超过 64 个（注意，不是元素数量，而是链表节点的数量，List 底层实现是一个链表，链表每个节点是一个 ziplist，一个 ziplist 可能有多个元素数据）</li>
</ul>
<p>只有满足以上条件，在释放 key 内存时，才会真正放到「后台线程」中执行，其它情况一律还是在主线程操作。</p>
<p>也就是说 String（不管内存占用多大）、List（少量元素）、Set（int 编码存储）、Hash/ZSet（ziplist 编码存储）这些情况下的 key，在释放内存时，依旧在「主线程」中操作。</p>
<ol start="8">
<li>可见，即使打开了 lazy-free，String 类型的 bigkey，在删除时依旧有「阻塞」主线程的风险。所以，即便 Redis 提供了 lazy-free，还是不建议在 Redis 存储 bigkey</li>
</ol>
<p>9、Redis 在释放内存「评估」代价时，不是看 key 的内存大小，而是关注释放内存时的「工作量」有多大。从上面分析可以看出，如果 key 内存是连续的，释放内存的代价就比较低，则依旧放在「主线程」处理。如果 key 内存不连续（包含大量指针），这个代价就比较高，这才会放在「后台线程」中执行</p>
<p>课后题：freeMemoryIfNeeded 函数在使用后台线程，删除被淘汰数据的过程中，主线程是否仍然可以处理外部请求？</p>
<p>肯定是可以继续处理请求的。</p>
<p>主线程决定淘汰这个 key 之后，会先把这个 key 从「全局哈希表」中剔除，然后评估释放内存的代价，如果符合条件，则丢到「后台线程」中执行「释放内存」操作。</p>
<p>之后就可以继续处理客户端请求，尽管后台线程还未完成释放内存，但因为 key 已被全局哈希表剔除，所以主线程已查询不到这个 key 了，对客户端来说无影响。</p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><ol>
<li>RDB 文件是 Redis 的数据快照，以「二进制」格式存储，相比 AOF 文件更小，写盘和加载时间更短</li>
<li>RDB 在执行 SAVE / BGSAVE 命令、定时 BGSAVE、主从复制时产生</li>
<li>RDB 文件包含文件头、数据部分、文件尾</li>
<li>文件头主要包括 Redis 的魔数、RDB 版本、Redis 版本、RDB 创建时间、键值对占用的内存大小等信息</li>
<li>文件数据部分包括整个 Redis 数据库中存储的所有键值对信息</li>
</ol>
<ul>
<li>数据库信息：db 编号、db 中 key 的数量、过期 key 的数量、键值数据</li>
<li>键值数据：过期标识、时间戳（绝对时间）、键值对类型、key 长度、key、value 长度、value</li>
</ul>
<ol start="6">
<li>文件尾保存了 RDB 的结束标记、文件校验值</li>
<li>RDB 存储的数据，为了压缩体积，还做了很多优化:</li>
</ol>
<ul>
<li>变长编码存储键值对数据</li>
<li>用操作码标识不同的内容</li>
<li>可整数编码的内容使用整数类型紧凑编码</li>
</ul>
<p>课后题：在 serverCron 函数中，rdbSaveBackground 函数一共会被调用执行几次？这又分别对应了什么场景？</p>
<p>在 serverCron 函数中 rdbSaveBackground 会被调用 2 次。</p>
<p>一次是满足配置的定时 RDB 条件后（save <seconds> &lt;changes），触发子进程生成 RDB。</p>
<p>另一次是客户端执行了 BGSAVE 命令，Redis 会先设置 server.rdb_bgsave_scheduled = 1，之后 serverCron 函数判断这个变量为 1，也会触发子进程生成 RDB。</p>
<h2 id="AOF-上"><a href="#AOF-上" class="headerlink" title="AOF 上"></a>AOF 上</h2><ol>
<li>AOF 记录的是每个命令的「操作历史」，随着时间增长，AOF 文件会越来越大，所以需要 AOF 重写来「瘦身」，减小文件体积</li>
<li>AOF 重写时，会扫描整个实例中的数据，把数据以「命令 + 键值对」的格式，写到 AOF 文件中</li>
<li>触发 AOF 重写的时机有 4 个：</li>
</ol>
<ul>
<li>执行 bgrewriteaof 命令</li>
<li>手动打开 AOF 开关（config set appendonly yes）</li>
<li>从库加载完主库 RDB 后（AOF 被启动的前提下）</li>
<li>定时触发：AOF 文件大小比例超出阈值、AOF 文件大小绝对值超出阈值（AOF 被启动的前提下）</li>
</ul>
<p>这 4 个时机，都不能有 RDB 子进程，否则 AOF 重写会延迟执行。</p>
<ol start="4">
<li>AOF 重写期间会禁用 rehash，不让父进程调整哈希表大小，目的是父进程「写时复制」拷贝大量内存页面</li>
</ol>
<p>课后题：为什么 Redis 源码中在有 RDB 子进程运行时，不会启动 AOF 重写子进程？</p>
<p>无论是生成 RDB 还是 AOF 重写，都需要创建子进程，然后把实例中的所有数据写到磁盘上，这个过程中涉及到两块：</p>
<ul>
<li>CPU：写盘之前需要先迭代实例中的所有数据，在这期间会耗费比较多的 CPU 资源，两者同时进行，CPU 资源消耗大</li>
<li>磁盘：同样地，RDB 和 AOF 重写，都是把内存数据落盘，在这期间 Redis 会持续写磁盘，如果同时进行，磁盘 IO 压力也会较大</li>
</ul>
<p>整体来说都是为了资源考虑，所以不会让它们同时进行。</p>
<h2 id="AOF-下"><a href="#AOF-下" class="headerlink" title="AOF 下"></a>AOF 下</h2><ol>
<li>AOF 重写是在子进程中执行，但在此期间父进程还会接收写操作，为了保证新的 AOF 文件数据更完整，所以父进程需要把在这期间的写操作缓存下来，然后发给子进程，让子进程追加到 AOF 文件中</li>
<li>因为需要父子进程传输数据，所以需要用到操作系统提供的进程间通信机制，这里 Redis 用的是「管道」，管道只能是一个进程写，另一个进程读，特点是单向传输</li>
<li>AOF 重写时，父子进程用了 3 个管道，分别传输不同类别的数据：</li>
</ol>
<ul>
<li>父进程传输数据给子进程的管道：发送 AOF 重写期间新的写操作</li>
<li>子进程完成重写后通知父进程的管道：让父进程停止发送新的写操作</li>
<li>父进程确认收到子进程通知的管道：父进程通知子进程已收到通知</li>
</ul>
<ol start="4">
<li>AOF 重写的完整流程是：父进程 fork 出子进程，子进程迭代实例所有数据，写到一个临时 AOF 文件，在写文件期间，父进程收到新的写操作，会先缓存到 buf 中，之后父进程把 buf 中的数据，通过管道发给子进程，子进程写完 AOF 文件后，会从管道中读取这些命令，再追加到 AOF 文件中，最后 rename 这个临时 AOF 文件为新文件，替换旧的 AOF 文件，重写结束</li>
</ol>
<p>课后题：Redis 中其它使用管道的地方还有哪些？</p>
<p>在源码中搜索 pipe 函数，能看到 server.child_info_pipe 和 server.module_blocked_pipe 也使用了管道。</p>
<p>其中 child_info_pipe 管道如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Pipe and data structures for child -&gt; parent info sharing. */</span>
<span class="hljs-keyword">int</span> child_info_pipe[<span class="hljs-number">2</span>]; <span class="hljs-comment">/* Pipe used to write the child_info_data. */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>
    <span class="hljs-keyword">int</span> process_type; <span class="hljs-comment">/* AOF or RDB child? */</span>
    <span class="hljs-keyword">size_t</span> cow_size; <span class="hljs-comment">/* Copy on write size. */</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> magic; <span class="hljs-comment">/* Magic value to make sure data is valid. */</span>
&#125; child_info_data;</code></pre></div>


<p>从注释能看出，子进程在生成 RDB 或 AOF 重写完成后，子进程通知父进程在这期间，父进程「写时复制」了多少内存，父进程把这个数据记录到 server 的 stat_rdb_cow_bytes / stat_aof_cow_bytes 下（childinfo.c 的 receiveChildInfo 函数），以便客户端可以查询到最后一次 RDB 和 AOF 重写期间写时复制时，新申请的内存大小。</p>
<p>而 module_blocked_pipe 管道主要服务于 Redis module。</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Pipe used to awake the event loop if a client blocked on a module command needs to be processed. */</span>
<span class="hljs-keyword">int</span> module_blocked_pipe[<span class="hljs-number">2</span>];</code></pre></div>

<p>看注释是指，如果被 module 命令阻塞的客户端需要处理，则会唤醒事件循环开始处理。</p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><ol>
<li>Redis 主从复制分为 4 个阶段：</li>
</ol>
<ul>
<li>初始化</li>
<li>建立连接</li>
<li>主从握手</li>
<li>数据传输（全量/增量复制）</li>
</ul>
<ol start="2">
<li>主从复制流程由于是是「从库」发起的，所以重点要看从库的执行流程</li>
<li>从库发起复制的方式有 3 个：</li>
</ol>
<ul>
<li>执行 slaveof / replicaof 命令</li>
<li>配置文件配置了主库的 ip port</li>
<li>启动实例时指定了主库的 ip port</li>
</ul>
<ol start="4">
<li>建议从 slaveof / replicaof 命令跟源码进去，来看整个主从复制的流程（入口在 replication.c 的 replicaofCommand 函数）</li>
<li>从库执行这个命令后，会先在 server 结构体上，记录主库的 ip port，然后把 server.repl_state 从 REPL_STATE_NONE 改为 REPL_STATE_CONNECT，「复制状态机」启动</li>
<li>随后从库会在定时任务（server.c 的 serverCron 函数）中会检测 server.repl_state 的状态，然后向主库发起复制请求（replication.c 的 replicationCron 函数），进入复制流程（replication.c 的 connectWithMaster 函数）</li>
<li>从库会与主库建立连接（REPL_STATE_CONNECTING），注册读事件（syncWithMaster 函数），之后主从进入握手认证阶段，从库会告知主库自己的 ip port 等信息，在这期间会流转多个状态（server.h 中定义的复制状态）：</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REPL_STATE_RECEIVE_PONG 3 <span class="hljs-comment">/* Wait for PING reply */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REPL_STATE_SEND_AUTH 4 <span class="hljs-comment">/* Send AUTH to master */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REPL_STATE_RECEIVE_AUTH 5 <span class="hljs-comment">/* Wait for AUTH reply */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REPL_STATE_SEND_PORT 6 <span class="hljs-comment">/* Send REPLCONF listening-port */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REPL_STATE_RECEIVE_PORT 7 <span class="hljs-comment">/* Wait for REPLCONF reply */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REPL_STATE_SEND_IP 8 <span class="hljs-comment">/* Send REPLCONF ip-address */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REPL_STATE_RECEIVE_IP 9 <span class="hljs-comment">/* Wait for REPLCONF reply */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REPL_STATE_SEND_CAPA 10 <span class="hljs-comment">/* Send REPLCONF capa */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REPL_STATE_RECEIVE_CAPA 11 <span class="hljs-comment">/* Wait for REPLCONF reply */</span></span></code></pre></div>

<ol start="8">
<li>完成握手后，从库向主库发送 PSYNC 命令和自己的 offset，首先尝试「增量同步」，如果 offset = -1，主库返回 FULLRESYNC 表示「全量同步」数据，否则返回 CONTINUE 增量同步</li>
<li>如果是全量同步，主库会先生成 RDB，从库等待，主库完成 RDB 后发给从库，从库接收 RDB，然后清空实例数据，加载 RDB，之后读取主库发来的「增量」数据</li>
<li>如果是增量同步，从库只需接收主库传来的增量数据即可</li>
</ol>
<p>课后题：当一个实例是主库时，为什么不需要使用状态机来实现主库在主从复制时的流程流转？</p>
<p>因为复制数据的发起方是从库，从库要求复制数据会经历多个阶段（发起连接、握手认证、请求数据），而主库只需要「被动」接收从库的请求，根据需要「响应数据」即可完成整个流程，所以主库不需要状态机流转。</p>
<h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><ol>
<li>哨兵和 Redis 实例是一套代码，只不过哨兵会根据启动参数（redis-sentinel 或 redis-server –sentinel），设置当前实例为哨兵模式（server.sentinel_mode = 1），然后初始化哨兵相关数据</li>
<li>哨兵模式的实例，只能执行一部分命令（ping、sentinel、subscribe、unsubscribe、psubscribe、punsubscribe、publish、info、role、client、shutdown、auth），其中 sentinel、publish、info、role 都是针对哨兵专门实现的</li>
<li>之后哨兵会初始化各种属性，例如哨兵实例 ID、用于故障切换的当前纪元、监听的主节点、正在执行的脚本数量、与其他哨兵实例发送的 IP 和端口号等信息</li>
<li>启动哨兵后，会检查配置文件是否可写（不可写直接退出，哨兵需把监控的实例信息写入配置文件）、是否配置了哨兵 ID（没配置随机生成一个）</li>
<li>最后哨兵会在监控的 master 实例的 PubSub（+monitor 频道）发布一条消息，表示哨兵开始监控 Redis 实例</li>
<li>哨兵后续会通过 PubSub 的方式，与主从库、其它哨兵实例进行通信</li>
</ol>
<p>课后题：哨兵实例本身是有配置文件 sentinel.conf 的，那么在哨兵实例的初始化过程中，解析这个配置文件的函数在哪？</p>
<p>Redis 启动时，会在 main 函数中调用 loadServerConfig 加载配置文件，loadServerConfig 函数会读取配置文件中的内容，然后调用 loadServerConfigFromString 函数解析具体的配置项。</p>
<p>loadServerConfigFromString 函数中，其中有一个分支，对哨兵模式进行了判断，如果是哨兵模式，则调用 sentinelHandleConfiguration 函数解析哨兵配置项。</p>
<p>所以，函数调用链为 main -&gt; loadServerConfig（读出配置文件内容） -&gt; loadServerConfigFromString（解析配置项） -&gt; sentinelHandleConfiguration（解析哨兵配置项）。</p>
<h2 id="哨兵选举-上"><a href="#哨兵选举-上" class="headerlink" title="哨兵选举 上"></a>哨兵选举 上</h2><ol>
<li>Redis 为了实现故障自动切换，引入了一个外部「观察者」检测实例的状态，这个观察者就是「哨兵」</li>
<li>但一个哨兵检测实例，有可能因为网络原因导致「误判」，所以需要「多个」哨兵共同判定</li>
<li>多个哨兵共同判定出实例故障后（主观下线、客观下线），会进入故障切换流程，切换时需要「选举」出一个哨兵「领导者」进行操作</li>
<li>这个选举的过程，就是「分布式共识」，即多个哨兵通过「投票」选举出一个都认可的实例当领导者，由这个领导者发起切换，这个选举使用的算法是 Raft 算法</li>
<li>严格来说，Raft 算法的核心流程是这样的：</li>
</ol>
<ul>
<li>集群正常情况下，Leader 会持续给 Follower 发心跳消息，维护 Leader 地位</li>
<li>如果 Follower 一段时间内收不到 Leader 心跳消息，则变为 Candidate 发起选举</li>
<li>Candidate 先给自己投一票，然后向其它节点发送投票请求</li>
<li>Candidate 收到超过半数确认票，则提升为新的 Leader，新 Leader 给其它 Follower 发心跳消息，维护新的 Leader 地位</li>
<li>Candidate 投票期间，收到了 Leader 心跳消息，则自动变为 Follower</li>
<li>投票结束后，没有超过半数确认票的实例，选举失败，会再次发起选举</li>
</ul>
<ol start="6">
<li>但哨兵的选举没有按照严格按照 Raft 实现，因为多个哨兵之间是「对等」关系，没有 Leader 和 Follower 角色，只有当 Redis 实例发生故障时，哨兵才选举领导者进行切换，选举 Leader 的过程是按照 Raft 算法步骤 3-6 实现的</li>
</ol>
<p>课后题：哨兵实例执行的周期性函数 sentinelTimer 的最后，修改 server.hz 的目的是什么？</p>
<p>server.hz 表示执行定时任务函数 serverCron 的频率，哨兵在最后修改 server.hz 增加一个随机值，是为了避免多个哨兵以「相同频率」执行，引发每个哨兵同时发起选举，进而导致没有一个哨兵能拿到多数投票，领导者选举失败的问题。适当打散执行频率，可以有效降低选举失败的概率。</p>
<h2 id="哨兵选举-下"><a href="#哨兵选举-下" class="headerlink" title="哨兵选举 下"></a>哨兵选举 下</h2><ol>
<li>一个哨兵检测判定主库故障，这个过程是「主观下线」，另外这个哨兵还会向其它哨兵询问（发送 sentinel is-master-down-by-addr 命令），多个哨兵都检测主库故障，数量达到配置的 quorum 值，则判定为「客观下线」</li>
<li>首先判定为客观下线的哨兵，会发起选举，让其它哨兵给自己投票成为「领导者」，成为领导者的条件是，拿到超过「半数」的确认票 + 超过预设的 quorum 阈值的赞成票</li>
<li>投票过程中会比较哨兵和主库的「纪元」（主库纪元 &lt; 发起投票哨兵的纪元 + 发起投票哨兵的纪元 &gt; 其它哨兵的纪元），保证一轮投票中一个哨兵只能投一次票</li>
</ol>
<p>课后题：哨兵在 sentinelTimer 函数中调用 sentinelHandleDictOfRedisInstances 函数，对每个主节点都执行 sentinelHandleRedisInstance 函数，并且还会对主节点的所有从节点也执行 sentinelHandleRedisInstance 函数，那么，哨兵会不会判断从节点的主观下线和客观下线？</p>
<p>sentinelHandleRedisInstance 函数逻辑如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sentinelHandleRedisInstance</span><span class="hljs-params">(sentinelRedisInstance *ri)</span> </span>&#123;
    ...

    <span class="hljs-comment">/* Every kind of instance */</span>
    <span class="hljs-comment">// 判断主观下线</span>
    sentinelCheckSubjectivelyDown(ri);

    ...

    <span class="hljs-comment">/* Only masters */</span>
    <span class="hljs-keyword">if</span> (ri-&gt;flags &amp; SRI_MASTER) &#123;
        <span class="hljs-comment">// 判断客观下线</span>
        sentinelCheckObjectivelyDown(ri);
        <span class="hljs-keyword">if</span> (sentinelStartFailoverIfNeeded(ri))
            sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_ASK_FORCED);
        sentinelFailoverStateMachine(ri);
        sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_NO_FLAGS);
    &#125;
&#125;</code></pre></div>

<p>可以看到，无论主库还是从库，哨兵都判断了「主观下线」，但只有主库才判断「客观下线」和「故障切换」。</p>
<h2 id="pub-sub"><a href="#pub-sub" class="headerlink" title="pub/sub"></a>pub/sub</h2><ol>
<li>哨兵是通过 master 的 PubSub 发现其它哨兵的：每个哨兵向 master 的 PubSub（<strong>sentinel</strong>:hello 频道）发布消息，同时也会订阅这个频道，这样每个哨兵就能拿到其它哨兵的 IP、端口等信息</li>
<li>每个哨兵有了其它哨兵的信息后，在判定 Redis 实例状态时，就可以互相通信、交换信息，共同判定实例是否真的故障</li>
<li>哨兵判定 Redis 实例故障、发起切换时，都会向 master 的 PubSub 的频道发布消息</li>
<li>客户端可以订阅 master 的 PubSub，感知到哨兵工作到了哪个状态节点，从而作出自己的反应</li>
<li>PubSub 的实现，其实就是 Redis 在内存中维护了一个「发布-订阅」映射表，订阅者执行 SUBSCRIBE 命令，Redis 会把订阅者加入到指定频道的「链表」下。发布者执行 PUBLISH，Redis 就找到这个映射表中这个频道的所有「订阅者」，把消息「实时转发」给这些订阅者</li>
</ol>
<p>课后题：在哨兵实例上执行 publish 命令，这条命令是不是就是由 pubsub.c 文件中的 publishCommand 函数来处理的?</p>
<p>以哨兵模式启动的 Redis 实例，会使用新「命令表」。</p>
<p>在 server.c 的 main 函数中可以看到，哨兵模式启动后，会调用 initSentinel 函数。</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initSentinel</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;
    ...

    <span class="hljs-comment">// 只添加 sentinelcmds 下的命令</span>
    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">sizeof</span>(sentinelcmds)/<span class="hljs-keyword">sizeof</span>(sentinelcmds[<span class="hljs-number">0</span>]); j++) &#123;
        <span class="hljs-keyword">int</span> retval;
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisCommand</span> *<span class="hljs-title">cmd</span> =</span> sentinelcmds+j;

        retval = dictAdd(server.commands, sdsnew(cmd-&gt;name), cmd);
        serverAssert(retval == DICT_OK);
    &#125;
    ...
&#125;</code></pre></div>

<p>可以看到只把 sentinelcmds 命令表添加到了 server.commands 中。sentinelcmds 如下：</p>
<div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisCommand</span> <span class="hljs-title">sentinelcmds</span>[] =</span> &#123;
    ...
    &#123;<span class="hljs-string">&quot;subscribe&quot;</span>,subscribeCommand,<span class="hljs-number">-2</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,
    &#123;<span class="hljs-string">&quot;publish&quot;</span>,sentinelPublishCommand,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,
    &#123;<span class="hljs-string">&quot;info&quot;</span>,sentinelInfoCommand,<span class="hljs-number">-1</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,
    ...
&#125;;</code></pre></div>

<p>可以看到哨兵的 PUBLISH 命令是由 sentinelPublishCommand 单独实现的，并非普通实例的 publishCommand。</p>
<h2 id="redis-性能测试"><a href="#redis-性能测试" class="headerlink" title="redis 性能测试"></a>redis 性能测试</h2><ol>
<li>redis-benchmark 是 Redis 官方提供的性能测试工具，一般都用这个工具测试其性能</li>
<li>测试性能结果，与客户端并发数、value 大小、是否用 pipeline 都有关系</li>
<li>除此之外，性能结果还受系统环境的影响，例如 CPU 负载、网络带宽、客户端和服务端是否在同一机器、实例是否部署在虚拟机、Redis 绑核情况都会影响性能结果</li>
<li>提升 Redis 性能的几点优化：</li>
</ol>
<ul>
<li>控制客户端并发数</li>
<li>value 小于 10KB</li>
<li>推荐使用 pipeline</li>
<li>隔离部署</li>
<li>保证 CPU、网络带宽负载正常</li>
<li>不部署在虚拟机</li>
<li>进程绑核</li>
<li>CPU 绑定网卡队列</li>
<li>Redis 内存碎片</li>
<li>不使用 Swap</li>
</ul>
<h2 id="RDB、AOF文件损坏"><a href="#RDB、AOF文件损坏" class="headerlink" title="RDB、AOF文件损坏"></a>RDB、AOF文件损坏</h2><ol>
<li>RDB 和 AOF 文件在写盘故障时，可能发生损坏不完整的情况，那使用其恢复数据就会出现问题，所以 Redis 提供了 2 个命令来检测文件是否有错误</li>
<li>要想检测出文件错误，那说明 RDB 和 AOF 必定是按照某种固定格式写入的，检测是否完整只需要按照其格式规则，发现不符即认为文件不完整</li>
<li>redis-check-rdb 命令检测 RDB，因为 RDB 有明确的文件头、数据部分、文件尾，读取文件发现不完整即报错</li>
<li>redis-check-aof 命令检测 AOF，AOF 按照 RESP 协议写入，按照这个协议可以读取每个命令参数个数、参数字符串长度，如果不符合协议格式，则说明不完整。但这个命令提供了 –fix 命令，可以修复 AOF 文件，实现原理是：把不完整的命令和后续部分，直接从 AOF 中删除</li>
</ol>
<p>课后题：redis_check_aof_main 函数是检测 AOF 文件的入口函数，但是它还会调用检测 RDB 文件的入口函数 redis_check_rdb_main，它的作用是什么？</p>
<p>Redis 在 4.0 版本支持了「混合持久化」，即在 AOF rewrite 期间，先以 RDB 格式写入到 AOF 文件中，再把后续命令追加到 AOF 中，这样 AOF rewrite 后的文件既包括了 RDB 格式，又包含 AOF 格式（目的是为了让 AOF 体积更小），所以 redis_check_rdb_main 在检测 AOF 文件时，RDB 和 AOF 文件格式都需要检测。</p>
<h2 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a>Gossip</h2><ol>
<li>多个节点组成一个分布式系统，它们之间需要交换数据，可以采用中心化的方式（依赖第三方系统，例如ZK），也可以采用非中心化（分布式协议，例如 Gossip）的方式</li>
<li>Redis Cluster 采用非中心化的方式 Gossip 协议，实现多个节点之间信息交换</li>
<li>集群中的每个实例，会按照固定频率，从集群中「随机」挑选部分实例，发送 PING 消息（自身实例状态、已知部分实例信息、slots 分布），用来交换彼此状态信息</li>
<li>收到 PING 的实例，会响应 PONG 消息，PONG 消息和 PING 消息格式一样，包含了自身实例状态、已知部分实例信息、slots 分布</li>
<li>这样经过几次交换后，集群中每个实例都能拿到其它实例的状态信息</li>
<li>即使有节点状态发生变化（新实例加入、节点故障、数据迁移），也可以通过 Gossip 协议的 PING-PONG 消息完成整个集群状态在每个实例上的同步</li>
</ol>
<p>课后题：为什么 clusterSendPing 函数计算 wanted 值时，是用的集群节点个数的十分之一？</p>
<p>这个和 Redis Cluster 判定实例「故障」逻辑有关了。</p>
<p>Redis Cluster 实例在周期性向其它实例交换信息时，会先随机选出 5 个实例，然后从中找出最久没通信过的实例，发送 PING 消息。</p>
<p>但这里有个问题，随机选出的这 5 个实例，有可能并不是整个「集群」中最久没通信过的，为了避免拿不到这些实例的状态，导致集群误以为这些实例已过期，所以制定了一个策略：如果和实例最近通信时间超过了 cluster-node-timeout / 2，那会立即向这个实例发送 PING 消息。</p>
<p>每次 PING 都会收到 PONG 响应，一来一回 2 次心跳包，来回都带有部分实例的状态信息，那在 cluster-node-timeout 时间内会收到 4 次心跳包。</p>
<p>又因为 Redis Cluster 计算故障转移超时时间是 cluster-node-timeout * 2，那这段时间内就能收到 8 个 PING + PONG 心跳包，每个心跳包中实例个数设置为集群的 1/10，那在故障转移期间就能收到集群 80%（8 * 1/10）节点发来的故障状态信息了，满足集群大部分节点发来的节点故障情况。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/redis/">redis</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%BA%90%E7%A0%81/">源码</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/redis/a/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Redis文章索引</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/redis/use/">
                        <span class="hidden-mobile">Redis核心技术与实战</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"1545f02c9a677f0bd433","clientSecret":"57b1b2091f1c8788e4a2722c7b05ba53bc1e6b18","repo":"zuoshuwen.github.io","owner":"zuoshuwen","admin":["zuoshuwen"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"<your own proxy>/https://github.com/login/oauth/access_token"},
          {
            id: '0771784e971280f3477259a32fa7a0a0'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        京ICP备18026333号-1
      </a>
    </span>
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>





  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?97f60cea7055dca81a77d34bd50655bf";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
