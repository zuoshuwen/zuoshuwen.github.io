

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="后端技术、笔记、教程">
  <meta name="author" content="sown">
  <meta name="keywords" content="go,golang,技术,后端,php,linux,redis,kubernetes,k8s,nginx,docker,网络,算法,">
  <meta name="description" content="数据结构之慢操作总结1一，作者讲了什么？  Redis的底层数据结构  二，作者是怎么把这事给讲明白的？  讲了Redis的数据结构：数据的保存形式与底层数据结构 由数据结构的异同点，引出数据操作的快慢原因  三，为了讲明白，作者讲了哪些要点？有哪些亮点？  亮点1：string，list，set，hast,sortset都只是数据的保存形式，底层的数据结构是：简单动态字符串，双向链表，压缩列表，">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis核心技术与实战">
<meta property="og:url" content="https://ilifes.com/redis/use/index.html">
<meta property="og:site_name" content="Sown">
<meta property="og:description" content="数据结构之慢操作总结1一，作者讲了什么？  Redis的底层数据结构  二，作者是怎么把这事给讲明白的？  讲了Redis的数据结构：数据的保存形式与底层数据结构 由数据结构的异同点，引出数据操作的快慢原因  三，为了讲明白，作者讲了哪些要点？有哪些亮点？  亮点1：string，list，set，hast,sortset都只是数据的保存形式，底层的数据结构是：简单动态字符串，双向链表，压缩列表，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ilifes.com/images/redis/datastruct-02.png">
<meta property="article:published_time" content="2021-06-16T00:00:00.000Z">
<meta property="article:modified_time" content="2021-10-10T15:07:09.731Z">
<meta property="article:author" content="sown">
<meta property="article:tag" content="使用">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://ilifes.com/images/redis/datastruct-02.png">
  
  <title>Redis核心技术与实战 - Sown</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"ilifes.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"97f60cea7055dca81a77d34bd50655bf","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"ButetqzXxYeinA3YL6tt2SI5-gzGzoHsz","app_key":"IQfQbzCDGqirp6rGE7bmsnzS","server_url":"https://butetqzx.lc-cn-n1-shared.com","path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Sown</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                程序设计
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/datastruct-algorithm/a/">
                    <i class="iconfont icon-notebook"></i>
                    数据结构与算法
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/design-pattern/a/">
                    <i class="iconfont icon-notebook"></i>
                    设计模式
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/program/a/">
                    <i class="iconfont icon-notebook"></i>
                    方案
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                编程
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/netprogram/a/">
                    <i class="iconfont icon-notebook"></i>
                    网络编程
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/golang/a/">
                    <i class="iconfont icon-notebook"></i>
                    Go
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/ios/a/">
                    <i class="iconfont icon-notebook"></i>
                    iOS
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/html5/a/">
                    <i class="iconfont icon-notebook"></i>
                    H5
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/applet/a/">
                    <i class="iconfont icon-notebook"></i>
                    小程序
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                架构
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/distributed/a/">
                    <i class="iconfont icon-notebook"></i>
                    分布式
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/microservices/a/">
                    <i class="iconfont icon-notebook"></i>
                    微服务
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/example/a/">
                    <i class="iconfont icon-notebook"></i>
                    方案设计
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/microservices/a/">
                    <i class="iconfont icon-notebook"></i>
                    架构模式
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/ddd/a/">
                    <i class="iconfont icon-notebook"></i>
                    领域驱动设计
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                开源学习
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/redis/a/">
                    <i class="iconfont icon-notebook"></i>
                    Redis
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/mysql/a/">
                    <i class="iconfont icon-notebook"></i>
                    MySQL
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/etcd/a/">
                    <i class="iconfont icon-notebook"></i>
                    Etcd
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-books"></i>
                数据
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/datadev/a/">
                    <i class="iconfont icon-notebook"></i>
                    数据开发
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/datanal/a/">
                    <i class="iconfont icon-notebook"></i>
                    数据分析
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/images/default.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Redis核心技术与实战">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-06-16 08:00" pubdate>
        2021年6月16日 早上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      29k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      90 分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Redis核心技术与实战</h1>
            
            <div class="markdown-body">
              <h2 id="数据结构之慢操作"><a href="#数据结构之慢操作" class="headerlink" title="数据结构之慢操作"></a>数据结构之慢操作</h2><h3 id="总结1"><a href="#总结1" class="headerlink" title="总结1"></a>总结1</h3><p>一，作者讲了什么？</p>
<ol>
<li>Redis的底层数据结构</li>
</ol>
<p>二，作者是怎么把这事给讲明白的？</p>
<ol>
<li>讲了Redis的数据结构：数据的保存形式与底层数据结构</li>
<li>由数据结构的异同点，引出数据操作的快慢原因</li>
</ol>
<p>三，为了讲明白，作者讲了哪些要点？有哪些亮点？</p>
<ol>
<li>亮点1：string，list，set，hast,sortset都只是数据的保存形式，底层的数据结构是：简单动态字符串，双向链表，压缩列表，哈希表，跳表，整数数组</li>
<li>亮点2：Redis使用了一个哈希表保存所有的键值对</li>
<li>要点1：五种数据形式的底层实现<br>a，string：简单动态字符串<br>b，list：双向链表，压缩列表<br>c，hash：压缩列表，哈希表<br>d，Sorted Set：压缩列表，跳表<br>e，set：哈希表，整数数组</li>
<li>要点2：List ,hash，set ,sorted set被统称为集合类型，一个键对应了一个集合的数据</li>
<li>要点3：集合类型的键和值之间的结构组织<br>a：Redis使用一个哈希表保存所有键值对，一个哈希表实则是一个数组，数组的每个元素称为哈希桶。<br>b：哈希桶中的元素保存的不是值的本身，而是指向具体值的指针</li>
<li>要点4：哈希冲突解决<br>a：Redis的hash表是全局的，所以当写入大量的key时，将会带来哈希冲突，已经rehash可能带来的操作阻塞<br>b：Redis解决hash冲突的方式，是链式哈希：同一个哈希桶中的多个元素用一个链表来保存<br>c：当哈希冲突链过长时，Redis会对hash表进行rehash操作。rehash就是增加现有的hash桶数量，分散entry元素。</li>
<li>要点5：rehash机制<br>a：为了使rehash操作更高效，Redis默认使用了两个全局哈希表：哈希表1和哈希表2，起始时hash2没有分配空间<br>b：随着数据增多，Redis执行分三步执行rehash;<br> 1，给hash2分配更大的内存空间，如是hash1的两倍<br> 2，把hash1中的数据重新映射并拷贝到哈希表2中<br> 3，释放hash1的空间</li>
<li>要点6：渐进式rehash<br>a：由于步骤2重新映射非常耗时，会阻塞redis<br>b：讲集中迁移数据，改成每处理一个请求时，就从hash1中的第一个索引位置，顺带将这个索引位置上的所有entries拷贝到hash2中。</li>
<li>要点7 ：压缩列表，跳表的特点<br>a：压缩列表类似于一个数组，不同的是:压缩列表在表头有三个字段zlbytes,zltail和zllen分别表示长度，列表尾的偏移量和列表中的entry的个数，压缩列表尾部还有一个zlend，表示列表结束<br>所以压缩列表定位第一个和最后一个是O(1),但其他就是O(n)<br>b：跳表：是在链表的基础上增加了多级索引，通过索引的几次跳转，实现数据快速定位</li>
</ol>
<p>四，对于作者所讲，我有哪些发散性思考？</p>
<p>五，在将来的哪些场景中，我能够用到它？</p>
<p>六，评论区收获</p>
<ol>
<li>数组和压缩列表可以提升内存利用率，因为他们的数据结构紧凑</li>
<li>数组对CPU高速缓存支持友好，当数据元素超过阈值时，会转为hash和跳表，保证查询效率时，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率。</li>
<li>内存利用率，数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少。Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，提高内存的利用率。</li>
<li>数组对CPU高速缓存支持更友好，所以Redis在设计时，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率。</li>
</ol>
<h2 id="单线程为什么快"><a href="#单线程为什么快" class="headerlink" title="单线程为什么快"></a>单线程为什么快</h2><h3 id="总结1-1"><a href="#总结1-1" class="headerlink" title="总结1"></a>总结1</h3><p>现在，我们知道了，Redis 单线程是指它对网络 IO 和数据读写的操作采用了一个线程，而采用单线程的一个核心原因是避免多线程开发的并发控制问题。单线程的 Redis 也能获得高性能，跟多路复用的 IO 模型密切相关，因为这避免了 accept() 和 send()/recv() 潜在的网络 IO 操作阻塞点。</p>
<h3 id="总结2"><a href="#总结2" class="headerlink" title="总结2"></a>总结2</h3><p>1，作者讲了什么？<br>redis实现单线程实现高性能IO的设计机制<br>2，作者是怎么把这事给讲明白的？<br>作者首先从简单的网络通信socket讲起，引出了非阻塞socket，由此谈到了著名的I/O多路复用，Linux内核的select/epoll机制<br>3，为了讲明白，作者讲了哪些要点?有哪些亮点？<br>（1）首先声明“redis单线程”这个概念的具体含义<br>（2）引入具体业务场景：redis的数据读取，事件处理机制模型<br>（3）解析单线程相对多线程带来的优势，已及多线程所特有的问题<br>（4）基于redis单线程的，设计机制，引出了网络socket的问题</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在“Redis 基本 IO 模型”图中，你觉得还有哪些潜在的性能瓶颈吗？</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>Redis单线程处理IO请求性能瓶颈主要包括2个方面：</p>
<ol>
<li>任意一个请求在server中一旦发生耗时，都会影响整个server的性能，也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。耗时的操作包括以下几种：<br>a. 操作bigkey：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时；<br>b. 使用复杂度过高的命令：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据；<br>c. 大量key集中过期：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；<br>d. 淘汰策略：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长；<br>e. AOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能；<br>f. 主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；</li>
<li>并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。</li>
</ol>
<p>针对问题1，一方面需要业务人员去规避，一方面Redis在4.0推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。</p>
<p>针对问题2，Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能，当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。</p>
<h2 id="AOF日志，宕机了，如何避免数据丢失"><a href="#AOF日志，宕机了，如何避免数据丢失" class="headerlink" title="AOF日志，宕机了，如何避免数据丢失"></a>AOF日志，宕机了，如何避免数据丢失</h2><h3 id="总结1-2"><a href="#总结1-2" class="headerlink" title="总结1"></a>总结1</h3><p>这个方法看似“简单”，但也是充分考虑了对 Redis 性能的影响。总结来说，它提供了 AOF 日志的三种写回策略，分别是 Always、Everysec 和 No，这三种策略在可靠性上是从高到低，而在性能上则是从低到高。</p>
<p>此外，为了避免日志文件过大，Redis 还提供了 AOF 重写机制，直接根据数据库里数据的最新状态，生成这些数据的插入命令，作为新日志。这个过程通过后台线程完成，避免了对主线程的阻塞。</p>
<p>其中，三种写回策略体现了系统设计中的一个重要原则 ，即 trade-off，或者称为“取舍”，指的就是在性能和可靠性保证之间做取舍。我认为，这是做系统设计和开发的一个关键哲学，我也非常希望，你能充分地理解这个原则，并在日常开发中加以应用。</p>
<p>不过，你可能也注意到了，落盘时机和重写机制都是在“记日志”这一过程中发挥作用的。例如，落盘时机的选择可以避免记日志时阻塞主线程，重写可以避免日志文件过大。但是，在“用日志”的过程中，也就是使用 AOF 进行故障恢复时，我们仍然需要把所有的操作记录都运行一遍。再加上 Redis 的单线程设计，这些命令操作只能一条一条按顺序执行，这个“重放”的过程就会很慢了。</p>
<h3 id="总结2-1"><a href="#总结2-1" class="headerlink" title="总结2"></a>总结2</h3><p>1，作者讲了什么？<br>本章讲了Redis两种持久化机制之一：AOF机制原理<br>aof日志记录了redis所有增删改的操作，保存在磁盘上，当redis宕机，需要恢复内存中的数据时，可以通过读取aop日志恢复数据，从而避免因redis异常导致的数据丢失</p>
<p>2，作者是怎么把这事给讲明白的？<br>（1）作者先讲述redis宕机会导致内存数据丢失，需要有一种机制在redis重启后恢复数据。<br>（2）介绍了AOF通过记录每一个对redis数据进行增删改的操作日志，可以实现这种功能<br>（2）介绍了AOF的运行机制，数据保存机制，以及由此带来的优点和缺点<br>3，为了讲明白，作者讲了哪些要点，有哪些亮点？<br>（1）亮点：记录操作的时机分为：“写前日志和写后日志”，这个是我之前所不知道的<br>（2）要点1：AOF是写后日志，这样带来的好处是，记录的所有操作命令都是正确的，不需要额外的语法检查，确保redis重启时能够正确的读取回复数据<br>（3）要点2：AOF日志写入磁盘是比较影响性能的，为了平衡性能与数据安全，开发了三种机制：①：立即写入②：按秒写入③：系统写入<br>（4）要点3：AOF日志会变得巨大，所以Redis提供了日志重整的机制，通过读取内存中的数据重新产生一份数据写入日志<br>4，对于作者所讲，我有哪些发散性的思考？<br>作者说系统设计“取舍”二字非常重要，这是我之前未曾意识到的。作者讲了fork子进程机制，是Linux系统的一个能力，在刘超的课中讲过，这鼓舞了我继续学习的信心<br>5，将来有哪些场景，我可以应用上它？<br>目前还没有机会直接操作生产的redis配置，但现在要学习，争取将来可以直接操作</p>
<h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><ol>
<li>AOF 日志重写的时候，是由 bgrewriteaof 子进程来完成的，不用主线程参与，我们今天说的非阻塞也是指子进程的执行不阻塞主线程。但是，你觉得，这个重写过程有没有其他潜在的阻塞风险呢？如果有的话，会在哪里阻塞？</li>
</ol>
<h3 id="解答1"><a href="#解答1" class="headerlink" title="解答1"></a>解答1</h3><p>Redis采用fork子进程重写AOF文件时，潜在的阻塞风险包括：fork子进程 和 AOF重写过程中父进程产生写入的场景，下面依次介绍。</p>
<p>a、fork子进程，fork这个瞬间一定是会阻塞主线程的（注意，fork时并不会一次性拷贝所有内存数据给子进程，老师文章写的是拷贝所有内存数据给子进程，我个人认为是有歧义的），fork采用操作系统提供的写实复制(Copy On Write)机制，就是为了避免一次性拷贝大量内存数据给子进程造成的长时间阻塞问题，但fork子进程需要拷贝进程必要的数据结构，其中有一项就是拷贝内存页表（虚拟内存和物理内存的映射索引表），这个拷贝过程会消耗大量CPU资源，拷贝完成之前整个进程是会阻塞的，阻塞时间取决于整个实例的内存大小，实例越大，内存页表越大，fork阻塞时间越久。拷贝内存页表完成后，子进程与父进程指向相同的内存地址空间，也就是说此时虽然产生了子进程，但是并没有申请与父进程相同的内存大小。那什么时候父子进程才会真正内存分离呢？“写实复制”顾名思义，就是在写发生时，才真正拷贝内存真正的数据，这个过程中，父进程也可能会产生阻塞的风险，就是下面介绍的场景。</p>
<p>b、fork出的子进程指向与父进程相同的内存地址空间，此时子进程就可以执行AOF重写，把内存中的所有数据写入到AOF文件中。但是此时父进程依旧是会有流量写入的，如果父进程操作的是一个已经存在的key，那么这个时候父进程就会真正拷贝这个key对应的内存数据，申请新的内存空间，这样逐渐地，父子进程内存数据开始分离，父子进程逐渐拥有各自独立的内存空间。因为内存分配是以页为单位进行分配的，默认4k，如果父进程此时操作的是一个bigkey，重新申请大块内存耗时会变长，可能会产阻塞风险。另外，如果操作系统开启了内存大页机制(Huge Page，页面大小2M)，那么父进程申请内存时阻塞的概率将会大大提高，所以在Redis机器上需要关闭Huge Page机制。Redis每次fork生成RDB或AOF重写完成后，都可以在Redis log中看到父进程重新申请了多大的内存空间。</p>
<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><ol start="2">
<li>AOF 重写也有一个重写日志，为什么它不共享使用 AOF 本身的日志呢？</li>
</ol>
<h3 id="解答2"><a href="#解答2" class="headerlink" title="解答2"></a>解答2</h3><p>AOF重写不复用AOF本身的日志，一个原因是父子进程写同一个文件必然会产生竞争问题，控制竞争就意味着会影响父进程的性能。二是如果AOF重写过程中失败了，那么原本的AOF文件相当于被污染了，无法做恢复使用。所以Redis AOF重写一个新文件，重写失败的话，直接删除这个文件就好了，不会对原先的AOF文件产生影响。等重写完成之后，直接替换旧文件即可。</p>
<p>这里要谢谢Kaito同学指出的文章中的歧义：fork子进程时，子进程是会拷贝父进程的页表，即虚实映射关系，而不会拷贝物理内存。子进程复制了父进程页表，也能共享访问父进程的内存数据了，此时，类似于有了父进程的所有内存数据。我的描述不太严谨了，非常感谢指出！</p>
<p>Kaito同学还提到了Huge page。这个特性大家在使用Redis也要注意。Huge page对提升TLB命中率比较友好，因为在相同的内存容量下，使用huge page可以减少页表项，TLB就可以缓存更多的页表项，能减少TLB miss的开销。</p>
<p>但是，这个机制对于Redis这种喜欢用fork的系统来说，的确不太友好，尤其是在Redis的写入请求比较多的情况下。因为fork后，父进程修改数据采用写时复制，复制的粒度为一个内存页。如果只是修改一个256B的数据，父进程需要读原来的内存页，然后再映射到新的物理地址写入。一读一写会造成读写放大。如果内存页越大（例如2MB的大页），那么读写放大也就越严重，对Redis性能造成影响。</p>
<p>Huge page在实际使用Redis时是建议关掉的。</p>
<h2 id="内存快照：宕机后，Redis如何实现快速恢复？"><a href="#内存快照：宕机后，Redis如何实现快速恢复？" class="headerlink" title="内存快照：宕机后，Redis如何实现快速恢复？"></a>内存快照：宕机后，Redis如何实现快速恢复？</h2><h3 id="总结1-3"><a href="#总结1-3" class="headerlink" title="总结1"></a>总结1</h3><p>这节课，我们学习了 Redis 用于避免数据丢失的内存快照方法。这个方法的优势在于，可以快速恢复数据库，也就是只需要把 RDB 文件直接读入内存，这就避免了 AOF 需要顺序、逐一重新执行操作命令带来的低效性能问题。</p>
<p>不过，内存快照也有它的局限性。它拍的是一张内存的“大合影”，不可避免地会耗时耗力。虽然，Redis 设计了 bgsave 和写时复制方式，尽可能减少了内存快照对正常读写的影响，但是，频繁快照仍然是不太能接受的。而混合使用 RDB 和 AOF，正好可以取两者之长，避两者之短，以较小的性能开销保证数据可靠性和性能。</p>
<p>最后，关于 AOF 和 RDB 的选择问题，我想再给你提三点建议：</p>
<ul>
<li>数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；</li>
<li>如果允许分钟级别的数据丢失，可以只使用 RDB；</li>
<li>如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。</li>
</ul>
<h3 id="总结2-2"><a href="#总结2-2" class="headerlink" title="总结2"></a>总结2</h3><p>1，作者讲了什么？<br>作者在本章讲了redis两种持久化方式中的RDB方式<br>2，作者是怎么把这事给讲明白的？<br>为了让大家明白RDB的快照的概念，作者举了拍照片，照合影的例子<br>3，为了讲明白，作者讲了哪些要点，有哪些亮点？<br>（1）亮点1：作者解释快照使用了拍合影的例子，让我很好的理解快照的概念，以及内存数据大小对快照产生的影响<br>（2）要点1：RDB快照，将此时内存中的所有的数据写入磁盘<br>（3）要点2：生成快照有两种方式：sava和bgsava，save是主进程执行，生成时会阻塞redis，只能执行查找。bgsave是由主进程fork出子进程执行，<br>（4）要点3：子进程在被fork处理时，与主进程共享同一份内存，但在生成快照时采取COW机制，确保不会阻塞主进程的数据读写<br>（5）要点4：RDB的执行频率很重要，这会影响到数据的完整性和Redis的性能稳定性。所以4.0后有了aof和rdb混合的数据持久化机制<br>4，对于作者所讲，我有哪些发散性思考？<br>作者开篇提到的两个问题：快照什么数据，快照有何影响，具体的场景，才能讨论出具体的技术方案，我个人认为，脱离场景谈方案是在自嗨</p>
<p>5，将来有哪些场景，我能够使用到它？<br>我们项目的redis持久化使用的方式就是aof和rdb混合，前一段时间，做过集群升级扩容。把每台8c,30G内存,5主5从，升级改造成为8c,15G内存,15主15从。这样搞主要是因为之前的集群内存占用太高，导致数据持久化失败<br>6，读者评论的收获：<br>定这个专栏，真是觉得捡到宝了，大神@Kaito写的评论实在漂亮，每次都要读好几遍，读完都有赏心悦目的愉悦感，期望自己有一天也可像他那样出色</p>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>我曾碰到过这么一个场景：<br>我们使用一个 2 核 CPU、4GB 内存、500GB 磁盘的云主机运行 Redis，Redis 数据库的数据量大小差不多是 2GB，我们使用了 RDB 做持久化保证。当时 Redis 的运行负载以修改操作为主，写读比例差不多在 8:2 左右，也就是说，如果有 100 个请求，80 个请求执行的是修改操作。你觉得，在这个场景下，用 RDB 做持久化有什么风险吗？你能帮着一起分析分析吗？</p>
<h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><p>2核CPU、4GB内存、500G磁盘，Redis实例占用2GB，写读比例为8:2，此时做RDB持久化，产生的风险主要在于 CPU资源 和 内存资源 这2方面：</p>
<p>a、内存资源风险：Redis fork子进程做RDB持久化，由于写的比例为80%，那么在持久化过程中，“写实复制”会重新分配整个实例80%的内存副本，大约需要重新分配1.6GB内存空间，这样整个系统的内存使用接近饱和，如果此时父进程又有大量新key写入，很快机器内存就会被吃光，如果机器开启了Swap机制，那么Redis会有一部分数据被换到磁盘上，当Redis访问这部分在磁盘上的数据时，性能会急剧下降，已经达不到高性能的标准（可以理解为武功被废）。如果机器没有开启Swap，会直接触发OOM，父子进程会面临被系统kill掉的风险。</p>
<p>b、CPU资源风险：虽然子进程在做RDB持久化，但生成RDB快照过程会消耗大量的CPU资源，虽然Redis处理处理请求是单线程的，但Redis Server还有其他线程在后台工作，例如AOF每秒刷盘、异步关闭文件描述符这些操作。由于机器只有2核CPU，这也就意味着父进程占用了超过一半的CPU资源，此时子进程做RDB持久化，可能会产生CPU竞争，导致的结果就是父进程处理请求延迟增大，子进程生成RDB快照的时间也会变长，整个Redis Server性能下降。</p>
<p>c、另外，可以再延伸一下，老师的问题没有提到Redis进程是否绑定了CPU，如果绑定了CPU，那么子进程会继承父进程的CPU亲和性属性，子进程必然会与父进程争夺同一个CPU资源，整个Redis Server的性能必然会受到影响！所以如果Redis需要开启定时RDB和AOF重写，进程一定不要绑定CPU。</p>
<h2 id="数据复制-主从同步"><a href="#数据复制-主从同步" class="headerlink" title="数据复制-主从同步"></a>数据复制-主从同步</h2><h3 id="总结1-4"><a href="#总结1-4" class="headerlink" title="总结1"></a>总结1</h3><p>这节课，我们一起学习了 Redis 的主从库同步的基本原理，总结来说，有三种模式：全量复制、基于长连接的命令传播，以及增量复制。</p>
<p>全量复制虽然耗时，但是对于从库来说，如果是第一次同步，全量复制是无法避免的，所以，我给你一个小建议：一个 Redis 实例的数据库不要太大，一个实例大小在几 GB 级别比较合适，这样可以减少 RDB 文件生成、传输和重新加载的开销。另外，为了避免多个从库同时和主库进行全量复制，给主库过大的同步压力，我们也可以采用“主 - 从 - 从”这一级联模式，来缓解主库的压力。</p>
<p>长连接复制是主从库正常运行后的常规同步阶段。在这个阶段中，主从库之间通过命令传播实现同步。不过，这期间如果遇到了网络断连，增量复制就派上用场了。我特别建议你留意一下 repl_backlog_size 这个配置参数。如果它配置得过小，在增量复制阶段，可能会导致从库的复制进度赶不上主库，进而导致从库重新进行全量复制。所以，通过调大这个参数，可以减少从库在网络断连时全量复制的风险。</p>
<p>不过，主从库模式使用读写分离虽然避免了同时写多个实例带来的数据不一致问题，但是还面临主库故障的潜在风险。主库故障了从库该怎么办，数据还能保持一致吗，Redis 还能正常提供服务吗？在接下来的两节课里，我会和你具体聊聊主库故障后，保证服务可靠性的解决方案。</p>
<h3 id="总结2-3"><a href="#总结2-3" class="headerlink" title="总结2"></a>总结2</h3><p>一，作者讲了什么？<br>Redis的主从库数据同步机制的诞生背景和运行机制</p>
<p>二，作者是怎么把这事给讲明白的？<br>1， 作者首先介绍了主从库诞生需求背景：（写到这让我想起许式伟在架构课中提到的：拆解架构的两个核心：需求和规格）<br>为了实现Redis的高可用性，需要有多个redis实例，并且要保证多个实例数据一致（CAP定理：一致性，可用性，分区容错性）<br>2，介绍Redis的主从库间的工作机制：读写分离，主库负责接收读写请求，从库负责接收读请求，为保证从库可以正确的响应读请求，主库需要向从库同步数据<br>3，详细介绍了主从同步的机制：同步时间，同步内容，异常处理，失败补偿</p>
<p>三，作者为了讲明白，讲了哪些要点？有哪些亮点？<br>1，亮点1：Redis采用读写分离的好处：避免了加锁，实例间协商是否完成修改等复杂操作<br>1，亮点2：全量同步的发生时机：首次上线 和 从库的环形缓冲区位置标识被覆盖<br>2，亮点3：增量同步保障机制依赖于一个特殊的数据结构：环形缓冲区<br>3，要点1：首次同步分为三个阶段，①：建立连接，②：同步RDB文件，③：同步增量数据<br>4，要点2：全量同步需要主机fork子进程，产生全量RDB文件，并发送，为了减轻主机的压力，从机之间也可用互相同步<br>5，要点3：增量同步可以缓解主机全量同步的压力，它需要特殊机制保障：replication buffer，环形缓冲区，master_repl_offset，slave_repl_offset<br>6，要点4：从机的同步位置标识，在环形缓冲区被覆盖后，会触发新的一轮全量同步，所repl_backlog_buffer的大小是redis重要的调优参数<br>7，要点5：主从同步有三种机制：全量同步，基于长链接的命令传播（在写这个笔记时把它忽略了），增量同步</p>
<p>四，对于作者所讲，我有哪些发散性思考？<br>1，作者在介绍数据备份和数据同步时，都提到了单个redis的实例不宜过大<br>2，同步机制不止是redis需要，kafka，mysql中也需要，这个需要去看看他们是怎么设计的<br>3，作者介绍的redis数据一致性保障机制是很有趣，对于异常的处理机制值得学习</p>
<p>五，在未来的哪些场景里，我能够使用它？<br>1，以后面试，redis的数据备份和数同步可以不怂了<br>2，分布式系统的三定律有了联系对象</p>
<p>六，评论区的收获<br>从@Kaito 大神 那里了解到，<br>1，repl_backlog_buffer，是随着主机一起诞生的<br>2，主机和所有的clent端（包括从机）都会建立一个对应的buffer<br>3，replication buffer是与每个clent端一一对应<br>4，redis的所有写命令除了用于长链接广播，还都会写入repl_backlog_buffer</p>
<h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>按照惯例，我给你提一个小问题。这节课，我提到，主从库间的数据复制同步使用的是 RDB 文件，前面我们学习过，AOF 记录的操作命令更全，相比于 RDB 丢失的数据更少。那么，为什么主从库间的复制不使用 AOF 呢？</p>
<h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><p>主从全量同步使用RDB而不使用AOF的原因：</p>
<p>1、RDB文件内容是经过压缩的二进制数据（不同数据类型数据做了针对性优化），文件很小。而AOF文件记录的是每一次写操作的命令，写操作越多文件会变得很大，其中还包括很多对同一个key的多次冗余操作。在主从全量数据同步时，传输RDB文件可以尽量降低对主库机器网络带宽的消耗，从库在加载RDB文件时，一是文件小，读取整个文件的速度会很快，二是因为RDB文件存储的都是二进制数据，从库直接按照RDB协议解析还原数据即可，速度会非常快，而AOF需要依次重放每个写命令，这个过程会经历冗长的处理逻辑，恢复速度相比RDB会慢得多，所以使用RDB进行主从全量同步的成本最低。</p>
<p>2、假设要使用AOF做全量同步，意味着必须打开AOF功能，打开AOF就要选择文件刷盘的策略，选择不当会严重影响Redis性能。而RDB只有在需要定时备份和主从全量同步数据时才会触发生成一次快照。而在很多丢失数据不敏感的业务场景，其实是不需要开启AOF的。</p>
<p>另外，需要指出老师文章的错误：“当主从库断连后，主库会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些操作命令也写入 repl_backlog_buffer 这个缓冲区。”</p>
<p>1、主从库连接都断开了，哪里来replication buffer呢？</p>
<p>2、应该不是“主从库断连后”主库才把写操作写入repl_backlog_buffer，只要有从库存在，这个repl_backlog_buffer就会存在。主库的所有写命令除了传播给从库之外，都会在这个repl_backlog_buffer中记录一份，缓存起来，只有预先缓存了这些命令，当从库断连后，从库重新发送psync $master_runid $offset，主库才能通过$offset在repl_backlog_buffer中找到从库断开的位置，只发送$offset之后的增量数据给从库即可。</p>
<p>有同学对repl_backlog_buffer和replication buffer理解比较混淆，我大概解释一下：</p>
<p>1、repl_backlog_buffer：就是上面我解释到的，它是为了从库断开之后，如何找到主从差异数据而设计的环形缓冲区，从而避免全量同步带来的性能开销。如果从库断开时间太久，repl_backlog_buffer环形缓冲区被主库的写命令覆盖了，那么从库连上主库后只能乖乖地进行一次全量同步，所以repl_backlog_buffer配置尽量大一些，可以降低主从断开后全量同步的概率。而在repl_backlog_buffer中找主从差异的数据后，如何发给从库呢？这就用到了replication buffer。</p>
<p>2、replication buffer：Redis和客户端通信也好，和从库通信也好，Redis都需要给分配一个 内存buffer进行数据交互，客户端是一个client，从库也是一个client，我们每个client连上Redis后，Redis都会分配一个client buffer，所有数据交互都是通过这个buffer进行的：Redis先把数据写到这个buffer中，然后再把buffer中的数据发到client socket中再通过网络发送出去，这样就完成了数据交互。所以主从在增量同步时，从库作为一个client，也会分配一个buffer，只不过这个buffer专门用来传播用户的写命令到从库，保证主从数据一致，我们通常把它叫做replication buffer。</p>
<p>3、再延伸一下，既然有这个内存buffer存在，那么这个buffer有没有限制呢？如果主从在传播命令时，因为某些原因从库处理得非常慢，那么主库上的这个buffer就会持续增长，消耗大量的内存资源，甚至OOM。所以Redis提供了client-output-buffer-limit参数限制这个buffer的大小，如果超过限制，主库会强制断开这个client的连接，也就是说从库处理慢导致主库内存buffer的积压达到限制后，主库会强制断开从库的连接，此时主从复制会中断，中断后如果从库再次发起复制请求，那么此时可能会导致恶性循环，引发复制风暴，这种情况需要格外注意。</p>
<h2 id="哨兵机制：主库挂了，如何不间断服务"><a href="#哨兵机制：主库挂了，如何不间断服务" class="headerlink" title="哨兵机制：主库挂了，如何不间断服务"></a>哨兵机制：主库挂了，如何不间断服务</h2><h3 id="总结1-5"><a href="#总结1-5" class="headerlink" title="总结1"></a>总结1</h3><p>这节课，我们一起学习了哨兵机制，它是实现 Redis 不间断服务的重要保证。具体来说，主从集群的数据同步，是数据可靠的基础保证；而在主库发生故障时，自动的主从切换是服务不间断的关键支撑。</p>
<p>Redis 的哨兵机制自动完成了以下三大功能，从而实现了主从库的自动切换，可以降低 Redis 集群的运维开销：</p>
<ul>
<li>监控主库运行状态，并判断主库是否客观下线；</li>
<li>在主库客观下线后，选取新主库；</li>
<li>选出新主库后，通知从库和客户端。</li>
</ul>
<p>为了降低误判率，在实际应用时，哨兵机制通常采用多实例的方式进行部署，多个哨兵实例通过“少数服从多数”的原则，来判断主库是否客观下线。一般来说，我们可以部署三个哨兵，如果有两个哨兵认定主库“主观下线”，就可以开始切换过程。当然，如果你希望进一步提升判断准确率，也可以再适当增加哨兵个数，比如说使用五个哨兵。<br>但是，使用多个哨兵实例来降低误判率，其实相当于组成了一个哨兵集群，我们会因此面临着一些新的挑战，例如：</p>
<ul>
<li>哨兵集群中有实例挂了，怎么办，会影响主库状态判断和选主吗？</li>
<li>哨兵集群多数实例达成共识，判断出主库“客观下线”后，由哪个实例来执行主从切换呢？</li>
</ul>
<p>要搞懂这些问题，就不得不提哨兵集群了，下节课，我们来具体聊聊哨兵集群的机制和问题。</p>
<h3 id="总结2-4"><a href="#总结2-4" class="headerlink" title="总结2"></a>总结2</h3><p>一，作者讲了什么？<br>Redis故障转移：主从切换机制哨兵</p>
<p>二，作者是怎么把这事给讲明白的？<br>1，提出主从切换的三个问题：a，主机状态确认 b，新主库选举 c，新主库通知<br>2，讲解了哨兵的本质是一个特殊的redis进程（实例），有三个职责：监控，选主，通知</p>
<p>三，为了讲明白，作者讲了哪些要点，有哪些亮点？<br>1，亮点1：哨兵的本质：是一个redis实例，要做三件事：监控主库，选举新主库，通知客户端和从机（这让我对哨兵理解清晰了很多）<br>2，要点1：哨兵是通过心跳检测，监控主库状态，主库下线被分为：主观下线和客观下线、<br>3，要点2：哨兵监控是可能误判的，所以哨兵一般是集群部署，采取投票的形式减少误判<br>4，要点3：选定新主库规则是先筛选在打分，得分高的会被选为新主库，<br>5，要点4：筛选规则：从库当前的网络连接状况，以及之前的网络连接状况，筛选中断次数标准可以配置<br>6，要点5：打分规则：从库的优先级，数据同步状况，Id号大小，可以分为三轮，只要有一轮出现得分高的，就能选出</p>
<p>四，对作者所讲，我有哪些发散性思考？<br>选举机制，在分布式的场景中经常出现。我在刚开始学习这一类知识的时候，经常会想：那些大神是怎么会想到这种解决方案的？<br>后来读了一些西方社会运行机制的书，我有所释然。得到一些感悟：大神思考的技术问题解决方案，和他所生活的社会环境有着莫大的关系</p>
<p>五，将来在哪些场景，我能够使用到它？</p>
<p>六，留言区的收获<br>1，数据同步状况的判断：（感谢@Monday 同学的提问）<br>a：判断哪个从库的数据同步最接近主库，不是拿从库与主库比较，而是从库之间互相比较，谁大谁就是最接近的<br>b：这样做的原因有二：主库已下线无法获取主库信息，环形缓冲区的位置偏移量是单调递增的（主库的被称为：master_repl_offset，从库的被称为：slave_repl_offset，其实两者本质是相同的，叫不同的名字只是为了区分）<br>2，哨兵的使用：（感谢 @Kaito 大神简洁明了，无私的分享）<br>a：主库下线，可读不可写，写失败的时间=哨兵切换主从的时间+客户端感知新主库时间<br>b：主库下线无感知，需要客户端与哨兵配合改造：<br>1：哨兵主动通知：哨兵需要将最新的主库地址写入自己的pubsub中，客户端需要订阅这个pubsub，当这个pubsub有数据时，客户端就能感知到<br>2：客户端主动获取：客户端不将主从库写死，而是从哨兵集群中获取，从而始终获取最新的主从地址<br>c：集群分片模式的Redis集群，可以不使用哨兵机制（我们项目组就是这样的）</p>
<h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><p>按照惯例，我给你提个小问题。这节课，我提到，通过哨兵机制，可以实现主从库的自动切换，这是实现服务不间断的关键支撑，同时，我也提到了主从库切换是需要一定时间的。所以，请你考虑下，在这个切换过程中，客户端能否正常地进行请求操作呢？如果想要应用程序不感知服务的中断，还需要哨兵或需要客户端再做些什么吗？</p>
<h3 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h3><p>哨兵在操作主从切换的过程中，客户端能否正常地进行请求操作？</p>
<p>如果客户端使用了读写分离，那么读请求可以在从库上正常执行，不会受到影响。但是由于此时主库已经挂了，而且哨兵还没有选出新的主库，所以在这期间写请求会失败，失败持续的时间 = 哨兵切换主从的时间 + 客户端感知到新主库 的时间。</p>
<p>如果不想让业务感知到异常，客户端只能把写失败的请求先缓存起来或写入消息队列中间件中，等哨兵切换完主从后，再把这些写请求发给新的主库，但这种场景只适合对写入请求返回值不敏感的业务，而且还需要业务层做适配，另外主从切换时间过长，也会导致客户端或消息队列中间件缓存写请求过多，切换完成之后重放这些请求的时间变长。</p>
<p>哨兵检测主库多久没有响应就提升从库为新的主库，这个时间是可以配置的（down-after-milliseconds参数）。配置的时间越短，哨兵越敏感，哨兵集群认为主库在短时间内连不上就会发起主从切换，这种配置很可能因为网络拥塞但主库正常而发生不必要的切换，当然，当主库真正故障时，因为切换得及时，对业务的影响最小。如果配置的时间比较长，哨兵越保守，这种情况可以减少哨兵误判的概率，但是主库故障发生时，业务写失败的时间也会比较久，缓存写请求数据量越多。</p>
<p>应用程序不感知服务的中断，还需要哨兵和客户端做些什么？当哨兵完成主从切换后，客户端需要及时感知到主库发生了变更，然后把缓存的写请求写入到新库中，保证后续写请求不会再受到影响，具体做法如下：</p>
<p>哨兵提升一个从库为新主库后，哨兵会把新主库的地址写入自己实例的pubsub（switch-master）中。客户端需要订阅这个pubsub，当这个pubsub有数据时，客户端就能感知到主库发生变更，同时可以拿到最新的主库地址，然后把写请求写到这个新主库即可，这种机制属于哨兵主动通知客户端。</p>
<p>如果客户端因为某些原因错过了哨兵的通知，或者哨兵通知后客户端处理失败了，安全起见，客户端也需要支持主动去获取最新主从的地址进行访问。</p>
<p>所以，客户端需要访问主从库时，不能直接写死主从库的地址了，而是需要从哨兵集群中获取最新的地址（sentinel get-master-addr-by-name命令），这样当实例异常时，哨兵切换后或者客户端断开重连，都可以从哨兵集群中拿到最新的实例地址。</p>
<p>一般Redis的SDK都提供了通过哨兵拿到实例地址，再访问实例的方式，我们直接使用即可，不需要自己实现这些逻辑。当然，对于只有主从实例的情况，客户端需要和哨兵配合使用，而在分片集群模式下，这些逻辑都可以做在proxy层，这样客户端也不需要关心这些逻辑了，Codis就是这么做的。</p>
<p>另外再简单回答下哨兵相关的问题：</p>
<p>1、哨兵集群中有实例挂了，怎么办，会影响主库状态判断和选主吗？</p>
<p>这个属于分布式系统领域的问题了，指的是在分布式系统中，如果存在故障节点，整个集群是否还可以提供服务？而且提供的服务是正确的？</p>
<p>这是一个分布式系统容错问题，这方面最著名的就是分布式领域中的“拜占庭将军”问题了，“拜占庭将军问题”不仅解决了容错问题，还可以解决错误节点的问题，虽然比较复杂，但还是值得研究的，有兴趣的同学可以去了解下。</p>
<p>简单说结论：存在故障节点时，只要集群中大多数节点状态正常，集群依旧可以对外提供服务。具体推导过程细节很多，大家去查前面的资料了解就好。</p>
<p>2、哨兵集群多数实例达成共识，判断出主库“客观下线”后，由哪个实例来执行主从切换呢？</p>
<p>哨兵集群判断出主库“主观下线”后，会选出一个“哨兵领导者”，之后整个过程由它来完成主从切换。</p>
<p>但是如何选出“哨兵领导者”？这个问题也是一个分布式系统中的问题，就是我们经常听说的共识算法，指的是集群中多个节点如何就一个问题达成共识。共识算法有很多种，例如Paxos、Raft，这里哨兵集群采用的类似于Raft的共识算法。</p>
<p>简单来说就是每个哨兵设置一个随机超时时间，超时后每个哨兵会请求其他哨兵为自己投票，其他哨兵节点对收到的第一个请求进行投票确认，一轮投票下来后，首先达到多数选票的哨兵节点成为“哨兵领导者”，如果没有达到多数选票的哨兵节点，那么会重新选举，直到能够成功选出“哨兵领导者”。</p>
<h2 id="哨兵集群：哨兵挂了，如何服务"><a href="#哨兵集群：哨兵挂了，如何服务" class="headerlink" title="哨兵集群：哨兵挂了，如何服务"></a>哨兵集群：哨兵挂了，如何服务</h2><h3 id="总结1-6"><a href="#总结1-6" class="headerlink" title="总结1"></a>总结1</h3><p>通常，我们在解决一个系统问题的时候，会引入一个新机制，或者设计一层新功能，就像我们在这两节课学习的内容：为了实现主从切换，我们引入了哨兵；为了避免单个哨兵故障后无法进行主从切换，以及为了减少误判率，又引入了哨兵集群；哨兵集群又需要有一些机制来支撑它的正常运行。</p>
<p>这节课上，我就向你介绍了支持哨兵集群的这些关键机制，包括：</p>
<ul>
<li>基于 pub/sub 机制的哨兵集群组成过程；</li>
<li>基于 INFO 命令的从库列表，这可以帮助哨兵和从库建立连接；</li>
<li>基于哨兵自身的 pub/sub 功能，这实现了客户端和哨兵之间的事件通知。</li>
</ul>
<p>对于主从切换，当然不是哪个哨兵想执行就可以执行的，否则就乱套了。所以，这就需要哨兵集群在判断了主库“客观下线”后，经过投票仲裁，选举一个 Leader 出来，由它负责实际的主从切换，即由它来完成新主库的选择以及通知从库与客户端。</p>
<p>最后，我想再给你分享一个经验：要保证所有哨兵实例的配置是一致的，尤其是主观下线的判断值 down-after-milliseconds。我们曾经就踩过一个“坑”。当时，在我们的项目中，因为这个值在不同的哨兵实例上配置不一致，导致哨兵集群一直没有对有故障的主库形成共识，也就没有及时切换主库，最终的结果就是集群服务不稳定。所以，你一定不要忽略这条看似简单的经验。</p>
<h3 id="总结2-5"><a href="#总结2-5" class="headerlink" title="总结2"></a>总结2</h3><p>一，作者讲了什么？<br>哨兵集群的工作机制</p>
<p>二，作者是怎么把这事给讲明白的？<br>1，哨兵之间互通机制：基于pub/sub机制，在主库中有一个”<strong>sentinel</strong>:hello”的频道，哨兵之间互相发现通信<br>2，哨兵与主从库互通机制：哨兵向主库发送INFO指令，可以获取所有从库的信息，实现对主库，从库的监控<br>3，哨兵判定主库异常机制：哨兵集群中任意一个实例都可以发起主库异常“投票仲裁”流程</p>
<p>三，为了讲明白，作者都讲了哪些要点？有哪些亮点？<br>1，亮点1：哨兵之间的互动是通过发布订阅机制完成的，利用自身的特性来实现。这让我联想到kafka对于日息位置偏移量的管理<br>2，要点1：哨兵之间通信不是哨兵之间之间联系，而是通过订阅主库的同一频道来获取彼此的信息<br>3，要点2：哨兵是通过INFO指令，从主库获取从库信息，并与每个从库建立连接，监控所有主从库状态<br>4，要点3：哨兵是一个特殊的redis实例，所以客户端可以订阅哨兵的指定频道获得redis主从库的信息<br>5，要点4：哨兵集群执行主从切换机制：谁发现，谁就发起投票流程，谁获得多数票，谁就是哨兵Leader，由Leader负责主从库切换<br>6，要点5：哨兵集群Leader选举成功与否，依赖于网络通信状况，网络拥塞会导致选举失败，重新进行新一轮选举</p>
<p>四，对于作者所讲，我有哪些发散性思考？</p>
<p>五，在未来的哪些场景里，我可以使用它？</p>
<p>六，留言区的收获：（感谢 @ 小喵喵 的提问）<br>1，哨兵投票机制：<br>a：哨兵实例只有在自己判定主库下线时，才会给自己投票，而其他的哨兵实例会把票投给第一个来要票的请求，其后的都拒绝<br>b：如果出现多个哨兵同时发现主库下线并给自己投票，导致投票选举失败，就会触发新一轮投票，直至成功</p>
<p>2，哨兵Leader切换主从库的机制：（感谢 @Kaito ，@Darren 大神的解答）<br>        哨兵成为Leader的必要条件：a：获得半数以上的票数，b：得到的票数要达到配置的quorum阀值<br>        主从切换只能由Leader执行，而成为Leader有两个必要的条件，所以当哨兵集群中实例异常过多时，会导致主从库无法切换</p>
<h3 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h3><p>假设有一个 Redis 集群，是“一主四从”，同时配置了包含 5 个哨兵实例的集群，quorum 值设为 2。在运行过程中，如果有 3 个哨兵实例都发生故障了，此时，Redis 主库如果有故障，还能正确地判断主库“客观下线”吗？如果可以的话，还能进行主从库自动切换吗？此外，哨兵实例是不是越多越好呢，如果同时调大 down-after-milliseconds 值，对减少误判是不是也有好处呢？</p>
<h3 id="解答-4"><a href="#解答-4" class="headerlink" title="解答"></a>解答</h3><p>Redis 1主4从，5个哨兵，哨兵配置quorum为2，如果3个哨兵故障，当主库宕机时，哨兵能否判断主库“客观下线”？能否自动切换？</p>
<p>经过实际测试，我的结论如下：</p>
<p>1、哨兵集群可以判定主库“主观下线”。由于quorum=2，所以当一个哨兵判断主库“主观下线”后，询问另外一个哨兵后也会得到同样的结果，2个哨兵都判定“主观下线”，达到了quorum的值，因此，哨兵集群可以判定主库为“客观下线”。</p>
<p>2、但哨兵不能完成主从切换。哨兵标记主库“客观下线后”，在选举“哨兵领导者”时，一个哨兵必须拿到超过多数的选票(5/2+1=3票)。但目前只有2个哨兵活着，无论怎么投票，一个哨兵最多只能拿到2票，永远无法达到多数选票的结果。</p>
<p>但是投票选举过程的细节并不是大家认为的：每个哨兵各自1票，这个情况是不一定的。下面具体说一下：</p>
<p>场景a：哨兵A先判定主库“主观下线”，然后马上询问哨兵B（注意，此时哨兵B只是被动接受询问，并没有去询问哨兵A，也就是它还没有进入判定“客观下线”的流程），哨兵B回复主库已“主观下线”，达到quorum=2后哨兵A此时可以判定主库“客观下线”。此时，哨兵A马上可以向其他哨兵发起成为“哨兵领导者”的投票，哨兵B收到投票请求后，由于自己还没有询问哨兵A进入判定“客观下线”的流程，所以哨兵B是可以给哨兵A投票确认的，这样哨兵A就已经拿到2票了。等稍后哨兵B也判定“主观下线”后想成为领导者时，因为它已经给别人投过票了，所以这一轮自己就不能再成为领导者了。</p>
<p>场景b：哨兵A和哨兵B同时判定主库“主观下线”，然后同时询问对方后都得到可以“客观下线”的结论，此时它们各自给自己投上1票后，然后向其他哨兵发起投票请求，但是因为各自都给自己投过票了，因此各自都拒绝了对方的投票请求，这样2个哨兵各自持有1票。</p>
<p>场景a是1个哨兵拿到2票，场景b是2个哨兵各自有1票，这2种情况都不满足大多数选票(3票)的结果，因此无法完成主从切换。</p>
<p>经过测试发现，场景b发生的概率非常小，只有2个哨兵同时进入判定“主观下线”的流程时才可以发生。我测试几次后发现，都是复现的场景a。</p>
<p>哨兵实例是不是越多越好？</p>
<p>并不是，我们也看到了，哨兵在判定“主观下线”和选举“哨兵领导者”时，都需要和其他节点进行通信，交换信息，哨兵实例越多，通信的次数也就越多，而且部署多个哨兵时，会分布在不同机器上，节点越多带来的机器故障风险也会越大，这些问题都会影响到哨兵的通信和选举，出问题时也就意味着选举时间会变长，切换主从的时间变久。</p>
<p>调大down-after-milliseconds值，对减少误判是不是有好处？</p>
<p>是有好处的，适当调大down-after-milliseconds值，当哨兵与主库之间网络存在短时波动时，可以降低误判的概率。但是调大down-after-milliseconds值也意味着主从切换的时间会变长，对业务的影响时间越久，我们需要根据实际场景进行权衡，设置合理的阈值。</p>
<h2 id="切片集群：是增加内存还是增加实例"><a href="#切片集群：是增加内存还是增加实例" class="headerlink" title="切片集群：是增加内存还是增加实例"></a>切片集群：是增加内存还是增加实例</h2><h3 id="总结1-7"><a href="#总结1-7" class="headerlink" title="总结1"></a>总结1</h3><p>这节课，我们学习了切片集群在保存大量数据方面的优势，以及基于哈希槽的数据分布机制和客户端定位键值对的方法。</p>
<p>在应对数据量扩容时，虽然增加内存这种纵向扩展的方法简单直接，但是会造成数据库的内存过大，导致性能变慢。Redis 切片集群提供了横向扩展的模式，也就是使用多个实例，并给每个实例配置一定数量的哈希槽，数据可以通过键的哈希值映射到哈希槽，再通过哈希槽分散保存到不同的实例上。这样做的好处是扩展性好，不管有多少数据，切片集群都能应对。</p>
<p>另外，集群的实例增减，或者是为了实现负载均衡而进行的数据重新分布，会导致哈希槽和实例的映射关系发生变化，客户端发送请求时，会收到命令执行报错信息。了解了 MOVED 和 ASK 命令，你就不会为这类报错而头疼了。</p>
<p>我刚刚说过，在 Redis 3.0 之前，Redis 官方并没有提供切片集群方案，但是，其实当时业界已经有了一些切片集群的方案，例如基于客户端分区的 ShardedJedis，基于代理的 Codis、Twemproxy 等。这些方案的应用早于 Redis Cluster 方案，在支撑的集群实例规模、集群稳定性、客户端友好性方面也都有着各自的优势，我会在后面的课程中，专门和你聊聊这些方案的实现机制，以及实践经验。这样一来，当你再碰到业务发展带来的数据量巨大的难题时，就可以根据这些方案的特点，选择合适的方案实现切片集群，以应对业务需求了。</p>
<h3 id="总结2-6"><a href="#总结2-6" class="headerlink" title="总结2"></a>总结2</h3><p>1，作者讲了什么？<br>切片集群</p>
<p>2，作者是怎么把事给讲明白的？<br>从一个案例入手，讲到单实例内存过大在数据备份时会导致Redis性能下降，<br>引出redis分片集群来解决大数据量，高性能的设计<br>提出两个关键问题：数据分片与实例间如何建立对应关系，2，客户端如何知晓去哪个实例中获取数据</p>
<p>3，为了讲明白，作者讲了哪些要点？有哪些亮点？<br>1，亮点1：这一课我更加清晰的明白了之前别人聊Redis扩容中的纵向扩容和横向扩容的真实含义和区别<br>2，要点1：数据分片和实例的对应关系建立：按照CRC16算法计算一个key的16bit的值，在将这值对16384取模<br>3，要点2：一个切片集群的槽位是固定的16384个，可手动分配每个实例的槽位，但必须将槽位全部分完<br>4，要点3：客户端如何确定要访问那个实例获取数据：1从任意个实例获取并缓存在自己本地，2，重定向机制<br>5，要点4：重定向机制：客户端访问的实例没有数据，被访问实例响应move命令，告诉客户端指向新的实例地址<br>6，要点5：ASK命令：1，表明数据正在迁移 2，告知客户端数据所在的实例<br>7，要点6：ASK命令和MOVE命令的区别：<br>move命令是在数据迁移完毕后被响应，客户端会更新本地缓存。<br>ASK命令是在数据迁移中被响应，不会让客户端更新缓存</p>
<p>4，对作者所讲，我有哪些发散性思考？<br>对于CRC16算法，应该可以用到我们系统当中，对所有手机的设备号进行计算取模，用于分表存储数据<br>在系统设计时，可以通过分层或增加一层来提升系统设计的弹性</p>
<p>5，在将来的那些场景中，我能够使用它？</p>
<p>6，留言区的收获（来自 @Kaito 大神）<br>1，Redis Cluster不采用直接把key映射到实例，而采用哈希槽的方式原因：可用使Redis集群设计：简洁，高效，有弹性<br>不使用的劣势<br>①：集群中的key无法预估，直接存key对应实例的映射关系，需占用的内存空间不可控<br>②：Cluster是去中心化设计，所有实例都需保存完整的映射关系，<br>采用直接的映射，会导致节点间信息交换成本高昂<br>③：key与实例直接映射，在集群扩缩容时，需要数据迁移，所有的key都需要重新映射<br>使用的好处<br>①：在中间增加一层哈希槽，可以将数据与节点解耦，使数据分配均匀<br>key通过hsah计算在取模，可以把数据打的更散，<br>只需要关心映射到了哪个哈希槽，通过哈希槽映射表找到对应的实例<br>②：增加哈希槽可以使得映射表比较小，有利于客户端和服务端保存，节点间信息交换<br>③：集群扩缩容，数据均衡时，操作单位是哈希槽，可以简化操作难度</p>
<p>2，Redis集群方案的两个关键问题：<br>    ①：请求路由<br>    ②：数据迁移</p>
<h3 id="问题-5"><a href="#问题-5" class="headerlink" title="问题"></a>问题</h3><p>Redis Cluster 方案通过哈希槽的方式把键值对分配到不同的实例上，这个过程需要对键值对的 key 做 CRC 计算，然后再和哈希槽做映射，这样做有什么好处吗？如果用一个表直接把键值对和实例的对应关系记录下来（例如键值对 1 在实例 2 上，键值对 2 在实例 1 上），这样就不用计算 key 和哈希槽的对应关系了，只用查表就行了，Redis 为什么不这么做呢？</p>
<h3 id="解答-5"><a href="#解答-5" class="headerlink" title="解答"></a>解答</h3><p>Redis Cluster不采用把key直接映射到实例的方式，而采用哈希槽的方式原因：</p>
<p>1、整个集群存储key的数量是无法预估的，key的数量非常多时，直接记录每个key对应的实例映射关系，这个映射表会非常庞大，这个映射表无论是存储在服务端还是客户端都占用了非常大的内存空间。</p>
<p>2、Redis Cluster采用无中心化的模式（无proxy，客户端与服务端直连），客户端在某个节点访问一个key，如果这个key不在这个节点上，这个节点需要有纠正客户端路由到正确节点的能力（MOVED响应），这就需要节点之间互相交换路由表，每个节点拥有整个集群完整的路由关系。如果存储的都是key与实例的对应关系，节点之间交换信息也会变得非常庞大，消耗过多的网络资源，而且就算交换完成，相当于每个节点都需要额外存储其他节点的路由表，内存占用过大造成资源浪费。</p>
<p>3、当集群在扩容、缩容、数据均衡时，节点之间会发生数据迁移，迁移时需要修改每个key的映射关系，维护成本高。</p>
<p>4、而在中间增加一层哈希槽，可以把数据和节点解耦，key通过Hash计算，只需要关心映射到了哪个哈希槽，然后再通过哈希槽和节点的映射表找到节点，相当于消耗了很少的CPU资源，不但让数据分布更均匀，还可以让这个映射表变得很小，利于客户端和服务端保存，节点之间交换信息时也变得轻量。</p>
<p>5、当集群在扩容、缩容、数据均衡时，节点之间的操作例如数据迁移，都以哈希槽为基本单位进行操作，简化了节点扩容、缩容的难度，便于集群的维护和管理。</p>
<p>另外，我想补充一下Redis集群相关的知识，以及我的理解：</p>
<p>Redis使用集群方案就是为了解决单个节点数据量大、写入量大产生的性能瓶颈的问题。多个节点组成一个集群，可以提高集群的性能和可靠性，但随之而来的就是集群的管理问题，最核心问题有2个：请求路由、数据迁移（扩容/缩容/数据平衡）。</p>
<p>1、请求路由：一般都是采用哈希槽的映射关系表找到指定节点，然后在这个节点上操作的方案。</p>
<p>Redis Cluster在每个节点记录完整的映射关系(便于纠正客户端的错误路由请求)，同时也发给客户端让客户端缓存一份，便于客户端直接找到指定节点，客户端与服务端配合完成数据的路由，这需要业务在使用Redis Cluster时，必须升级为集群版的SDK才支持客户端和服务端的协议交互。</p>
<p>其他Redis集群化方案例如Twemproxy、Codis都是中心化模式（增加Proxy层），客户端通过Proxy对整个集群进行操作，Proxy后面可以挂N多个Redis实例，Proxy层维护了路由的转发逻辑。操作Proxy就像是操作一个普通Redis一样，客户端也不需要更换SDK，而Redis Cluster是把这些路由逻辑做在了SDK中。当然，增加一层Proxy也会带来一定的性能损耗。</p>
<p>2、数据迁移：当集群节点不足以支撑业务需求时，就需要扩容节点，扩容就意味着节点之间的数据需要做迁移，而迁移过程中是否会影响到业务，这也是判定一个集群方案是否成熟的标准。</p>
<p>Twemproxy不支持在线扩容，它只解决了请求路由的问题，扩容时需要停机做数据重新分配。而Redis Cluster和Codis都做到了在线扩容（不影响业务或对业务的影响非常小），重点就是在数据迁移过程中，客户端对于正在迁移的key进行操作时，集群如何处理？还要保证响应正确的结果？</p>
<p>Redis Cluster和Codis都需要服务端和客户端/Proxy层互相配合，迁移过程中，服务端针对正在迁移的key，需要让客户端或Proxy去新节点访问（重定向），这个过程就是为了保证业务在访问这些key时依旧不受影响，而且可以得到正确的结果。由于重定向的存在，所以这个期间的访问延迟会变大。等迁移完成之后，Redis Cluster每个节点会更新路由映射表，同时也会让客户端感知到，更新客户端缓存。Codis会在Proxy层更新路由表，客户端在整个过程中无感知。</p>
<p>除了访问正确的节点之外，数据迁移过程中还需要解决异常情况（迁移超时、迁移失败）、性能问题（如何让数据迁移更快、bigkey如何处理），这个过程中的细节也很多。</p>
<p>Redis Cluster的数据迁移是同步的，迁移一个key会同时阻塞源节点和目标节点，迁移过程中会有性能问题。而Codis提供了异步迁移数据的方案，迁移速度更快，对性能影响最小，当然，实现方案也比较复杂。</p>
<h2 id="string为什么不好用了"><a href="#string为什么不好用了" class="headerlink" title="string为什么不好用了"></a>string为什么不好用了</h2><h3 id="总结1-8"><a href="#总结1-8" class="headerlink" title="总结1"></a>总结1</h3><p>这节课，我们打破了对 String 的认知误区，以前，我们认为 String 是“万金油”，什么场合都适用，但是，在保存的键值对本身占用的内存空间不大时（例如这节课里提到的的图片 ID 和图片存储对象 ID），String 类型的元数据开销就占据主导了，这里面包括了 RedisObject 结构、SDS 结构、dictEntry 结构的内存开销。</p>
<p>针对这种情况，我们可以使用压缩列表保存数据。当然，使用 Hash 这种集合类型保存单值键值对的数据时，我们需要将单值数据拆分成两部分，分别作为 Hash 集合的键和值，就像刚才案例中用二级编码来表示图片 ID，希望你能把这个方法用到自己的场景中。</p>
<p>最后，我还想再给你提供一个小方法：如果你想知道键值对采用不同类型保存时的内存开销，可以在这个网址里输入你的键值对长度和使用的数据类型，这样就能知道实际消耗的内存大小了。建议你把这个小工具用起来，它可以帮助你充分地节省内存。</p>
<h3 id="总结2-7"><a href="#总结2-7" class="headerlink" title="总结2"></a>总结2</h3><p>一，作者讲了什么？<br>Redis的String类型数据结构，及其底层实现<br>二，作者是怎么把这事给说明白的？<br>1，通过一个图片存储的案例，讲通过合理利用Redis的数据结构，降低资源消耗</p>
<p>三，为了讲明白，作者讲了哪些要点？有哪些亮点？<br>1，亮点1：String类型的数据占用内存，分别是被谁占用了<br>2，亮点2：可以巧妙的利用Redis的底层数据结构特性，降低资源消耗<br>3，要点1： Simple Dynamic String结构体（<br>buf：字节数组，为了表示字节结束，会在结尾增加“\0”<br>len： 占4个字节，表示buf的已用长度<br>alloc：占4个字节，表示buf实际分配的长度，一般大于len）</p>
<p>4，要点2： RedisObject 结构体（<br>元数据：8字节（用于记录最后一次访问时间，被引用次数。。。）<br>指针：8字节，指向具体数据类型的实际数据所在 ）</p>
<p>5，要点3：dicEntry 结构体（<br>key：8个字节指针，指向key<br>value：8个字节指针，指向value<br>next：指向下一个dicEntry）<br>6，要点4：ziplist(压缩列表)（<br>zlbytes：在表头，表示列表长度<br>zltail：在表头，表示列尾偏移量<br>zllen：在表头，表示列表中<br>entry：保存数据对象模型<br>zlend：在表尾，表示列表结束）<br>entry：（<br>prev_len：表示一个entry的长度，有两种取值方式：1字节或5字节。<br>1字节表示一个entry小于254字节，255是zlend的默认值，所以不使用。<br>len：表示自身长度，4字节<br>encodeing：表示编码方式，1字节<br>content：保存实际数据）</p>
<p>5，要点4：String类型的内存空间消耗<br>①，保存Long类型时，指针直接保存整数数据值，可以节省空间开销（被称为：int编码）<br>②，保存字符串，且不大于44字节时，RedisObject的元数据，指针和SDS是连续的，可以避免内存碎片（被称为：embstr编码）<br>③，当保存的字符串大于44字节时，SDS的数据量变多，Redis会给SDS分配独立的空间，并用指针指向SDS结构（被称为：raw编码）<br>④，Redis使用一个全局哈希表保存所以键值对，哈希表的每一项都是一个dicEntry，每个dicEntry占用32字节空间<br>⑤，dicEntry自身24字节，但会占用32字节空间，是因为Redis使用了内存分配库jemalloc。<br>jemalloc在分配内存时，会根据申请的字节数N，找一个比N大，但最接近N的2的幂次数作为分配空间，这样可以减少频繁分配内存的次数</p>
<p>4，要点5：使用什么数据结构可以节省内存？<br>①， 压缩列表，是一种非常节省内存的数据结构，因为他使用连续的内存空间保存数据，不需要额外的指针进行连接<br>②，Redis基于压缩列表实现List，Hash，Sorted Set集合类型，最大的好处是节省了dicEntry开销</p>
<p>5，要点6：如何使用集合类型保存键值对？<br>①，Hash类型设置了用压缩列表保存数据时的两个阀值，一旦超过就会将压缩列表转为哈希表，且不可回退<br>②，hash-max-ziplist-entries：表示用压缩列表保存哈希集合中的最大元素个数<br>③，hash-max-ziplist-value：表示用压缩列表保存时，哈希集合中单个元素的最大长度</p>
<p>四，对于作者所讲，我有哪些发散性思考？<br>看了老师讲解，做了笔记，又看了黄建宏写的《Redis 设计与实现》<br>有这样的讲解：<br>当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：</p>
<ol>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；</li>
<li>哈希对象保存的键值对数量小于 512 个；</li>
</ol>
<p>五，在将来的哪些场景中，我能够使用它？<br>这次学习Redis数据结构特性有了更多了解，在以后可以更加有信心根据业务需要，选取特定的数据结构</p>
<h3 id="问题-6"><a href="#问题-6" class="headerlink" title="问题"></a>问题</h3><p>除了 String 类型和 Hash 类型，你觉得，还有其他合适的类型可以应用在这节课所说的保存图片的例子吗？</p>
<h3 id="解答-6"><a href="#解答-6" class="headerlink" title="解答"></a>解答</h3><p>保存图片的例子，除了用String和Hash存储之外，还可以用Sorted Set存储（勉强）。</p>
<p>Sorted Set与Hash类似，当元素数量少于zset-max-ziplist-entries，并且每个元素内存占用小于zset-max-ziplist-value时，默认也采用ziplist结构存储。我们可以把zset-max-ziplist-entries参数设置为1000，这样Sorted Set默认就会使用ziplist存储了，member和score也会紧凑排列存储，可以节省内存空间。</p>
<p>使用zadd 1101000 3302000080 060命令存储图片ID和对象ID的映射关系，查询时使用zscore 1101000 060获取结果。</p>
<p>但是Sorted Set使用ziplist存储时的缺点是，这个ziplist是需要按照score排序的（为了方便zrange和zrevrange命令的使用），所以在插入一个元素时，需要先根据score找到对应的位置，然后把member和score插入进去，这也意味着Sorted Set插入元素的性能没有Hash高（这也是前面说勉强能用Sorte Set存储的原因）。而Hash在插入元素时，只需要将新的元素插入到ziplist的尾部即可，不需要定位到指定位置。</p>
<p>不管是使用Hash还是Sorted Set，当采用ziplist方式存储时，虽然可以节省内存空间，但是在查询指定元素时，都要遍历整个ziplist，找到指定的元素。所以使用ziplist方式存储时，虽然可以利用CPU高速缓存，但也不适合存储过多的数据（hash-max-ziplist-entries和zset-max-ziplist-entries不宜设置过大），否则查询性能就会下降比较厉害。整体来说，这样的方案就是时间换空间，我们需要权衡使用。</p>
<p>当使用ziplist存储时，我们尽量存储int数据，ziplist在设计时每个entry都进行了优化，针对要存储的数据，会尽量选择占用内存小的方式存储（整数比字符串在存储时占用内存更小），这也有利于我们节省Redis的内存。还有，因为ziplist是每个元素紧凑排列，而且每个元素存储了上一个元素的长度，所以当修改其中一个元素超过一定大小时，会引发多个元素的级联调整（前面一个元素发生大的变动，后面的元素都要重新排列位置，重新分配内存），这也会引发性能问题，需要注意。</p>
<p>另外，使用Hash和Sorted Set存储时，虽然节省了内存空间，但是设置过期变得困难（无法控制每个元素的过期，只能整个key设置过期，或者业务层单独维护每个元素过期删除的逻辑，但比较复杂）。而使用String虽然占用内存多，但是每个key都可以单独设置过期时间，还可以设置maxmemory和淘汰策略，以这种方式控制整个实例的内存上限。</p>
<p>所以在选用Hash和Sorted Set存储时，意味着把Redis当做数据库使用，这样就需要务必保证Redis的可靠性（做好备份、主从副本），防止实例宕机引发数据丢失的风险。而采用String存储时，可以把Redis当做缓存使用，每个key设置过期时间，同时设置maxmemory和淘汰策略，控制整个实例的内存上限，这种方案需要在数据库层（例如MySQL）也存储一份映射关系，当Redis中的缓存过期或被淘汰时，需要从数据库中重新查询重建缓存，同时需要保证数据库和缓存的一致性，这些逻辑也需要编写业务代码实现。</p>
<p>总之，各有利弊，我们需要根据实际场景进行选择。</p>
<h2 id="一亿keys要统计，用哪种集合"><a href="#一亿keys要统计，用哪种集合" class="headerlink" title="一亿keys要统计，用哪种集合"></a>一亿keys要统计，用哪种集合</h2><h3 id="总结1-9"><a href="#总结1-9" class="headerlink" title="总结1"></a>总结1</h3><p><img src="/images/redis/datastruct-02.png" alt="img.png"><br>可以看到，Set 和 Sorted Set 都支持多种聚合统计，不过，对于差集计算来说，只有 Set 支持。Bitmap 也能做多个 Bitmap 间的聚合计算，包括与、或和异或操作。</p>
<p>当需要进行排序统计时，List 中的元素虽然有序，但是一旦有新元素插入，原来的元素在 List 中的位置就会移动，那么，按位置读取的排序结果可能就不准确了。而 Sorted Set 本身是按照集合元素的权重排序，可以准确地按序获取结果，所以建议你优先使用它。</p>
<p>如果我们记录的数据只有 0 和 1 两个值的状态，Bitmap 会是一个很好的选择，这主要归功于 Bitmap 对于一个数据只用 1 个 bit 记录，可以节省内存。</p>
<p>对于基数统计来说，如果集合元素量达到亿级别而且不需要精确统计时，我建议你使用 HyperLogLog。</p>
<h3 id="总结2-8"><a href="#总结2-8" class="headerlink" title="总结2"></a>总结2</h3><p>1，作者讲了什么？<br>1，Redis有那些数据结构适合做统计</p>
<p>2，作者是怎么把这事给讲明白的？<br>1，列举了常见的数据统计需求。从实际需求出发，推荐适合的数据类型，讲解了怎么用，并解答这种数据结构为什么可以<br>2，将数据统计需求，分了四类，分类分别讲解</p>
<p>3，为了讲明白，作者讲了哪些要点，有哪些亮点？<br>1，亮点1：BITMAP的特性和使用场景，方式<br>2，亮点2：HyperLogLog的特性和使用场景，方式<br>3，要点1：日常的统计需求可以分为四类：聚合，排序，二值状态，基数，选用适合的数据类型可以实现即快速又节省内存<br>4，要点2：聚合统计，可以选用Set类型完成，但Set的差，并，交集操作复杂度高，在数据量大的时候会阻塞主进程<br>5，要点3：排序统计，可以选用List和Sorted Set<br>6，要点4：二值状态统计：Bitmap本身是用String类型作为底层数据结构实现，String类型会保存为二进制字节数组，所以可以看作是一个bit数组<br>7，要点5：基数统计：HyperLogLog ,计算基数所需空间总是固定的，而且很小。但要注意，HyperLogLog是统计规则是基于概率完成的，不是非常准确</p>
<p>4，对于作者所讲，我有那些发散性思考？<br>1，对于统计用户的打卡情况，我们项目组也做了这个需求，但遗憾的是我们没有采用bitmap这种方案，而是使用了 sortSet<br>2，HyperLogLog可以考虑使用到，我们项目中的统计视频播放次数，现在这块，我们的方案是，每天产生一个key，单调递增。在通过定时任务，将缓存中的结果，每天一条数据记录，存入数据库</p>
<p>5，在将来的那些场景中，我能够使用它？</p>
<p>6，留言区的收获</p>
<p>1，主从库模式使用Set数据类型聚合命令(来自 @kaito 大神)<br>①：使用SUNIONSTORE，SDIFFSTORE，SINTERSTOR做并集，差集，交集时，这三个命令都会在Redis中生成一个新key,而从库默认是readOnly。所以这些命令只能在主库上使用<br>②：SUNION，SDIFF,SINTER，这些命令可以计算出结果，不产生新的key可以在从库使用</p>
<h3 id="问题-7"><a href="#问题-7" class="headerlink" title="问题"></a>问题</h3><p>这节课，我们学习了 4 种典型的统计模式，以及各种集合类型的支持情况和优缺点，我想请你聊一聊，你还遇到过其他的统计场景吗？用的是怎样的集合类型呢？</p>
<h3 id="解答-7"><a href="#解答-7" class="headerlink" title="解答"></a>解答</h3><p>使用Sorted Set可以实现统计一段时间内的在线用户数：用户上线时使用zadd online_users $timestamp $user_id把用户添加到Sorted Set中，使用zcount online_users $start_timestamp $end_timestamp就可以得出指定时间段内的在线用户数。</p>
<p>如果key是以天划分的，还可以执行zinterstore online_users_tmp 2 online_users_{date1} online_users_{date2} aggregate max，把结果存储到online_users_tmp中，然后通过zrange online_users_tmp 0 -1 withscores就可以得到这2天都在线过的用户，并且score就是这些用户最近一次的上线时间。</p>
<p>还有一个有意思的方式，使用Set记录数据，再使用zunionstore命令求并集。例如sadd user1 apple orange banana、sadd user2 apple banana peach记录2个用户喜欢的水果，使用zunionstore fruits_union 2 user1 user2把结果存储到fruits_union这个key中，zrange fruits_union 0 -1 withscores可以得出每种水果被喜欢的次数。</p>
<p>使用HyperLogLog计算UV时，补充一点，还可以使用pfcount page1:uv page2:uv page3:uv或pfmerge page_union:uv page1:uv page2:uv page3:uv得出3个页面的UV总和。</p>
<p>另外，需要指出老师文章描述不严谨的地方：“Set数据类型，使用SUNIONSTORE、SDIFFSTORE、SINTERSTORE做并集、差集、交集时，选择一个从库进行聚合计算”。这3个命令都会在Redis中生成一个新key，而从库默认是readonly不可写的，所以这些命令只能在主库使用。想在从库上操作，可以使用SUNION、SDIFF、SINTER，这些命令可以计算出结果，但不会生成新key。</p>
<p>最后需要提醒一下：</p>
<p>1、如果是在集群模式使用多个key聚合计算的命令，一定要注意，因为这些key可能分布在不同的实例上，多个实例之间是无法做聚合运算的，这样操作可能会直接报错或者得到的结果是错误的！</p>
<p>2、当数据量非常大时，使用这些统计命令，因为复杂度较高，可能会有阻塞Redis的风险，建议把这些统计数据与在线业务数据拆分开，实例单独部署，防止在做统计操作时影响到在线业务。</p>
<h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2><h3 id="总结1-10"><a href="#总结1-10" class="headerlink" title="总结1"></a>总结1</h3><p>这节课，我们学习了 Redis 的扩展数据类型 GEO。GEO 可以记录经纬度形式的地理位置信息，被广泛地应用在 LBS 服务中。GEO 本身并没有设计新的底层数据结构，而是直接使用了 Sorted Set 集合类型。</p>
<p>GEO 类型使用 GeoHash 编码方法实现了经纬度到 Sorted Set 中元素权重分数的转换，这其中的两个关键机制就是对二维地图做区间划分，以及对区间进行编码。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为 Sorted Set 元素的权重分数。这样一来，我们就可以把经纬度保存到 Sorted Set 中，利用 Sorted Set 提供的“按权重进行有序范围查找”的特性，实现 LBS 服务中频繁使用的“搜索附近”的需求。</p>
<p>GEO 属于 Redis 提供的扩展数据类型。扩展数据类型有两种实现途径：一种是基于现有的数据类型，通过数据编码或是实现新的操作的方式，来实现扩展数据类型，例如基于 Sorted Set 和 GeoHash 编码实现 GEO，以及基于 String 和位操作实现 Bitmap；另一种就是开发自定义的数据类型，具体的操作是增加新数据类型的定义，实现创建和释放函数，实现新数据类型支持的命令操作，建议你尝试着把今天学到的内容灵活地应用到你的工作场景中。</p>
<h3 id="总结2-9"><a href="#总结2-9" class="headerlink" title="总结2"></a>总结2</h3><p>1，作者讲了什么？<br>Redis的三种扩展数据类型之一：GEO，一种可以实现LBS服务的数据结构</p>
<p>2，作者是怎么把这事给讲明白的？<br>1，提出一个真问题：打车软件是怎么基于位置提供服务的<br>2，通过GEO原理讲解，说明GEO为什么可以</p>
<p>3，作者为了把这事给讲清楚，讲了那些要点？有哪些亮点？<br>1，亮点1：GEO的原理，这个是我之前所不知道的，学完后对GEO有了一些认知<br>2，亮点2：Redis居然支持自定义数据存储结构，这打开了我的眼界<br>3，要点1：GEO的底层实现，是sortSet，元素是车辆信息，权重是车辆经纬度转换过来的float值<br>4，要点2：GEOHash编码，基本原理“二分区间，区间编码”（二分法的应用，将一个值编码成N位的二进制值）<br>5，要点3：GEO使用GEOHash编码后，将经纬度，按照纬奇经偶位分别填充组合，得到一个车辆的经纬度编码值<br>6，要点4：GEOHash编码实现的效果是将一个空间分割成为一个个方块，可以实现LBS服务（但编码值相近，不一定位置相近）</p>
<p>4，对于作者所讲，我有哪些发散性思考？<br>①：这一篇讲了通过Redis的GEO数据类型可以实现LBS服务，让我体验到了算法的巧妙应用带来的巨大便利（这应是科技让生活更美好的实例）。<br>②：不过，我觉得最大的惊喜在于作者介绍了如何自定义一种新的数据类型，虽然我尚未掌握开发新数据类型的能力。<br>③：通过作者的讲解，拓宽了我了见识，这让我体验到了购买专栏的价值（如果都是搜索引擎能解决的事，何必买专栏）。<br>④：作者细致的讲解开发过程，也让我对Redis的数据结构，RedisObjecti有了进一步认识（面向对象等）</p>
<p>5，在未来的那些场景中，我能够使用它？<br>redis采用的GEOHash算法，貌似可以协助我们处理分省的一些业务</p>
<h3 id="问题-8"><a href="#问题-8" class="headerlink" title="问题"></a>问题</h3><p>我想请你来聊一聊，你在日常的实践过程中，还用过 Redis 的其他数据类型吗？</p>
<h3 id="解答-8"><a href="#解答-8" class="headerlink" title="解答"></a>解答</h3><p>Redis也可以使用List数据类型当做队列使用，一个客户端使用rpush生产数据到Redis中，另一个客户端使用lpop取出数据进行消费，非常方便。但要注意的是，使用List当做队列，缺点是没有ack机制和不支持多个消费者。没有ack机制会导致从Redis中取出的数据后，如果客户端处理失败了，取出的这个数据相当于丢失了，无法重新消费。所以使用List用作队列适合于对于丢失数据不敏感的业务场景，但它的优点是，因为都是内存操作，所以非常快和轻量。</p>
<p>而Redis提供的PubSub，可以支持多个消费者进行消费，生产者发布一条消息，多个消费者同时订阅消费。但是它的缺点是，如果任意一个消费者挂了，等恢复过来后，在这期间的生产者的数据就丢失了。PubSub只把数据发给在线的消费者，消费者一旦下线，就会丢弃数据。另一个缺点是，PubSub中的数据不支持数据持久化，当Redis宕机恢复后，其他类型的数据都可以从RDB和AOF中恢复回来，但PubSub不行，它就是简单的基于内存的多播机制。</p>
<p>之后Redis 5.0推出了Stream数据结构，它借鉴了Kafka的设计思想，弥补了List和PubSub的不足。Stream类型数据可以持久化、支持ack机制、支持多个消费者、支持回溯消费，基本上实现了队列中间件大部分功能，比List和PubSub更可靠。</p>
<p>另一个经常使用的是基于Redis实现的布隆过滤器，其底层实现利用的是String数据结构和位运算，可以解决业务层缓存穿透的问题，而且内存占用非常小，操作非常高效。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/redis/">redis</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E4%BD%BF%E7%94%A8/">使用</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/redis/source-code/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Redis源码剖析与实战</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/golang/ipc-channel/">
                        <span class="hidden-mobile">Go并发编程之终极武器—channel</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"1545f02c9a677f0bd433","clientSecret":"57b1b2091f1c8788e4a2722c7b05ba53bc1e6b18","repo":"zuoshuwen.github.io","owner":"zuoshuwen","admin":["zuoshuwen"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"<your own proxy>/https://github.com/login/oauth/access_token"},
          {
            id: 'be3829fa822868d071dd749c012ab112'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        京ICP备18026333号-1
      </a>
    </span>
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>





  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?97f60cea7055dca81a77d34bd50655bf";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
