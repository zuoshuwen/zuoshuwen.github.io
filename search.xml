<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello Sown</title>
    <url>/2020/12/28/Hello-Sown/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/12/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Go并发编程之传统同步—(1)互斥锁</title>
    <url>/2020/12/28/golang/ipc-mutex/</url>
    <content><![CDATA[<p>先回顾一下，在 C 或者其它编程语言的并发编程中，主要存在两种<strong>通信</strong>（IPC）：</p>
<blockquote>
<ul>
<li><strong>进程间通信</strong>：管道、消息队列、信号等</li>
<li><strong>线程间通信</strong>：互斥锁、条件变量等</li>
</ul>
</blockquote>
<p>利用以上通信手段采取的同步措施，最终是为了达到以下两种目的：</p>
<blockquote>
<ul>
<li><strong>维持共享数据一致性，并发安全</strong></li>
<li><strong>控制流程管理，更好的协同工作</strong></li>
</ul>
</blockquote>
<p>Go语言中除了保留了传统的同步支持，还提供了特有的 CSP 并发编程模型。</p>
<a id="more"></a>

<h2 id="传统同步"><a href="#传统同步" class="headerlink" title="传统同步"></a>传统同步</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>接下来通过一个“做累加”的示例程序，展示<strong>竞争状态</strong>（race condition）。</p>
<h4 id="不加锁"><a href="#不加锁" class="headerlink" title="不加锁"></a>不加锁</h4><p>开启 5000 个 goroutine，让每个 goroutine 给 counter 加 1，最终在所有 goroutine 都完成任务时 counter 的值应该为 5000，先试下不加锁的示例程序表现如何</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDemo1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			counter++</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	t.Logf(<span class="string">&quot;counter = %d&quot;</span>, counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDemo1</span><br><span class="line">    a1_test.go:18: counter &#x3D; 4663</span><br><span class="line">--- PASS: TestDemo1 (1.00s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>
<p>多试几次，结果一直是小于 5000 的不定值。<br>竞争状态下程序行为的图像表示<br><img src="/images/golang/ipc-mutex-01.jpg" alt="ipc-mutex-01"></p>
<h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>将刚刚的代码稍作改动</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDemo2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mut sync.Mutex <span class="comment">// 声明锁</span></span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			mut.Lock() <span class="comment">// 加锁</span></span><br><span class="line">			counter++</span><br><span class="line">			mut.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	t.Logf(<span class="string">&quot;counter = %d&quot;</span>, counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDemo2</span><br><span class="line">    a1_test.go:35: counter &#x3D; 5000</span><br><span class="line">--- PASS: TestDemo2 (1.01s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>
<p>counter = 5000，返回的结果对了。</p>
<p>这就是<strong>互斥锁</strong>，在代码上创建一个<strong>临界区</strong>（critical section），保证串行操作（同一时间只有一个 goroutine 执行临界区代码）。</p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>那么互斥锁是怎么串行的呢？把每一步的执行过程打印出来看下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDemo3</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mut sync.Mutex</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		mut.Lock()</span><br><span class="line">		log.Println(<span class="string">&quot;goroutine B Lock&quot;</span>)</span><br><span class="line">		counter = <span class="number">1</span></span><br><span class="line">		log.Println(<span class="string">&quot;goroutine B counter =&quot;</span>, counter)</span><br><span class="line">		time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">		mut.Unlock()</span><br><span class="line">		log.Println(<span class="string">&quot;goroutine B Unlock&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	mut.Lock()</span><br><span class="line">	log.Println(<span class="string">&quot;goroutine A Lock&quot;</span>)</span><br><span class="line">	counter = <span class="number">2</span></span><br><span class="line">	log.Println(<span class="string">&quot;goroutine A counter =&quot;</span>, counter)</span><br><span class="line">	mut.Unlock()</span><br><span class="line">	log.Println(<span class="string">&quot;goroutine A Unlock&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDemo3</span><br><span class="line">2020&#x2F;09&#x2F;30 22:14:00 goroutine B Lock</span><br><span class="line">2020&#x2F;09&#x2F;30 22:14:00 goroutine B counter &#x3D; 1</span><br><span class="line">2020&#x2F;09&#x2F;30 22:14:05 goroutine B Unlock</span><br><span class="line">2020&#x2F;09&#x2F;30 22:14:05 goroutine A Lock</span><br><span class="line">2020&#x2F;09&#x2F;30 22:14:05 goroutine A counter &#x3D; 2</span><br><span class="line">2020&#x2F;09&#x2F;30 22:14:05 goroutine A Unlock</span><br><span class="line">--- PASS: TestDemo3 (5.00s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>
<p>通过每个操作记录下来的时间可以看出，goroutine A 的 Lock 一直阻塞到了 goroutine B 的 Unlock。<br><img src="/images/golang/ipc-mutex-02.jpg" alt="ipc-mutex-01"></p>
<h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>这时候有个疑问，那 goroutine B 上的锁，goroutine A 能解锁吗？修改一下刚才的代码，试一下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDemo5</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mut sync.Mutex</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		mut.Lock()</span><br><span class="line">		log.Println(<span class="string">&quot;goroutine B Lock&quot;</span>)</span><br><span class="line">		counter = <span class="number">1</span></span><br><span class="line">		log.Println(<span class="string">&quot;goroutine B counter =&quot;</span>, counter)</span><br><span class="line">		time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">		<span class="comment">//mut.Unlock()</span></span><br><span class="line">		<span class="comment">//log.Println(&quot;goroutine B Unlock&quot;)</span></span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	mut.Unlock()</span><br><span class="line">	log.Println(<span class="string">&quot;goroutine A Unlock&quot;</span>)</span><br><span class="line">	counter = <span class="number">2</span></span><br><span class="line">	log.Println(<span class="string">&quot;goroutine A counter =&quot;</span>, counter)</span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDemo5</span><br><span class="line">2020&#x2F;09&#x2F;30 22:15:03 goroutine B Lock</span><br><span class="line">2020&#x2F;09&#x2F;30 22:15:03 goroutine B counter &#x3D; 1</span><br><span class="line">2020&#x2F;09&#x2F;30 22:15:04 goroutine A Unlock</span><br><span class="line">2020&#x2F;09&#x2F;30 22:15:04 goroutine A counter &#x3D; 2</span><br><span class="line">--- PASS: TestDemo5 (3.01s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>
<p>测试通过，未报错，counter 的值也被成功修改，证明B上的锁，是可以被A解开的。</p>
<p>再进一步，goroutine A 不解锁，直接修改已经被 goroutine B 锁住的 counter 的值可以吗？试一下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDemo6</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mut sync.Mutex</span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		mut.Lock()</span><br><span class="line">		log.Println(<span class="string">&quot;goroutine B Lock&quot;</span>)</span><br><span class="line">		counter = <span class="number">1</span></span><br><span class="line">		log.Println(<span class="string">&quot;goroutine B counter =&quot;</span>, counter)</span><br><span class="line">		time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">		mut.Unlock()</span><br><span class="line">		log.Println(<span class="string">&quot;goroutine B Unlock&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="comment">//log.Println(&quot;goroutine A Unlock&quot;)</span></span><br><span class="line">	<span class="comment">//mut.Unlock()</span></span><br><span class="line">	counter = <span class="number">2</span></span><br><span class="line">	log.Println(<span class="string">&quot;goroutine A counter =&quot;</span>, counter)</span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDemo6</span><br><span class="line">2020&#x2F;09&#x2F;30 22:15:43 goroutine B Lock</span><br><span class="line">2020&#x2F;09&#x2F;30 22:15:43 goroutine B counter &#x3D; 1</span><br><span class="line">2020&#x2F;09&#x2F;30 22:15:44 goroutine A counter &#x3D; 2</span><br><span class="line">2020&#x2F;09&#x2F;30 22:15:48 goroutine B Unlock</span><br><span class="line">--- PASS: TestDemo6 (11.00s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>
<p>测试通过，未报错，证明B上的锁，A可以不用解锁直接改。</p>
<h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><h3 id="锁的两种通常处理方式"><a href="#锁的两种通常处理方式" class="headerlink" title="锁的两种通常处理方式"></a>锁的两种通常处理方式</h3><ul>
<li>一种是没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁叫做<strong>自旋锁</strong>，它不用将线程阻塞起来(NON-BLOCKING)；</li>
<li>还有一种处理方式就是把自己阻塞起来，等待重新调度请求，这种叫做互斥锁。</li>
</ul>
<h3 id="饥饿模式"><a href="#饥饿模式" class="headerlink" title="饥饿模式"></a>饥饿模式</h3><p>当互斥锁不断地试图获得一个永远无法获得的锁时，它可能会遇到饥饿问题。<br>在版本1.9中，Go通过添加一个新的饥饿模式来解决先前的问题，所有等待锁定超过一毫秒的 goroutine，也称为有界等待，将被标记为饥饿。当标记为饥饿时，解锁方法现在将把锁直接移交给第一位等待着。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁和上面的多也差不多，有这么几种情况</p>
<ul>
<li>在写锁已被锁定的情况下试图锁定写锁，会阻塞当前的 goroutine。</li>
<li>在写锁已被锁定的情况下试图锁定读锁，会阻塞当前的 goroutine。</li>
<li>在读锁已被锁定的情况下试图锁定写锁，会阻塞当前的 goroutine。</li>
<li>在读锁已被锁定的情况下试图锁定读锁，不会阻塞当前的 goroutine。</li>
</ul>
<h3 id="panic错误"><a href="#panic错误" class="headerlink" title="panic错误"></a>panic错误</h3><p>无论是互斥锁还是读写锁在程序运行时一定是成对的，不然就会引发不可恢复的panic。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>锁一定要用对地方，特别是要注意Lock产生的阻塞对性能的影响。</li>
<li>在各种程序的逻辑分支下，都要确保锁的成对出现。</li>
<li>读写锁是对互斥锁的一个扩展，提高了程序的可读性。</li>
<li>临界区是需要每个 goroutine 主动遵守的，说白了就是每个 goroutine 的代码都存在 Lock。</li>
</ol>
<p><a href="https://github.com/zuoshuwen/go-example/blob/master/e001/a01_test.go">文章示例代码</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>同步</tag>
        <tag>互斥锁</tag>
      </tags>
  </entry>
</search>
