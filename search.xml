<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Go数据结构之数组与切片</title>
    <url>/golang/datastruct-arrayslice/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数组的长度是声明的时候就固定好的，后面不可能变大，而且长度和容量相等。</p>
<p>切片的长度和容量后面可以随着元素增多而增长，但是容量不可能小于长度。</p>
<a id="more"></a>

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="声明-amp-初始化"><a href="#声明-amp-初始化" class="headerlink" title="声明&amp;初始化"></a>声明&amp;初始化</h3><p>在 Go 中声明即初始化，如果在声明的时候没有初始化值，那么就会赋值为声明类型的「零值」。</p>
<div class="code-wrapper"><pre><code class="hljs reasonml">func <span class="hljs-constructor">TestDemo1(<span class="hljs-params">t</span> <span class="hljs-operator">*</span><span class="hljs-params">testing</span>.T)</span> &#123;
	<span class="hljs-comment">// 数组</span>
	var array1 <span class="hljs-literal">[<span class="hljs-number">5</span>]</span><span class="hljs-built_in">int</span>        <span class="hljs-comment">// 只需设置长度，后面不可变</span>
	var array2 = <span class="hljs-keyword">new</span>(<span class="hljs-literal">[<span class="hljs-number">5</span>]</span><span class="hljs-built_in">int</span>) <span class="hljs-comment">// 返回指针</span>

	<span class="hljs-comment">// 切片</span>
	var slice1 <span class="hljs-literal">[]</span><span class="hljs-built_in">int</span>
	var slice2 = make(<span class="hljs-literal">[]</span><span class="hljs-built_in">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 设置长度、容量，后面可变</span>

	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array1 val:&quot;</span>, <span class="hljs-params">array1</span>)</span>      <span class="hljs-comment">// [0 0 0 0 0]</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array1 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">array1</span>)</span>) <span class="hljs-comment">// 5</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array1 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">array1</span>)</span>) <span class="hljs-comment">// 5</span>

	fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;&quot;</span>)</span>

	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array2 val:&quot;</span>, <span class="hljs-params">array2</span>)</span>      <span class="hljs-comment">// &amp;[0 0 0 0 0]</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array2 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">array2</span>)</span>) <span class="hljs-comment">// 5</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array2 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">array2</span>)</span>) <span class="hljs-comment">// 5</span>

	fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;&quot;</span>)</span>

	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice1 val:&quot;</span>, <span class="hljs-params">slice1</span>)</span>      <span class="hljs-comment">// []</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice1 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">slice1</span>)</span>) <span class="hljs-comment">// 0</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice1 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">slice1</span>)</span>) <span class="hljs-comment">// 0</span>

	fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;&quot;</span>)</span>

	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice2 val:&quot;</span>, <span class="hljs-params">slice2</span>)</span>      <span class="hljs-comment">// [0 0 0 0 0]</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice2 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">slice2</span>)</span>) <span class="hljs-comment">// 5</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice2 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">slice2</span>)</span>) <span class="hljs-comment">// 5</span>
&#125;</code></pre></div>
<p>在声明的时候就初始化：</p>
<div class="code-wrapper"><pre><code class="hljs reasonml">func <span class="hljs-constructor">TestDemo2(<span class="hljs-params">t</span> <span class="hljs-operator">*</span><span class="hljs-params">testing</span>.T)</span> &#123;
	<span class="hljs-comment">// 数组</span>
	var array1 = <span class="hljs-literal">[<span class="hljs-number">5</span>]</span><span class="hljs-built_in">int</span>&#123;<span class="hljs-number">4</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">5</span>&#125;
	var array2 = <span class="hljs-literal">[<span class="hljs-operator">...</span>]</span><span class="hljs-built_in">int</span>&#123;<span class="hljs-number">4</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">5</span>&#125;

	<span class="hljs-comment">// 切片</span>
	var slice1 = <span class="hljs-literal">[]</span><span class="hljs-built_in">int</span>&#123;<span class="hljs-number">4</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">5</span>&#125;
	var slice2 = array1<span class="hljs-literal">[:]</span> <span class="hljs-comment">// 从数组截取来的切片</span>

	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array1 val:&quot;</span>, <span class="hljs-params">array1</span>)</span>      <span class="hljs-comment">// [0 0 5 0 1]</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array1 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">array1</span>)</span>) <span class="hljs-comment">// 5</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array1 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">array1</span>)</span>) <span class="hljs-comment">// 5</span>

	fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;&quot;</span>)</span>

	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array2 val:&quot;</span>, <span class="hljs-params">array2</span>)</span>      <span class="hljs-comment">// [0 0 5 0 1]</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array2 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">array2</span>)</span>) <span class="hljs-comment">// 5</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array2 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">array2</span>)</span>) <span class="hljs-comment">// 5</span>

	fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;&quot;</span>)</span>

	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice1 val:&quot;</span>, <span class="hljs-params">slice1</span>)</span>      <span class="hljs-comment">// [0 0 5 0 1]</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice1 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">slice1</span>)</span>) <span class="hljs-comment">// 5</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice1 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">slice1</span>)</span>) <span class="hljs-comment">// 5</span>

	fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;&quot;</span>)</span>

	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice2 val:&quot;</span>, <span class="hljs-params">slice2</span>)</span>      <span class="hljs-comment">// [0 0 5 0 1]</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice2 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">slice2</span>)</span>) <span class="hljs-comment">// 5</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice2 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">slice2</span>)</span>) <span class="hljs-comment">// 5</span>
&#125;</code></pre></div>

<h3 id="添加-amp-更新元素值"><a href="#添加-amp-更新元素值" class="headerlink" title="添加&amp;更新元素值"></a>添加&amp;更新元素值</h3><p>数组因为长度固定，且的值都是初始化好了的，所以只有更新。</p>
<p>切片更新操作和数据一样，只不过新增元素只能通过 append() 方法。</p>
<blockquote>
<p>append()：将元素追加大切片的末尾，如果容量不够，会进行扩容。</p>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs reasonml">func <span class="hljs-constructor">TestDemo3(<span class="hljs-params">t</span> <span class="hljs-operator">*</span><span class="hljs-params">testing</span>.T)</span> &#123;
	<span class="hljs-comment">// 数组</span>
	var array1 = <span class="hljs-literal">[<span class="hljs-number">5</span>]</span><span class="hljs-built_in">int</span>&#123;<span class="hljs-number">4</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">5</span>&#125;
	array1<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = <span class="hljs-number">100</span> <span class="hljs-comment">// 更新</span>
	array1<span class="hljs-literal">[<span class="hljs-number">4</span>]</span> = <span class="hljs-number">100</span> <span class="hljs-comment">// 更新</span>

	<span class="hljs-comment">// 切片</span>
	var slice1 = <span class="hljs-literal">[]</span><span class="hljs-built_in">int</span>&#123;<span class="hljs-number">4</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">5</span>&#125;
	array1<span class="hljs-literal">[<span class="hljs-number">4</span>]</span> = <span class="hljs-number">100</span> <span class="hljs-comment">// 更新</span>
	<span class="hljs-comment">//array1[5] = 100 // 报错</span>
	slice1 = append(slice1, <span class="hljs-number">1</span>) <span class="hljs-comment">// 切片增加元素只能使用此方法</span>

	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array1 val:&quot;</span>, <span class="hljs-params">array1</span>)</span>      <span class="hljs-comment">// [100 0 5 0 100]</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array1 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">array1</span>)</span>) <span class="hljs-comment">// 5</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array1 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">array1</span>)</span>) <span class="hljs-comment">// 5</span>

	fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;&quot;</span>)</span>

	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice1 val:&quot;</span>, <span class="hljs-params">slice1</span>)</span>      <span class="hljs-comment">// [0 0 5 0 1 1]</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice1 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">slice1</span>)</span>) <span class="hljs-comment">// 6</span>
	t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice1 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">slice1</span>)</span>) <span class="hljs-comment">// 10</span>
&#125;</code></pre></div>

<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>数组与切片，都可以使用表达式截取，截取之后的数据它的类型为切片。</p>
<div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-keyword">func</span> TestDemo4(t *testing.T) &#123;
	array1 := [<span class="hljs-number">10</span>]int&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;

	slice1 := array1[<span class="hljs-number">3</span>:]              <span class="hljs-regexp">//</span> 从 index <span class="hljs-number">3</span> 取到 index end
	t.Log(<span class="hljs-string">&quot;slice1 val:&quot;</span>, slice1)      <span class="hljs-regexp">//</span> [<span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span>]
	t.Log(<span class="hljs-string">&quot;slice1 len:&quot;</span>, len(slice1)) <span class="hljs-regexp">//</span> <span class="hljs-number">7</span>
	t.Log(<span class="hljs-string">&quot;slice1 cap:&quot;</span>, cap(slice1)) <span class="hljs-regexp">//</span> <span class="hljs-number">7</span>

	fmt.Println(<span class="hljs-string">&quot;&quot;</span>)

	slice2 := array1[<span class="hljs-number">3</span>:<span class="hljs-number">4</span>]             <span class="hljs-regexp">//</span> 从 index <span class="hljs-number">3</span> 取到 index <span class="hljs-number">4</span>
	t.Log(<span class="hljs-string">&quot;slice2 val:&quot;</span>, slice2)      <span class="hljs-regexp">//</span> [<span class="hljs-number">3</span>]
	t.Log(<span class="hljs-string">&quot;slice2 len:&quot;</span>, len(slice2)) <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>
	t.Log(<span class="hljs-string">&quot;slice2 cap:&quot;</span>, cap(slice2)) <span class="hljs-regexp">//</span> <span class="hljs-number">7</span>

	fmt.Println(<span class="hljs-string">&quot;&quot;</span>)

	slice3 := array1[<span class="hljs-number">3</span>:<span class="hljs-number">6</span>:<span class="hljs-number">6</span>]           <span class="hljs-regexp">//</span> 从 index <span class="hljs-number">3</span> 取到 index <span class="hljs-number">6</span>，容量取到 index <span class="hljs-number">6</span>
	t.Log(<span class="hljs-string">&quot;slice3 val:&quot;</span>, slice3)      <span class="hljs-regexp">//</span> [<span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span>]
	t.Log(<span class="hljs-string">&quot;slice3 len:&quot;</span>, len(slice3)) <span class="hljs-regexp">//</span> <span class="hljs-number">3</span>
	t.Log(<span class="hljs-string">&quot;slice3 cap:&quot;</span>, cap(slice3)) <span class="hljs-regexp">//</span> <span class="hljs-number">3</span>

	fmt.Println(<span class="hljs-string">&quot;&quot;</span>)

	slice4 := array1[<span class="hljs-number">3</span>:<span class="hljs-number">6</span>:<span class="hljs-number">9</span>]           <span class="hljs-regexp">//</span> 从 index <span class="hljs-number">3</span> 取到 index <span class="hljs-number">6</span>，容量取到 index <span class="hljs-number">9</span>
	t.Log(<span class="hljs-string">&quot;slice4 val:&quot;</span>, slice4)      <span class="hljs-regexp">//</span> [<span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span>]
	t.Log(<span class="hljs-string">&quot;slice4 len:&quot;</span>, len(slice4)) <span class="hljs-regexp">//</span> <span class="hljs-number">3</span>
	t.Log(<span class="hljs-string">&quot;slice4 cap:&quot;</span>, cap(slice4)) <span class="hljs-regexp">//</span> <span class="hljs-number">6</span>
&#125;</code></pre></div>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>使用 for、range</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo5</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	array1 := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;
	slice1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>)
	<span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> array1 &#123;
		fmt.Println(k, <span class="hljs-string">&quot;-&quot;</span>, v)
	&#125;
	fmt.Println()
	<span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> slice1 &#123;
		fmt.Println(k, <span class="hljs-string">&quot;-&quot;</span>, v)
	&#125;
&#125;</code></pre></div>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>数组与数组可以使用 == 比较，不能与 nil 比较</p>
<p>切片与切片不能使用 == 比较，可以使用 reflect.DeepEqual 比较，可以与 nil 比较</p>
<div class="code-wrapper"><pre><code class="hljs jboss-cli">func TestDemo6<span class="hljs-params">(t *testing.T)</span> &#123;
	array1 := [<span class="hljs-string">...</span>]int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 4&#125;
	array2 := [<span class="hljs-string">...</span>]int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 9&#125;
	array3 := [<span class="hljs-string">...</span>]int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 9&#125;

	t.Logf<span class="hljs-params">(&quot;<span class="hljs-attr">array1</span> == array2 %t\n&quot;, <span class="hljs-attr">array1</span> == array2)</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span>
	t.Logf<span class="hljs-params">(&quot;<span class="hljs-attr">array2</span> == array3 %t\n&quot;, <span class="hljs-attr">array2</span> == array3)</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span>
	<span class="hljs-string">//t.Logf</span><span class="hljs-params">(&quot;%t\n&quot;, <span class="hljs-attr">array2</span> == nil)</span> <span class="hljs-string">//</span> 会报错，数组不能与nil比

	slice1 := make<span class="hljs-params">([]int, 5, 5)</span>
	var slice2 []int
	slice3 := []int&#123;4: 0&#125;

	<span class="hljs-string">//</span> t.Logf<span class="hljs-params">(&quot;%t\n&quot;, <span class="hljs-attr">slice1</span> == slice2)</span> <span class="hljs-string">//</span> 会报错，切片与切片不能比
	t.Logf<span class="hljs-params">(&quot;<span class="hljs-attr">slice1</span> == nil %t\n&quot;, <span class="hljs-attr">slice1</span> == nil)</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span>
	t.Logf<span class="hljs-params">(&quot;<span class="hljs-attr">slice2</span> == nil %t\n&quot;, <span class="hljs-attr">slice2</span> == nil)</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span>
	t.Logf<span class="hljs-params">(&quot;<span class="hljs-attr">slice3</span> == nil %t\n&quot;, <span class="hljs-attr">slice3</span> == nil)</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span>

	t.Logf<span class="hljs-params">(&quot;<span class="hljs-attr">slice1</span> == slice2 %t\n&quot;, reflect.DeepEqual(slice1, slice2)</span>) <span class="hljs-string">//</span> <span class="hljs-literal">false</span>
	t.Logf<span class="hljs-params">(&quot;<span class="hljs-attr">slice2</span> == slice3 %t\n&quot;, reflect.DeepEqual(slice2, slice3)</span>) <span class="hljs-string">//</span> <span class="hljs-literal">false</span>
	t.Logf<span class="hljs-params">(&quot;<span class="hljs-attr">slice1</span> == slice3 %t\n&quot;, reflect.DeepEqual(slice1, slice3)</span>) <span class="hljs-string">//</span> <span class="hljs-literal">true</span>
&#125;</code></pre></div>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>需使用 append()、切片表达式 结合来完成</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo7</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	slice1 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;
	slice1 = <span class="hljs-built_in">append</span>(slice1[:<span class="hljs-number">2</span>], slice1[<span class="hljs-number">3</span>:]...)
	t.Log(slice1)
&#125;</code></pre></div>

<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="数组与切片的关系"><a href="#数组与切片的关系" class="headerlink" title="数组与切片的关系"></a>数组与切片的关系</h3><p><strong>数组为值类型，切片为引用类型</strong>，他们又有何关系呢？</p>
<p>程序示例：</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo8</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	array1 := [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;

	slice1 := array1[:]

	t.Log(<span class="hljs-string">&quot;slice1 val:&quot;</span>, slice1)      <span class="hljs-comment">// [9 1 7 3 0 5 6 2 8 4]</span>
	t.Log(<span class="hljs-string">&quot;slice1 len:&quot;</span>, <span class="hljs-built_in">len</span>(slice1)) <span class="hljs-comment">// 10</span>
	t.Log(<span class="hljs-string">&quot;slice1 cap:&quot;</span>, <span class="hljs-built_in">cap</span>(slice1)) <span class="hljs-comment">// 10</span>

	array1[<span class="hljs-number">9</span>] = <span class="hljs-number">96969696</span> <span class="hljs-comment">// array1 的修改会影响到 slice1</span>

	fmt.Println(<span class="hljs-string">&quot;&quot;</span>)

	t.Log(<span class="hljs-string">&quot;slice1 val:&quot;</span>, slice1)      <span class="hljs-comment">// [9 1 7 3 0 5 6 2 8 96969696]</span>
	t.Log(<span class="hljs-string">&quot;slice1 len:&quot;</span>, <span class="hljs-built_in">len</span>(slice1)) <span class="hljs-comment">// 10</span>
	t.Log(<span class="hljs-string">&quot;slice1 cap:&quot;</span>, <span class="hljs-built_in">cap</span>(slice1)) <span class="hljs-comment">// 10</span>
&#125;</code></pre></div>
<p>在这个示例程序中，可以说 slice1 是 array1 的引用。</p>
<p>不光是在示例程序中，这种在数组上通过表达式截取出的切片，为数组的引用，就算在程序中，直接声明一个新切片（var slice1 []int），在切片的底层实现，其实也是引用了一个数组。</p>
<p>他们的关系就是：<strong>数组是切片的底层实现，切片是数组的引用。</strong></p>
<h3 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h3><p>在示例程序 TestDemo8 中，slice1 会一直引用 array1 么？</p>
<p>一般情况下是这样，但有种情况下引用会发生变化，就是在 slice 发生扩容的情况下</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo9</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	array1 := [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;
	slice1 := array1[:] <span class="hljs-comment">// 从 array1 截取出 slice1</span>

	t.Log(<span class="hljs-string">&quot;slice1 val:&quot;</span>, slice1)      <span class="hljs-comment">// [9 1 7 3 0 5 6 2 8 4]</span>
	t.Log(<span class="hljs-string">&quot;slice1 len:&quot;</span>, <span class="hljs-built_in">len</span>(slice1)) <span class="hljs-comment">// 10</span>
	t.Log(<span class="hljs-string">&quot;slice1 cap:&quot;</span>, <span class="hljs-built_in">cap</span>(slice1)) <span class="hljs-comment">// 10</span>

	slice1 = <span class="hljs-built_in">append</span>(slice1, <span class="hljs-number">9</span>) <span class="hljs-comment">// 进行扩容后，slice1 指向了新的底层数组，不在是 array1 的引用</span>
	array1[<span class="hljs-number">9</span>] = <span class="hljs-number">96969696</span>

	fmt.Println(<span class="hljs-string">&quot;&quot;</span>)

	t.Log(<span class="hljs-string">&quot;slice1 val:&quot;</span>, slice1)      <span class="hljs-comment">// [9 1 7 3 0 5 6 2 8 4 9]</span>
	t.Log(<span class="hljs-string">&quot;slice1 len:&quot;</span>, <span class="hljs-built_in">len</span>(slice1)) <span class="hljs-comment">// 11</span>
	t.Log(<span class="hljs-string">&quot;slice1 cap:&quot;</span>, <span class="hljs-built_in">cap</span>(slice1)) <span class="hljs-comment">// 20</span>
&#125;</code></pre></div>
<p>当切片添加新元素，发现容量不够时，会开辟一个新的底层数组，然后把旧数组的数据和添加的新元素一并拷贝到新数组中。</p>
<h4 id="扩容策略："><a href="#扩容策略：" class="headerlink" title="扩容策略："></a>扩容策略：</h4><ul>
<li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）</li>
<li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）</li>
<li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li>
<li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）</li>
</ul>
<h3 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h3><p>靠扩容解决引用问题，显得不是那么优雅。</p>
<p>可以使用 copy() 进行深复制</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo10</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	array1 := [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;

	<span class="hljs-keyword">var</span> slice1 = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)
	<span class="hljs-built_in">copy</span>(slice1, array1[:]) <span class="hljs-comment">// 深复制，slice1 不会引用 array1</span>
	array1[<span class="hljs-number">9</span>] = <span class="hljs-number">96969696</span>

	t.Log(<span class="hljs-string">&quot;slice1 val:&quot;</span>, slice1)      <span class="hljs-comment">// [9 1 7 3 0 5 6 2 8 4]</span>
	t.Log(<span class="hljs-string">&quot;slice1 len:&quot;</span>, <span class="hljs-built_in">len</span>(slice1)) <span class="hljs-comment">// 10</span>
	t.Log(<span class="hljs-string">&quot;slice1 cap:&quot;</span>, <span class="hljs-built_in">cap</span>(slice1)) <span class="hljs-comment">// 10</span>

	fmt.Println(<span class="hljs-string">&quot;&quot;</span>)

	t.Log(<span class="hljs-string">&quot;array1 val:&quot;</span>, array1)      <span class="hljs-comment">// [9 1 7 3 0 5 6 2 8 96969696]</span>
	t.Log(<span class="hljs-string">&quot;array1 len:&quot;</span>, <span class="hljs-built_in">len</span>(array1)) <span class="hljs-comment">// 10</span>
	t.Log(<span class="hljs-string">&quot;array1 cap:&quot;</span>, <span class="hljs-built_in">cap</span>(array1)) <span class="hljs-comment">// 10</span>
&#125;</code></pre></div>

<h3 id="传递"><a href="#传递" class="headerlink" title="传递"></a>传递</h3><p>切片，如果不使用 copy() 进行深复制出一个新的切片，直接传递过去的切片底层还是同一个数组，当然，append() 发生了扩容之后，就不会是同一个数组了。</p>
<p>数组，直接传递会变成两个数组，如果运用了指针，会指向同一个。</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo11</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	<span class="hljs-comment">// 切片，底层引用的还是同一个数组</span>
	slice1 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v []<span class="hljs-keyword">int</span>)</span></span> &#123;
		<span class="hljs-comment">//v = append(v, 20) // 扩容后底层数组就变了</span>
		v[<span class="hljs-number">0</span>] = <span class="hljs-number">99999</span>
		t.Log(v)
	&#125;(slice1)
	time.Sleep(<span class="hljs-number">1</span> * time.Second)
	t.Log(<span class="hljs-string">&quot;slice1&quot;</span>, slice1) <span class="hljs-comment">// slice1 [99999 1 7 3 0 5 6 2 8 4]</span>

	fmt.Println()

	<span class="hljs-comment">// 切片，copy() 深复制后，底层不是同一个数组</span>
	slice2 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;
	slice2Copy := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)
	<span class="hljs-built_in">copy</span>(slice2Copy, slice2)
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v []<span class="hljs-keyword">int</span>)</span></span> &#123;
		v[<span class="hljs-number">0</span>] = <span class="hljs-number">99999</span>
	&#125;(slice2Copy)
	time.Sleep(<span class="hljs-number">1</span> * time.Second)
	t.Log(<span class="hljs-string">&quot;slice2&quot;</span>, slice2) <span class="hljs-comment">// slice2 [9 1 7 3 0 5 6 2 8 4]</span>

	fmt.Println()

	<span class="hljs-comment">// 数组，不是同一个</span>
	array1 := [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v [10]<span class="hljs-keyword">int</span>)</span></span> &#123;
		v[<span class="hljs-number">0</span>] = <span class="hljs-number">99999</span>
	&#125;(array1)
	time.Sleep(<span class="hljs-number">1</span> * time.Second)
	t.Log(<span class="hljs-string">&quot;array1&quot;</span>, array1) <span class="hljs-comment">// array1 [9 1 7 3 0 5 6 2 8 4]</span>
	fmt.Println()

	<span class="hljs-comment">// 数组，同一个</span>
	array2 := [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v *[10]<span class="hljs-keyword">int</span>)</span></span> &#123;
		v[<span class="hljs-number">0</span>] = <span class="hljs-number">99999</span>
	&#125;(&amp;array2)
	time.Sleep(<span class="hljs-number">1</span> * time.Second)
	t.Log(<span class="hljs-string">&quot;array2&quot;</span>, array2) <span class="hljs-comment">// array2 [99999 1 7 3 0 5 6 2 8 4]</span>

	fmt.Println()

	<span class="hljs-comment">// 数组 同一个</span>
	array3 := <span class="hljs-built_in">new</span>([<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>)
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v *[10]<span class="hljs-keyword">int</span>)</span></span> &#123;
		v[<span class="hljs-number">0</span>] = <span class="hljs-number">99999</span>
	&#125;(array3)
	time.Sleep(<span class="hljs-number">1</span> * time.Second)
	t.Log(<span class="hljs-string">&quot;array3&quot;</span>, array3) <span class="hljs-comment">// array3 &amp;[99999 0 0 0 0 0 0 0 0 0]</span>
&#125;</code></pre></div>
<p>效果和下面一样</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo12</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	array1 := [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;
	array2 := array1
	array2[<span class="hljs-number">0</span>] = <span class="hljs-number">999</span>
	t.Log(<span class="hljs-string">&quot;array1&quot;</span>, array1) <span class="hljs-comment">// array1 [9 1 7 3 0 5 6 2 8 4]</span>
	t.Log(<span class="hljs-string">&quot;array2&quot;</span>, array2) <span class="hljs-comment">// array2 [999 1 7 3 0 5 6 2 8 4]</span>

	fmt.Println()

	slice1 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;
	slice2 := slice1
	slice2[<span class="hljs-number">0</span>] = <span class="hljs-number">999</span>
	t.Log(<span class="hljs-string">&quot;slice1&quot;</span>, slice1) <span class="hljs-comment">// slice1 [999 1 7 3 0 5 6 2 8 4]</span>
	t.Log(<span class="hljs-string">&quot;slice2&quot;</span>, slice2) <span class="hljs-comment">// slice2 [999 1 7 3 0 5 6 2 8 4]</span>
&#125;</code></pre></div>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>一段连续的内存空间。</p>
<h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>make 只能用于 slice、map、channel，返回的初始化后的（非零）值。</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul>
<li>切片</li>
<li>字典</li>
<li>通道</li>
<li>函数</li>
</ul>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><ul>
<li>数组</li>
<li>基础数据类型</li>
<li>结构体类型</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>切片是数组的引用，数组是切片的底层实现。</li>
<li>数组的长度(len)等于容量(cap)，切片的长度(len)小于等于容量(cap)。</li>
<li>数组声明的时候默认就会初始化，值为类型的「零值」；切片声明的时候，如果不初始化，值是 nil。</li>
<li>使用 copy() 深复制解决引用问题。</li>
</ol>
<p><a href="https://github.com/zuoshuwen/go-example/blob/master/e005/a01_test.go">文章示例代码</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>切片</tag>
      </tags>
  </entry>
  <entry>
    <title>Go并发编程之传统同步—(3)原子操作</title>
    <url>/golang/ipc-atomic/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前文章中介绍的互斥锁虽然能够保证同串行化，但是却保证不了执行过程中的中断。<br>要么成功、要么失败，没有中断的情况，我们叫它叫原子性，这种由硬件 CPU 提供支持的特性，是非常可靠的。</p>
<p><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C">百度百科</a>上关于原子操作的介绍。</p>
<a id="more"></a>

<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>由 sync/atomic 包提供操作支持。</p>
<h3 id="加法（add）"><a href="#加法（add）" class="headerlink" title="加法（add）"></a>加法（add）</h3><p>实现累加</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo1</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	<span class="hljs-keyword">var</span> counter <span class="hljs-keyword">int64</span> = <span class="hljs-number">0</span>

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;
		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
			atomic.AddInt64(&amp;counter, <span class="hljs-number">1</span>)
		&#125;()
	&#125;

	time.Sleep(<span class="hljs-number">2</span> * time.Second)
	log.Println(<span class="hljs-string">&quot;counter:&quot;</span>, atomic.LoadInt64(&amp;counter))
&#125;</code></pre></div>
<p>结果</p>
<div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">=== RUN   TestDemo1</span>
2020/10/11 00:24:56 counter: 100
<span class="hljs-bullet">--- </span>PASS: TestDemo1 (2.00s)
PASS</code></pre></div>

<h3 id="减法（add）"><a href="#减法（add）" class="headerlink" title="减法（add）"></a>减法（add）</h3><p>对于做减法，是没有直接提供的方法的，而 Add（-1）这种是不能对 uint 类型使用的，可以通过补码的方式实现</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo2</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	<span class="hljs-keyword">var</span> counter <span class="hljs-keyword">uint64</span> = <span class="hljs-number">100</span>

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;
		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
			atomic.AddUint64(&amp;counter, ^<span class="hljs-keyword">uint64</span>(-(<span class="hljs-number">-1</span>)<span class="hljs-number">-1</span>))
		&#125;()
	&#125;

	time.Sleep(<span class="hljs-number">2</span> * time.Second)
	log.Println(<span class="hljs-string">&quot;counter:&quot;</span>, atomic.LoadUint64(&amp;counter))
&#125;</code></pre></div>
<p>结果</p>
<div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">=== RUN   TestDemo2</span>
2020/10/11 00:32:05 counter: 0
<span class="hljs-bullet">--- </span>PASS: TestDemo2 (2.00s)
PASS</code></pre></div>

<h3 id="比较并交换（compare-and-swap，简称-CAS）"><a href="#比较并交换（compare-and-swap，简称-CAS）" class="headerlink" title="比较并交换（compare and swap，简称 CAS）"></a>比较并交换（compare and swap，简称 CAS）</h3><p>并发编程中，在没有使用互斥锁的前提下，对共享数据先取出做判断，再根据判断的结果做后续操作，必然是会出问题的，使用 CAS 可以避免这种问题。</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo3</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	<span class="hljs-keyword">var</span> first <span class="hljs-keyword">int64</span> = <span class="hljs-number">0</span>

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10000</span>; i++ &#123;
		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;
			<span class="hljs-keyword">if</span> atomic.CompareAndSwapInt64(&amp;first, <span class="hljs-number">0</span>, <span class="hljs-keyword">int64</span>(i)) &#123;
				log.Println(<span class="hljs-string">&quot;抢先运行的是 goroutine&quot;</span>, i)
			&#125;
		&#125;(i)
	&#125;

	time.Sleep(<span class="hljs-number">2</span> * time.Second)
	log.Println(<span class="hljs-string">&quot;num:&quot;</span>, atomic.LoadInt64(&amp;first))
&#125;</code></pre></div>
<p>结果</p>
<div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">=== RUN   TestDemo3</span>
2020/10/11 00:42:10 抢先运行的是 goroutine 3
2020/10/11 00:42:12 num: 3
<span class="hljs-bullet">--- </span>PASS: TestDemo3 (2.01s)
PASS</code></pre></div>

<h3 id="加载（load）"><a href="#加载（load）" class="headerlink" title="加载（load）"></a>加载（load）</h3><p>加载操作在进行时只会有一个，不会有其它的读写操作同时进行。</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo4</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	<span class="hljs-keyword">var</span> counter <span class="hljs-keyword">int64</span> = <span class="hljs-number">0</span>

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;
		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
			atomic.AddInt64(&amp;counter, <span class="hljs-number">1</span>)
			log.Println(<span class="hljs-string">&quot;counter:&quot;</span>, atomic.LoadInt64(&amp;counter))
		&#125;()
	&#125;

	time.Sleep(<span class="hljs-number">2</span> * time.Second)
&#125;</code></pre></div>

<h3 id="存储（store）"><a href="#存储（store）" class="headerlink" title="存储（store）"></a>存储（store）</h3><p>存储操作在进行时只会有一个，不会有其它的读写操作同时进行。</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo5</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	<span class="hljs-keyword">var</span> counter <span class="hljs-keyword">int64</span> = <span class="hljs-number">0</span>

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;
		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;
			atomic.StoreInt64(&amp;counter, <span class="hljs-keyword">int64</span>(i))
			log.Println(<span class="hljs-string">&quot;counter:&quot;</span>, atomic.LoadInt64(&amp;counter))
		&#125;(i)
	&#125;

	time.Sleep(<span class="hljs-number">2</span> * time.Second)
&#125;</code></pre></div>

<h3 id="交换（swap）"><a href="#交换（swap）" class="headerlink" title="交换（swap）"></a>交换（swap）</h3><p>swap 方法返回被替换之前的旧值。</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo6</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	<span class="hljs-keyword">var</span> counter <span class="hljs-keyword">int64</span> = <span class="hljs-number">0</span>

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;
		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;
			log.Println(<span class="hljs-string">&quot;counter old:&quot;</span>, atomic.SwapInt64(&amp;counter, <span class="hljs-keyword">int64</span>(i)))
		&#125;(i)
	&#125;

	time.Sleep(<span class="hljs-number">2</span> * time.Second)
&#125;</code></pre></div>
<p>结果</p>
<div class="code-wrapper"><pre><code class="hljs groovy">=== RUN   TestDemo6
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">0</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">9</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">5</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">1</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">2</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">3</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">6</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">4</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">7</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">0</span>
--- <span class="hljs-attr">PASS:</span> TestDemo6 (<span class="hljs-number">2.00</span>s)
PASS</code></pre></div>

<h3 id="原子值（value）"><a href="#原子值（value）" class="headerlink" title="原子值（value）"></a>原子值（value）</h3><p>value是一个结构体，内部值定义为 interface{}，所以它是可以接受任何类型的值。</p>
<p>第一次赋值的时候，原子值的类型就确认了，后面不能赋值其它类型的值。</p>
<div class="code-wrapper"><pre><code class="hljs reasonml">func <span class="hljs-constructor">TestDemo7(<span class="hljs-params">t</span> <span class="hljs-operator">*</span><span class="hljs-params">testing</span>.T)</span> &#123;
	var value atomic.Value
	var counter uint64 = <span class="hljs-number">1</span>

	value.<span class="hljs-constructor">Store(<span class="hljs-params">counter</span>)</span>
	log.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;counter:&quot;</span>, <span class="hljs-params">value</span>.Load()</span>)

	value.<span class="hljs-constructor">Store(<span class="hljs-params">uint64</span>(10)</span>)
	log.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;counter:&quot;</span>, <span class="hljs-params">value</span>.Load()</span>)

	value.<span class="hljs-constructor">Store(100)</span> <span class="hljs-comment">// 引发 panic</span>
	log.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;counter:&quot;</span>, <span class="hljs-params">value</span>.Load()</span>)

	time.<span class="hljs-constructor">Sleep(2 <span class="hljs-operator">*</span> <span class="hljs-params">time</span>.Second)</span>
&#125;</code></pre></div>
<p>结果</p>
<div class="code-wrapper"><pre><code class="hljs awk">=== RUN   TestDemo7
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">10</span>:<span class="hljs-number">14</span>:<span class="hljs-number">58</span> counter: <span class="hljs-number">0</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">10</span>:<span class="hljs-number">14</span>:<span class="hljs-number">58</span> counter: <span class="hljs-number">10</span>
--- FAIL: TestDemo7 (<span class="hljs-number">0.00</span>s)
panic: sync/atomic: store of inconsistently typed value into Value [recovered]
	panic: sync/atomic: store of inconsistently typed value into Value
                ...
Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">1</span></code></pre></div>

<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="无锁编程"><a href="#无锁编程" class="headerlink" title="无锁编程"></a>无锁编程</h3><p><em>此处暂时先介绍一下，后面有机会出文章再一起学习进步。</em></p>
<p>放弃互斥锁，采用原子操作，常见方法有以下几种：</p>
<h4 id="针对计数器"><a href="#针对计数器" class="headerlink" title="针对计数器"></a>针对计数器</h4><p>可以使用例如上面介绍的 Add 方法。</p>
<h4 id="单生产、消费者"><a href="#单生产、消费者" class="headerlink" title="单生产、消费者"></a>单生产、消费者</h4><p>单生产者、单消费者可以做到免锁访问环形缓冲区（Ring Buffer）。<br>比如，Linux kernel 中的 kfifo 的实现。</p>
<h4 id="RCU（Read-Copy-Update）"><a href="#RCU（Read-Copy-Update）" class="headerlink" title="RCU（Read Copy Update）"></a>RCU（Read Copy Update）</h4><p>新旧副本切换机制，对于旧副本可以采用延迟释放的做法。</p>
<h4 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare And Swap）"></a>CAS（Compare And Swap）</h4><p>如无锁栈，无锁队列等待</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>原子操作性能是高于互斥锁的，但带来的复杂性也会提高，真正用好并不容易。</li>
<li>互斥锁、条件变量，方法内部的实现也都用到了原子操作，特别是CAS。</li>
</ol>
<p><a href="https://github.com/zuoshuwen/go-example/blob/master/e003/a01_test.go">文章示例代码</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>同步</tag>
        <tag>原子操作</tag>
      </tags>
  </entry>
  <entry>
    <title>Go并发编程之传统同步—(2)条件变量</title>
    <url>/golang/ipc-cond/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>回顾上篇文章 <a href="/golang/ipc-mutex/" title="Go并发编程之传统同步—(1)互斥锁">Go并发编程之传统同步—(1)互斥锁</a> 其中说到，同步最终是为了达到以下两种目的：</p>
<blockquote>
<ul>
<li><strong>维持共享数据一致性，并发安全</strong></li>
<li><strong>控制流程管理，更好的协同工作</strong></li>
</ul>
</blockquote>
<p>示例程序通过使用互斥锁，达到了数据一致性目的，那么流程管理应该怎么做呢？</p>
<a id="more"></a>

<h2 id="传统同步"><a href="#传统同步" class="headerlink" title="传统同步"></a>传统同步</h2><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>上篇文章的示例程序，仅仅实现了累加功能，但在现实的工作场景中，需求往往不可能这么简单，现在扩展一下这个程序，给它加上累减的功能。</p>
<p>加上了累减的示例程序，可以抽象的理解为一个固定容量的“储水池”，可以注水、排水。</p>
<h4 id="仅用互斥锁"><a href="#仅用互斥锁" class="headerlink" title="仅用互斥锁"></a>仅用互斥锁</h4><p>当水注满以后，停止注水，开始排水，当水排空以后，开始注水，反反复复…</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo1</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	<span class="hljs-keyword">var</span> mut sync.Mutex
	maxSize := <span class="hljs-number">10</span>
	counter := <span class="hljs-number">0</span>

	<span class="hljs-comment">// 排水口</span>
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		<span class="hljs-keyword">for</span> &#123;
			mut.Lock()
			<span class="hljs-keyword">if</span> counter == maxSize &#123;
				<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; maxSize; i++ &#123;
					counter--
					log.Printf(<span class="hljs-string">&quot;OUTPUT counter = %d&quot;</span>, counter)
				&#125;
			&#125;
			mut.Unlock()
			time.Sleep(<span class="hljs-number">1</span> * time.Second)
		&#125;
	&#125;()

	<span class="hljs-comment">// 注水口</span>
	<span class="hljs-keyword">for</span> &#123;
		mut.Lock()
		<span class="hljs-keyword">if</span> counter == <span class="hljs-number">0</span> &#123;
			<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; maxSize; i++ &#123;
				counter++
				log.Printf(<span class="hljs-string">&quot; INPUT counter = %d&quot;</span>, counter)
			&#125;
		&#125;
		mut.Unlock()
		time.Sleep(<span class="hljs-number">1</span> * time.Second)
	&#125;
&#125;</code></pre></div>
<p>结果</p>
<div class="code-wrapper"><pre><code class="hljs awk">=== RUN   TestDemo1
                ···
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">13</span>:<span class="hljs-number">52</span>:<span class="hljs-number">50</span>  INPUT counter = <span class="hljs-number">8</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">13</span>:<span class="hljs-number">52</span>:<span class="hljs-number">50</span>  INPUT counter = <span class="hljs-number">9</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">13</span>:<span class="hljs-number">52</span>:<span class="hljs-number">50</span>  INPUT counter = <span class="hljs-number">10</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">13</span>:<span class="hljs-number">52</span>:<span class="hljs-number">50</span> OUTPUT counter = <span class="hljs-number">9</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">13</span>:<span class="hljs-number">52</span>:<span class="hljs-number">50</span> OUTPUT counter = <span class="hljs-number">8</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">13</span>:<span class="hljs-number">52</span>:<span class="hljs-number">50</span> OUTPUT counter = <span class="hljs-number">7</span>
                ···</code></pre></div>
<p>看着没有什么问题，一切正常，但就是这样工作的策略效率太低。</p>
<h4 id="优化互斥锁"><a href="#优化互斥锁" class="headerlink" title="优化互斥锁"></a>优化互斥锁</h4><p>优化策略，不用等注满水再排水，也不用放空之后，再注水，注水口和排水口一起工作。</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo2</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	<span class="hljs-keyword">var</span> mut sync.Mutex
	maxSize := <span class="hljs-number">10</span>
	counter := <span class="hljs-number">0</span>

	<span class="hljs-comment">// 排水口</span>
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		<span class="hljs-keyword">for</span> &#123;
			mut.Lock()
			<span class="hljs-keyword">if</span> counter != <span class="hljs-number">0</span> &#123;
				counter--
			&#125;
			log.Printf(<span class="hljs-string">&quot;OUTPUT counter = %d&quot;</span>, counter)
			mut.Unlock()
			time.Sleep(<span class="hljs-number">5</span> * time.Second) <span class="hljs-comment">// 为了演示效果，睡眠5秒</span>
		&#125;
	&#125;()

	<span class="hljs-comment">// 注水口</span>
	<span class="hljs-keyword">for</span> &#123;
		mut.Lock()
		<span class="hljs-keyword">if</span> counter != maxSize &#123;
			counter++
		&#125;
		log.Printf(<span class="hljs-string">&quot; INPUT counter = %d&quot;</span>, counter)
		mut.Unlock()
		time.Sleep(<span class="hljs-number">1</span> * time.Second) <span class="hljs-comment">// 为了演示效果，睡眠1秒</span>
	&#125;
&#125;</code></pre></div>
<p>结果</p>
<div class="code-wrapper"><pre><code class="hljs awk">=== RUN   TestDemo2
                ···
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">46</span>  INPUT counter = <span class="hljs-number">7</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">47</span>  INPUT counter = <span class="hljs-number">8</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">48</span> OUTPUT counter = <span class="hljs-number">7</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">48</span>  INPUT counter = <span class="hljs-number">8</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">49</span>  INPUT counter = <span class="hljs-number">9</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">50</span>  INPUT counter = <span class="hljs-number">10</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">51</span>  INPUT counter = <span class="hljs-number">10</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">52</span>  INPUT counter = <span class="hljs-number">10</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">53</span> OUTPUT counter = <span class="hljs-number">9</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">53</span>  INPUT counter = <span class="hljs-number">10</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">54</span>  INPUT counter = <span class="hljs-number">10</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">55</span>  INPUT counter = <span class="hljs-number">10</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">56</span>  INPUT counter = <span class="hljs-number">10</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">57</span>  INPUT counter = <span class="hljs-number">10</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">58</span> OUTPUT counter = <span class="hljs-number">9</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">58</span>  INPUT counter = <span class="hljs-number">10</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">59</span>  INPUT counter = <span class="hljs-number">10</span>
                ···</code></pre></div>
<p>通过日志输出，可以看到程序达到了需求，运作正常。</p>
<p>但是，通过日志输出发现，当排水口效率低下的时候，注水口一直在轮询，这里频繁的上锁操作造成的开销很是浪费。</p>
<h4 id="条件变量：单发通知"><a href="#条件变量：单发通知" class="headerlink" title="条件变量：单发通知"></a>条件变量：单发通知</h4><p>那有没有什么好的办法，省去不必要的轮询？如果注水口和排水口能互相“通知”就好了！这个功能，<strong>条件变量</strong>可以做到。</p>
<p>条件变量总是与互斥锁组合使用，除了可以使用 Lock、Unlock，还有如下三个方法：</p>
<blockquote>
<ul>
<li>Wait 等待通知</li>
<li>Signal 单发通知</li>
<li>Broadcast 广播通知</li>
</ul>
</blockquote>
<div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-keyword">func</span> TestDemo3(t *testing.T) &#123;
	cond := sync.NewCond(new(sync.Mutex)) <span class="hljs-regexp">//</span> 初始化条件变量
	maxSize := <span class="hljs-number">10</span>
	counter := <span class="hljs-number">0</span>

	<span class="hljs-regexp">//</span> 排水口
	go <span class="hljs-keyword">func</span>() &#123;
		<span class="hljs-keyword">for</span> &#123;
			cond.L.Lock() <span class="hljs-regexp">//</span> 上锁
			<span class="hljs-keyword">if</span> counter == <span class="hljs-number">0</span> &#123; <span class="hljs-regexp">//</span> 没水了
				cond.Wait() <span class="hljs-regexp">//</span> 啥时候来水？等通知！
			&#125;
			counter--
			log.Printf(<span class="hljs-string">&quot;OUTPUT counter = %d&quot;</span>, counter)
			cond.Signal() <span class="hljs-regexp">//</span> 单发通知：已排水
			cond.L.Unlock() <span class="hljs-regexp">//</span> 解锁
			time.Sleep(<span class="hljs-number">5</span> * time.Second) <span class="hljs-regexp">//</span> 为了演示效果，睡眠<span class="hljs-number">5</span>秒
		&#125;
	&#125;()

	<span class="hljs-regexp">//</span> 注水口
	<span class="hljs-keyword">for</span> &#123;
		cond.L.Lock() <span class="hljs-regexp">//</span> 上锁
		<span class="hljs-keyword">if</span> counter == maxSize &#123; <span class="hljs-regexp">//</span> 水满了
			cond.Wait() <span class="hljs-regexp">//</span> 啥时候排水？等待通知！
		&#125;
		counter++
		log.Printf(<span class="hljs-string">&quot; INPUT counter = %d&quot;</span>, counter)
		cond.Signal() <span class="hljs-regexp">//</span> 单发通知：已来水
		cond.L.Unlock() <span class="hljs-regexp">//</span> 解锁
		time.Sleep(<span class="hljs-number">1</span> * time.Second) <span class="hljs-regexp">//</span> 为了演示效果，睡眠<span class="hljs-number">1</span>秒
	&#125;
&#125;</code></pre></div>
<p>结果</p>
<div class="code-wrapper"><pre><code class="hljs awk">=== RUN   TestDemo3
                ···
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">22</span>  INPUT counter = <span class="hljs-number">7</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">23</span>  INPUT counter = <span class="hljs-number">8</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">24</span> OUTPUT counter = <span class="hljs-number">7</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">24</span>  INPUT counter = <span class="hljs-number">8</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">25</span>  INPUT counter = <span class="hljs-number">9</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">26</span>  INPUT counter = <span class="hljs-number">10</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">29</span> OUTPUT counter = <span class="hljs-number">9</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">29</span>  INPUT counter = <span class="hljs-number">10</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">34</span> OUTPUT counter = <span class="hljs-number">9</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">34</span>  INPUT counter = <span class="hljs-number">10</span>
                ···</code></pre></div>
<p>通过日志输出，可以看出来，注水口没有一直轮询了，而是等到排水口发通知后，再进行注水，注水口一直再等排水口。那么新的问题又来了，如何提高排水口的效率呢？</p>
<h4 id="条件变量：广播通知"><a href="#条件变量：广播通知" class="headerlink" title="条件变量：广播通知"></a>条件变量：广播通知</h4><p>多制造出一个排水口，提高排水效率。</p>
<p>那就不能继续使用单发通知了（Signal），因为单发通知只会通知到一个等待（Wait），针对多等待的这种情况，就需要使用广播通知（Broadcast）。</p>
<div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-keyword">func</span> TestDemo4(t *testing.T) &#123;
	cond := sync.NewCond(new(sync.Mutex)) <span class="hljs-regexp">//</span> 初始化条件变量
	maxSize := <span class="hljs-number">10</span>
	counter := <span class="hljs-number">0</span>

	<span class="hljs-regexp">//</span> 排水口 <span class="hljs-number">1</span>
	go <span class="hljs-keyword">func</span>() &#123;
		<span class="hljs-keyword">for</span> &#123;
			cond.L.Lock() <span class="hljs-regexp">//</span> 上锁
			<span class="hljs-keyword">if</span> counter == <span class="hljs-number">0</span> &#123; <span class="hljs-regexp">//</span> 没水了
			<span class="hljs-regexp">//</span><span class="hljs-keyword">for</span> counter == <span class="hljs-number">0</span> &#123; <span class="hljs-regexp">//</span> 没水了
				cond.Wait() <span class="hljs-regexp">//</span> 啥时候来水？等通知！
			&#125;
			counter--
			log.Printf(<span class="hljs-string">&quot;OUTPUT A counter = %d&quot;</span>, counter)
			cond.Broadcast() <span class="hljs-regexp">//</span> 单发通知：已排水
			cond.L.Unlock() <span class="hljs-regexp">//</span> 解锁
			<span class="hljs-regexp">//</span>time.Sleep(<span class="hljs-number">2</span> * time.Second) <span class="hljs-regexp">//</span> 为了演示效果，睡眠<span class="hljs-number">5</span>秒
		&#125;
	&#125;()

	<span class="hljs-regexp">//</span> 排水口 <span class="hljs-number">2</span>
	go <span class="hljs-keyword">func</span>() &#123;
		<span class="hljs-keyword">for</span> &#123;
			cond.L.Lock() <span class="hljs-regexp">//</span> 上锁
			<span class="hljs-keyword">if</span> counter == <span class="hljs-number">0</span> &#123; <span class="hljs-regexp">//</span> 没水了
			<span class="hljs-regexp">//</span><span class="hljs-keyword">for</span> counter == <span class="hljs-number">0</span> &#123; <span class="hljs-regexp">//</span> 没水了
				cond.Wait() <span class="hljs-regexp">//</span> 啥时候来水？等通知！
			&#125;
			counter--
			log.Printf(<span class="hljs-string">&quot;OUTPUT B counter = %d&quot;</span>, counter)
			cond.Broadcast() <span class="hljs-regexp">//</span> 单发通知：已排水
			cond.L.Unlock() <span class="hljs-regexp">//</span> 解锁
			<span class="hljs-regexp">//</span>time.Sleep(<span class="hljs-number">2</span> * time.Second) <span class="hljs-regexp">//</span> 为了演示效果，睡眠<span class="hljs-number">5</span>秒
		&#125;
	&#125;()

	<span class="hljs-regexp">//</span> 注水口
	<span class="hljs-keyword">for</span> &#123;
		cond.L.Lock() <span class="hljs-regexp">//</span> 上锁
		<span class="hljs-keyword">if</span> counter == maxSize &#123; <span class="hljs-regexp">//</span> 水满了
		<span class="hljs-regexp">//</span><span class="hljs-keyword">for</span> counter == maxSize &#123; <span class="hljs-regexp">//</span> 水满了
			cond.Wait() <span class="hljs-regexp">//</span> 啥时候排水？等待通知！
		&#125;
		counter++
		log.Printf(<span class="hljs-string">&quot; INPUT   counter = %d&quot;</span>, counter)
		cond.Broadcast() <span class="hljs-regexp">//</span> 单发通知：已来水
		cond.L.Unlock() <span class="hljs-regexp">//</span> 解锁
		<span class="hljs-regexp">//</span>time.Sleep(<span class="hljs-number">1</span> * time.Second) <span class="hljs-regexp">//</span> 为了演示效果，睡眠<span class="hljs-number">1</span>秒
	&#125;
&#125;</code></pre></div>
<p>结果</p>
<div class="code-wrapper"><pre><code class="hljs awk">=== RUN   TestDemo4
                ···
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">30</span> OUTPUT B counter = <span class="hljs-number">2</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">30</span> OUTPUT B counter = <span class="hljs-number">1</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">30</span> OUTPUT B counter = <span class="hljs-number">0</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">30</span> OUTPUT A counter = -<span class="hljs-number">1</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">30</span> OUTPUT A counter = -<span class="hljs-number">2</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">30</span> OUTPUT A counter = -<span class="hljs-number">3</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">30</span> OUTPUT A counter = -<span class="hljs-number">4</span>
                ···
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">31</span> OUTPUT B counter = -<span class="hljs-number">7605</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">31</span>  INPUT   counter = -<span class="hljs-number">7604</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">31</span> OUTPUT A counter = -<span class="hljs-number">7605</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">31</span> OUTPUT A counter = -<span class="hljs-number">7606</span>
                ···</code></pre></div>
<p>通过日志输出可以看到，刚开始的时候还很正常，到后面的时候就变成负值了，一直在负增长，What？</p>
<p>在 <a href="/golang/ipc-mutex/" title="Go并发编程之传统同步—(1)互斥锁">Go并发编程之传统同步—(1)互斥锁</a> 文章中，程序因为没有加上互斥锁，出现过 counter 值异常的情况。</p>
<p>但这次程序这次加了互斥锁，按理说形成了一个临界区应该是没有问题了，所以问题应该不是出在临界区上，难道问题出在 <strong>Wait</strong> 上？</p>
<p>通过IDE<strong>追踪一下Wait的源码</strong></p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span> <span class="hljs-title">Wait</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-comment">// 检查 c 是否是被复制的，如果是就 panic</span>
	c.checker.check()
	<span class="hljs-comment">// 将当前 goroutine 加入等待队列</span>
	t := runtime_notifyListAdd(&amp;c.notify)
	c.L.Unlock()
	<span class="hljs-comment">// 等待当前 goroutine 被唤醒</span>
	runtime_notifyListWait(&amp;c.notify, t)
	c.L.Lock()
&#125;</code></pre></div>
<p>原来 Wait 内部的执行流程是，先执行了解锁，然后进入等待状态，接到通知之后，再执行加锁操作。</p>
<p>那按照这个代码逻辑结合输出日志，走一程序遍流程，看看能不能复现出 counter 为负值的情况：</p>
<blockquote>
<ol>
<li><p>注水口将 counter 累加到 10 之后，发送广播通知（Broadcast）。</p>
</li>
<li><p>goroutine A 在“第1步”之前的时候进入了等待通知（Wait），现在接收到了广播通知（Broadcast），从 runtime_notifyListWait() 返回，并且成功执行了加锁（Lock）操作。</p>
</li>
<li><p>goroutine B 在“第1步”之前的时候进入了等待通知（Wait），现在接收到了广播通知（Broadcast），从 runtime_notifyListWait() 返回，在执行加锁（Lock）操作的时候，发现 goroutine A 先抢占了临界区，所以一直阻塞在 c.L.Lock()。</p>
</li>
<li><p>goroutine A 虽然完成任务后会释放锁，但是每次也成功将锁抢占，所以就这样 一直将 counter 减到了 0，然后发送广播通知（Broadcast）、解锁（Unlock）。</p>
</li>
<li><p>goroutine B 在 goroutine A 解锁后，成功获得锁并从 Lock 方法中返回，接下来跳出 Wait 方法、跳出 if 判断，执行 counter–（0–），这时候 counter 的值是 -1</p>
</li>
</ol>
</blockquote>
<p>图示</p>
<p><img src="/images/golang/ipc-cond-01.jpg" alt="ipc-cond-01"></p>
<p>问题就出现在第五步，只要 goroutine B 加锁成功的时候，再判断一下 counter 是否为 0 就好了。</p>
<p>所以将 if counter == 0 改成 for counter == 0，这样上面的“第五步”就变成了</p>
<blockquote>
<p>5.goroutine B 在 goroutine A 解锁后，成功加锁（Lock）并从阻塞总返回，接下来跳出 Wait 方法、再次进入 for 循环，判断 counter == 0 结果为真，再次进入等待（Wait）。</p>
</blockquote>
<p>代码做出相应的修改后，再执行看结果，没有问题了。</p>
<h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><h3 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h3><p>等待通知（Wait）肯定是要在临界区里面的，那发送通知（Signal、Broadcast）在哪里更好呢？</p>
<div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Luck</span><span class="hljs-params">()</span></span>
<span class="hljs-function"><span class="hljs-title">Wait</span><span class="hljs-params">()</span></span>
<span class="hljs-function"><span class="hljs-title">Broadcast</span><span class="hljs-params">()</span></span><span class="hljs-comment">// Signal()</span>
<span class="hljs-function"><span class="hljs-title">Unlock</span><span class="hljs-params">()</span></span>

<span class="hljs-comment">// 或者</span>

<span class="hljs-function"><span class="hljs-title">Luck</span><span class="hljs-params">()</span></span>
<span class="hljs-function"><span class="hljs-title">Wait</span><span class="hljs-params">()</span></span>
<span class="hljs-function"><span class="hljs-title">Unlock</span><span class="hljs-params">()</span></span>
<span class="hljs-function"><span class="hljs-title">Broadcast</span><span class="hljs-params">()</span></span><span class="hljs-comment">// Signal()</span>

<span class="hljs-comment">// 两种写法都不会报错 </span></code></pre></div>
<p>在 go 的发送通知方法（Broadcast、Signal）上有这么一段话：</p>
<blockquote>
<p>// It is allowed but not required for the caller to hold c.L<br>// during the call.</p>
</blockquote>
<p>在我以往的 C 多线程开发的时候，发送通知总是在锁中的：</p>
<div class="code-wrapper"><pre><code class="hljs reasonml">pthread<span class="hljs-constructor">_mutex_lock(&amp;<span class="hljs-params">thread</span>-&gt;<span class="hljs-params">mutex</span>)</span>;
<span class="hljs-comment">//              ...</span>
pthread<span class="hljs-constructor">_cond_signal(&amp;<span class="hljs-params">thread</span>-&gt;<span class="hljs-params">cond</span>)</span>;
pthread<span class="hljs-constructor">_mutex_unlock(&amp;<span class="hljs-params">thread</span>-&gt;<span class="hljs-params">mutex</span>)</span>;</code></pre></div>
<p>在 <a href="https://linux.die.net/man/3/pthread_cond_signal">man</a> 手册中有写到：</p>
<blockquote>
<p>The pthread_cond_broadcast() or pthread_cond_signal() functions may be called by a thread whether or not it currently owns the mutex that threads calling pthread_cond_wait() or pthread_cond_timedwait() have associated with the condition variable during their waits; however, if predictable scheduling behavior is required, then that mutex shall be locked by the thread calling pthread_cond_broadcast() or pthread_cond_signal().</p>
</blockquote>
<p>个人对此并没有什么见解，就不乱下定论了，有想法的小伙伴可以在文章下面留言，一起讨论。</p>
<h3 id="等待通知"><a href="#等待通知" class="headerlink" title="等待通知"></a>等待通知</h3><p>消息通知是有即时性的，如果没有 goroutine 在等待通知，那么这次通知直接被丢弃。</p>
<h3 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h3><p><a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/fifo.go">https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/fifo.go</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Wait() 内会执行解锁、等待、加锁。</li>
<li>Wait() 必须在 for 循环里面。</li>
<li>Wait() 方法会把当前的 goroutine 添加到通知队列的队尾。</li>
<li>单发通知，唤醒通知队列第一个排队的 goroutine。</li>
<li>广播通知，唤醒通知队列里面全部的 goroutine。</li>
<li>程序示例只是为了演示效果，实际的开发中，生产者和消费者应该是异步消费，不应该使用同一个互斥锁。</li>
</ol>
<p><a href="https://github.com/zuoshuwen/go-example/blob/master/e002/a01_test.go">文章示例代码</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>同步</tag>
        <tag>条件变量</tag>
      </tags>
  </entry>
  <entry>
    <title>Go并发编程之传统同步—(1)互斥锁</title>
    <url>/golang/ipc-mutex/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先回顾一下，在 C 或者其它编程语言的并发编程中，主要存在两种<strong>通信</strong>（IPC）：</p>
<blockquote>
<ul>
<li><strong>进程间通信</strong>：管道、消息队列、信号等</li>
<li><strong>线程间通信</strong>：互斥锁、条件变量等</li>
</ul>
</blockquote>
<p>利用以上通信手段采取的同步措施，最终是为了达到以下两种目的：</p>
<blockquote>
<ul>
<li><strong>维持共享数据一致性，并发安全</strong></li>
<li><strong>控制流程管理，更好的协同工作</strong></li>
</ul>
</blockquote>
<p>Go语言中除了保留了传统的同步支持，还提供了特有的 CSP 并发编程模型。</p>
<span id="more"></span>

<h2 id="传统同步"><a href="#传统同步" class="headerlink" title="传统同步"></a>传统同步</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>接下来通过一个“做累加”的示例程序，展示<strong>竞争状态</strong>（race condition）。</p>
<h4 id="不加锁"><a href="#不加锁" class="headerlink" title="不加锁"></a>不加锁</h4><p>开启 5000 个 goroutine，让每个 goroutine 给 counter 加 1，最终在所有 goroutine 都完成任务时 counter 的值应该为 5000，先试下不加锁的示例程序表现如何</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo1</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	counter := <span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ &#123;
		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
			counter++
		&#125;()
	&#125;
	time.Sleep(<span class="hljs-number">1</span> * time.Second)
	t.Logf(<span class="hljs-string">&quot;counter = %d&quot;</span>, counter)
&#125;</code></pre></div>
<p>结果</p>
<div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">=== RUN   TestDemo1</span>
<span class="hljs-code">    a1_test.go:18: counter = 4663</span>
<span class="hljs-bullet">--- </span>PASS: TestDemo1 (1.00s)
PASS</code></pre></div>
<p>多试几次，结果一直是小于 5000 的不定值。<br>竞争状态下程序行为的图像表示<br><img src="/images/golang/ipc-mutex-01.jpg" alt="ipc-mutex-01"></p>
<h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>将刚刚的代码稍作改动</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo2</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	<span class="hljs-keyword">var</span> mut sync.Mutex <span class="hljs-comment">// 声明锁</span>
	counter := <span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ &#123;
		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
			mut.Lock() <span class="hljs-comment">// 加锁</span>
			counter++
			mut.Unlock() <span class="hljs-comment">// 解锁</span>
		&#125;()
	&#125;
	time.Sleep(<span class="hljs-number">1</span> * time.Second)
	t.Logf(<span class="hljs-string">&quot;counter = %d&quot;</span>, counter)
&#125;</code></pre></div>
<p>结果</p>
<div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">=== RUN   TestDemo2</span>
<span class="hljs-code">    a1_test.go:35: counter = 5000</span>
<span class="hljs-bullet">--- </span>PASS: TestDemo2 (1.01s)
PASS</code></pre></div>
<p>counter = 5000，返回的结果对了。</p>
<p>这就是<strong>互斥锁</strong>，在代码上创建一个<strong>临界区</strong>（critical section），保证串行操作（同一时间只有一个 goroutine 执行临界区代码）。</p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>那么互斥锁是怎么串行的呢？把每一步的执行过程打印出来看下</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo3</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	<span class="hljs-keyword">var</span> mut sync.Mutex
	counter := <span class="hljs-number">0</span>
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		mut.Lock()
		log.Println(<span class="hljs-string">&quot;goroutine B Lock&quot;</span>)
		counter = <span class="hljs-number">1</span>
		log.Println(<span class="hljs-string">&quot;goroutine B counter =&quot;</span>, counter)
		time.Sleep(<span class="hljs-number">5</span> * time.Second)
		mut.Unlock()
		log.Println(<span class="hljs-string">&quot;goroutine B Unlock&quot;</span>)
	&#125;()
	time.Sleep(<span class="hljs-number">1</span> * time.Second)
	mut.Lock()
	log.Println(<span class="hljs-string">&quot;goroutine A Lock&quot;</span>)
	counter = <span class="hljs-number">2</span>
	log.Println(<span class="hljs-string">&quot;goroutine A counter =&quot;</span>, counter)
	mut.Unlock()
	log.Println(<span class="hljs-string">&quot;goroutine A Unlock&quot;</span>)
&#125;</code></pre></div>
<p>结果</p>
<div class="code-wrapper"><pre><code class="hljs awk">=== RUN   TestDemo3
<span class="hljs-number">2020</span><span class="hljs-regexp">/09/</span><span class="hljs-number">30</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span>:<span class="hljs-number">00</span> goroutine B Lock
<span class="hljs-number">2020</span><span class="hljs-regexp">/09/</span><span class="hljs-number">30</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span>:<span class="hljs-number">00</span> goroutine B counter = <span class="hljs-number">1</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/09/</span><span class="hljs-number">30</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span>:<span class="hljs-number">05</span> goroutine B Unlock
<span class="hljs-number">2020</span><span class="hljs-regexp">/09/</span><span class="hljs-number">30</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span>:<span class="hljs-number">05</span> goroutine A Lock
<span class="hljs-number">2020</span><span class="hljs-regexp">/09/</span><span class="hljs-number">30</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span>:<span class="hljs-number">05</span> goroutine A counter = <span class="hljs-number">2</span>
<span class="hljs-number">2020</span><span class="hljs-regexp">/09/</span><span class="hljs-number">30</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span>:<span class="hljs-number">05</span> goroutine A Unlock
--- PASS: TestDemo3 (<span class="hljs-number">5.00</span>s)
PASS</code></pre></div>
<p>通过每个操作记录下来的时间可以看出，goroutine A 的 Lock 一直阻塞到了 goroutine B 的 Unlock。<br><img src="/images/golang/ipc-mutex-02.jpg" alt="ipc-mutex-01"></p>
<h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>这时候有个疑问，那 goroutine B 上的锁，goroutine A 能解锁吗？修改一下刚才的代码，试一下</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo5</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	<span class="hljs-keyword">var</span> mut sync.Mutex
	counter := <span class="hljs-number">0</span>
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		mut.Lock()
		log.Println(<span class="hljs-string">&quot;goroutine B Lock&quot;</span>)
		counter = <span class="hljs-number">1</span>
		log.Println(<span class="hljs-string">&quot;goroutine B counter =&quot;</span>, counter)
		time.Sleep(<span class="hljs-number">5</span> * time.Second)
		<span class="hljs-comment">//mut.Unlock()</span>
		<span class="hljs-comment">//log.Println(&quot;goroutine B Unlock&quot;)</span>
	&#125;()
	time.Sleep(<span class="hljs-number">1</span> * time.Second)
	mut.Unlock()
	log.Println(<span class="hljs-string">&quot;goroutine A Unlock&quot;</span>)
	counter = <span class="hljs-number">2</span>
	log.Println(<span class="hljs-string">&quot;goroutine A counter =&quot;</span>, counter)
	time.Sleep(<span class="hljs-number">2</span> * time.Second)
&#125;</code></pre></div>
<p>结果</p>
<div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">=== RUN   TestDemo5</span>
2020/09/30 22:15:03 goroutine B Lock
2020/09/30 22:15:03 goroutine B counter = 1
2020/09/30 22:15:04 goroutine A Unlock
2020/09/30 22:15:04 goroutine A counter = 2
<span class="hljs-bullet">--- </span>PASS: TestDemo5 (3.01s)
PASS</code></pre></div>
<p>测试通过，未报错，counter 的值也被成功修改，证明B上的锁，是可以被A解开的。</p>
<p>再进一步，goroutine A 不解锁，直接修改已经被 goroutine B 锁住的 counter 的值可以吗？试一下</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo6</span><span class="hljs-params">(t *testing.T)</span></span> &#123;
	<span class="hljs-keyword">var</span> mut sync.Mutex
	counter := <span class="hljs-number">0</span>
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		mut.Lock()
		log.Println(<span class="hljs-string">&quot;goroutine B Lock&quot;</span>)
		counter = <span class="hljs-number">1</span>
		log.Println(<span class="hljs-string">&quot;goroutine B counter =&quot;</span>, counter)
		time.Sleep(<span class="hljs-number">5</span> * time.Second)
		mut.Unlock()
		log.Println(<span class="hljs-string">&quot;goroutine B Unlock&quot;</span>)
	&#125;()
	time.Sleep(<span class="hljs-number">1</span> * time.Second)
	<span class="hljs-comment">//log.Println(&quot;goroutine A Unlock&quot;)</span>
	<span class="hljs-comment">//mut.Unlock()</span>
	counter = <span class="hljs-number">2</span>
	log.Println(<span class="hljs-string">&quot;goroutine A counter =&quot;</span>, counter)
	time.Sleep(<span class="hljs-number">10</span> * time.Second)
&#125;</code></pre></div>
<p>结果</p>
<div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">=== RUN   TestDemo6</span>
2020/09/30 22:15:43 goroutine B Lock
2020/09/30 22:15:43 goroutine B counter = 1
2020/09/30 22:15:44 goroutine A counter = 2
2020/09/30 22:15:48 goroutine B Unlock
<span class="hljs-bullet">--- </span>PASS: TestDemo6 (11.00s)
PASS</code></pre></div>
<p>测试通过，未报错，证明B上的锁，A可以不用解锁直接改。</p>
<h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id="锁的两种通常处理方式"><a href="#锁的两种通常处理方式" class="headerlink" title="锁的两种通常处理方式"></a>锁的两种通常处理方式</h3><ul>
<li>一种是没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁叫做<strong>自旋锁</strong>，它不用将线程阻塞起来(NON-BLOCKING)；</li>
<li>还有一种处理方式就是把自己阻塞起来，等待重新调度请求，这种叫做互斥锁。</li>
</ul>
<h3 id="饥饿模式"><a href="#饥饿模式" class="headerlink" title="饥饿模式"></a>饥饿模式</h3><p>当互斥锁不断地试图获得一个永远无法获得的锁时，它可能会遇到饥饿问题。<br>在版本1.9中，Go通过添加一个新的饥饿模式来解决先前的问题，所有等待锁定超过一毫秒的 goroutine，也称为有界等待，将被标记为饥饿。当标记为饥饿时，解锁方法现在将把锁直接移交给第一位等待着。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁和上面的多也差不多，有这么几种情况</p>
<ul>
<li>在写锁已被锁定的情况下试图锁定写锁，会阻塞当前的 goroutine。</li>
<li>在写锁已被锁定的情况下试图锁定读锁，会阻塞当前的 goroutine。</li>
<li>在读锁已被锁定的情况下试图锁定写锁，会阻塞当前的 goroutine。</li>
<li>在读锁已被锁定的情况下试图锁定读锁，不会阻塞当前的 goroutine。</li>
</ul>
<h3 id="panic错误"><a href="#panic错误" class="headerlink" title="panic错误"></a>panic错误</h3><p>无论是互斥锁还是读写锁在程序运行时一定是成对的，不然就会引发不可恢复的panic。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>锁一定要用对地方，特别是要注意Lock产生的阻塞对性能的影响。</li>
<li>在各种程序的逻辑分支下，都要确保锁的成对出现。</li>
<li>读写锁是对互斥锁的一个扩展，提高了程序的可读性。</li>
<li>临界区是需要每个 goroutine 主动遵守的，说白了就是每个 goroutine 的代码都存在 Lock。</li>
</ol>
<p><a href="https://github.com/zuoshuwen/go-example/blob/master/e001/a01_test.go">文章示例代码</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>同步</tag>
        <tag>互斥锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Redash Gunicorn 超时</title>
    <url>/gunicorn/timeout/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近总有用户反馈说Redash下载比较大的Excel就会出现“失败 - 服务器出现问题”，而且每次从点了下载到出现错误提示时间都是差不多的。我先查看了Nginx的error日志，显示 <code>upstream prematurely closed connection while sending to client</code>，第一反应应该是超时导致的。</p>
<a id="more"></a>

<h2 id="1-修改Redash配置"><a href="#1-修改Redash配置" class="headerlink" title="1. 修改Redash配置"></a>1. 修改Redash配置</h2><ul>
<li>.env文件修改log级别为调试 <code>REDASH_LOG_LEVEL=&quot;DEBUG&quot;</code></li>
<li>.env文件加上超时配置 <code>REDASH_BIGQUERY_HTTP_TIMEOUT=600</code></li>
<li>Redash的启动命令后面增加 <code>-t 600</code> 参数。<br>10分钟应该够用了！重启redash进程后，进行尝试试，不好使！好吧，也许是配置参数写错了，那改成 <code>--timeout 600</code> 再试一下，发现还不好使！继续。。。</li>
</ul>
<h2 id="2-修改Nginx配置"><a href="#2-修改Nginx配置" class="headerlink" title="2. 修改Nginx配置"></a>2. 修改Nginx配置</h2><ul>
<li>请求超时：keepalive_timeout、client_header_timeout、client_body_timeout</li>
<li>后端服务器处理请求的时间设置：proxy_connect_timeout、proxy_read_timeout<br>重启Nginx，下载还是失败！！！看来不是超时导致的了？！</li>
</ul>
<h2 id="3-查看进程使用的资源"><a href="#3-查看进程使用的资源" class="headerlink" title="3. 查看进程使用的资源"></a>3. 查看进程使用的资源</h2><p>先执行：<br><code>top</code><br>再尝试下载操作，发现名叫<code>gunicorn</code>（Redash的server是用gunicorn启动的）的<code>COMMAND</code>CPU占用CPU到了100%，并且持续一定时间后，进程消失，新的进程启动后，CPU占用恢复正常值。那接下来就看看此进程都执行了哪些操作。</p>
<h2 id="4-进程跟踪"><a href="#4-进程跟踪" class="headerlink" title="4. 进程跟踪"></a>4. 进程跟踪</h2><p>跟踪CPU占用超高的 <code>gunicorn</code> 进程：</p>
<div class="code-wrapper"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> strace -T -tt -e trace=<span class="hljs-keyword">all</span> -p 进程ID</code></pre></div>
<p>显式进程一直在 <code>read</code>、<code>write</code> 的系统调用，最后一行输出<br><code>+++ killed by SIGKILL +++</code><br>后，跟踪就停止了。难道是触发了系统的<code>ulimit</code>限制，然后被系统杀掉了？</p>
<h2 id="5-设置ulimit参数"><a href="#5-设置ulimit参数" class="headerlink" title="5. 设置ulimit参数"></a>5. 设置ulimit参数</h2><p>设置 <code>gunicorn</code> 运行用户的 <code>ulimit</code>，重新尝试，没有解决。看来也不是这个问题。。。那是被谁 <code>kill</code> 掉的呢？</p>
<h2 id="6-捕捉kill信号"><a href="#6-捕捉kill信号" class="headerlink" title="6. 捕捉kill信号"></a>6. 捕捉kill信号</h2><p>使用 <code>auditctl</code>，添加捕捉规则：</p>
<div class="code-wrapper"><pre><code class="hljs awk">$ auditctl -a <span class="hljs-keyword">exit</span>,always -F arch=b64 -S kill -F a1=<span class="hljs-number">9</span></code></pre></div>
<p>进行下载文件操作，等待进程被杀死之后，显式捕捉到结果：</p>
<div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> ausearch <span class="hljs-literal">-sc</span> <span class="hljs-built_in">kill</span></code></pre></div>
<p>输出：</p>
<div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">time</span>-&gt;Fri Dec  <span class="hljs-number">6</span> <span class="hljs-number">16</span>:<span class="hljs-number">13</span>:<span class="hljs-number">26</span> <span class="hljs-number">2019</span>
<span class="hljs-attribute">type</span>=PROCTITLE msg=audit(<span class="hljs-number">1575620006</span>.<span class="hljs-number">444</span>:<span class="hljs-number">103711</span>): proctitle=<span class="hljs-number">2</span>F<span class="hljs-number">6</span>F<span class="hljs-number">70742</span>F<span class="hljs-number">6</span>D<span class="hljs-number">6</span>F<span class="hljs-number">64756</span>C<span class="hljs-number">65732</span>F<span class="hljs-number">7265646173682</span>D<span class="hljs-number">372</span>E<span class="hljs-number">302</span>E<span class="hljs-number">302</span>F<span class="hljs-number">7265646173682</span>F<span class="hljs-number">62696</span>E<span class="hljs-number">2</span>F<span class="hljs-number">707974686</span>F<span class="hljs-number">6</span>E<span class="hljs-number">322</span>E<span class="hljs-number">37002</span>F<span class="hljs-number">6</span>F<span class="hljs-number">70742</span>F<span class="hljs-number">7265646173682</span>F<span class="hljs-number">7265646173682</span>F<span class="hljs-number">62696</span>E<span class="hljs-number">2</span>F<span class="hljs-number">67756</span>E<span class="hljs-number">69636</span>F<span class="hljs-number">726</span>E<span class="hljs-number">002</span>D<span class="hljs-number">62003132372</span>E<span class="hljs-number">302</span>E<span class="hljs-number">302</span>E<span class="hljs-number">313</span>A<span class="hljs-number">35303030002</span>D<span class="hljs-number">2</span>D<span class="hljs-number">6</span>E<span class="hljs-number">616</span>D<span class="hljs-number">6500726564617368002</span>D<span class="hljs-number">770034002</span>D<span class="hljs-number">2</span>D<span class="hljs-number">6</span>D<span class="hljs-number">61782</span>D<span class="hljs-number">726571756573</span>
<span class="hljs-attribute">type</span>=OBJ_PID msg=audit(<span class="hljs-number">1575620006</span>.<span class="hljs-number">444</span>:<span class="hljs-number">103711</span>): opid=<span class="hljs-number">11646</span> oauid=<span class="hljs-number">0</span> ouid=<span class="hljs-number">1001</span> oses=<span class="hljs-number">14406</span> ocomm=<span class="hljs-string">&quot;gunicorn&quot;</span>
<span class="hljs-attribute">type</span>=SYSCALL msg=audit(<span class="hljs-number">1575620006</span>.<span class="hljs-number">444</span>:<span class="hljs-number">103711</span>): arch=c<span class="hljs-number">000003</span>e syscall=<span class="hljs-number">62</span> success=yes exit=<span class="hljs-number">0</span> a<span class="hljs-number">0</span>=<span class="hljs-number">2</span>d<span class="hljs-number">7</span>e a<span class="hljs-number">1</span>=<span class="hljs-number">9</span> a<span class="hljs-number">2</span>=<span class="hljs-number">0</span> a<span class="hljs-number">3</span>=<span class="hljs-number">0</span> items=<span class="hljs-number">0</span> ppid=<span class="hljs-number">11490</span> pid=<span class="hljs-number">11494</span> auid=<span class="hljs-number">0</span> uid=<span class="hljs-number">1001</span> gid=<span class="hljs-number">1001</span> euid=<span class="hljs-number">1001</span> suid=<span class="hljs-number">1001</span> fsuid=<span class="hljs-number">1001</span> egid=<span class="hljs-number">1001</span> sgid=<span class="hljs-number">1001</span> fsgid=<span class="hljs-number">1001</span> tty=(none) ses=<span class="hljs-number">14406</span> comm=<span class="hljs-string">&quot;gunicorn&quot;</span> exe=<span class="hljs-string">&quot;/opt/modules/redash-7.0.0/redash/bin/python2.7&quot;</span> key=(null)</code></pre></div>
<p>原来是被父进程搞死了。。。</p>
<h2 id="7-查看gunicorn日志"><a href="#7-查看gunicorn日志" class="headerlink" title="7. 查看gunicorn日志"></a>7. 查看gunicorn日志</h2><p>进入supervisord控制台，通过<code>tail -f </code> 打印 <code>gunicorn</code>进程的输出。</p>
<div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-attr">[CRITICAL]</span> <span class="hljs-selector-tag">WORKER</span> <span class="hljs-selector-tag">TIMEOUT</span> (<span class="hljs-attribute">pid</span>:<span class="hljs-number">15577</span>)
<span class="hljs-selector-attr">[INFO]</span> <span class="hljs-selector-tag">Worker</span> <span class="hljs-selector-tag">exiting</span> (<span class="hljs-attribute">pid</span>: <span class="hljs-number">15577</span>)
<span class="hljs-selector-attr">[INFO]</span> <span class="hljs-selector-tag">Booting</span> <span class="hljs-selector-tag">worker</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">pid</span>: <span class="hljs-selector-tag">15646</span></code></pre></div>
<p><code>timeout</code>…原因就是最开始猜测的超时问题。</p>
<p><code>gunicorn</code> 给子进程的执行时间就有30秒，如果超过这个限制就会被父进程kill。可是timeout的超时配置并不生效。。。</p>
<h2 id="8-最终解决方案"><a href="#8-最终解决方案" class="headerlink" title="8.最终解决方案"></a>8.最终解决方案</h2><p><code>Gunicorn</code> 运行命令增加 <code>-k gevent</code> 配置</p>
<p><code>Gunicorn</code> 是 <code>pre-fork</code> 模型，<code>worker</code> 默认是 <code>sync</code> 改为 <code>gevent</code></p>
]]></content>
      <categories>
        <category>gunicorn</category>
      </categories>
      <tags>
        <tag>gunicorn</tag>
        <tag>timeout</tag>
        <tag>redash</tag>
      </tags>
  </entry>
  <entry>
    <title>GoMPG与调度</title>
    <url>/golang/scheduling/</url>
    <content><![CDATA[<h1 id="MPG"><a href="#MPG" class="headerlink" title="MPG"></a>MPG</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开始学习 Go 特性的并发编程之前，先来简单了解一些基础概念，这对理解学习 Go 并发模型会有一些帮助。</p>
<span id="more"></span>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h3><p>也被称为内核空间，是系统内核的运行空间，与用户空间隔离。控制计算机的硬件资源。</p>
<h3 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h3><p>也被称为用户空间，代码运行在较低的特权级别上，不能直接访问内核空间和硬件设备。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>用户空间不能直接调用系统资源，必须通过调用系统接口，由内核完成相关指令。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是操作系统分配资源的最小单元。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>有时也被称为轻量级进程（LWP），是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。</p>
<h3 id="KSE"><a href="#KSE" class="headerlink" title="KSE"></a>KSE</h3><p>理论上说 Linux 内核是没有线程这个概念的，只有内核调度实体（Kernal Scheduling Entry）这个概念。</p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>有时也被称为微线程（Coroutine），只不过这个线程是用户态的，不需要操作系统参与。</p>
<p>调度过程示例：</p>
<ol>
<li>coroutine A 进行 网络I/O，使用 write() 发送数据后调用 read() 等待数据的返回，但是不一定什么时候能够读到数据，所以将 Socket Fd 放入 EventLoop 中。</li>
<li>coroutine A 让出 CPU 给 其它 coroutine 使用 —— <strong>挂起（yield）</strong></li>
<li>待 read() 有返回数据后，继续执行 coroutine A  —— <strong>恢复（resume）</strong></li>
</ol>
<p><em>EventLoop：无限循环着的事件分发器，一旦有事件发生，它就会回调预先定义好的回调函数，完成事件的处理。</em></p>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p><strong>M:1</strong> 多个用户空间的线程，对应一个内核空间的 KSE。</p>
<h4 id="系统级线程"><a href="#系统级线程" class="headerlink" title="系统级线程"></a>系统级线程</h4><p><strong>1:1</strong> 1个用户空间的线程，对应1个内核空间的 KSE。</p>
<h4 id="两级线程模型（混合式线程模型）"><a href="#两级线程模型（混合式线程模型）" class="headerlink" title="两级线程模型（混合式线程模型）"></a>两级线程模型（混合式线程模型）</h4><p><strong>M:N</strong> 多个用户空间的线程，对应多个内核空间的 KSE。</p>
<h3 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h3><p>并发模型指定了系统中的线程如何通过协作来完成分配给它们的作业。不同的并发模型采用不同的方式拆分作业，同时线程间的协作和交互方式也不相同。</p>
<p>常见的有：</p>
<ul>
<li>线程&amp;锁</li>
<li>Actor</li>
<li>CSP</li>
<li>Lambda 架构</li>
</ul>
<h3 id="并发模型—CSP"><a href="#并发模型—CSP" class="headerlink" title="并发模型—CSP"></a>并发模型—CSP</h3><p>Communicating Sequential Processes 通信顺序进程。</p>
<p>看这个名字就能知道，在CSP模型中主角是<strong>通信</strong>。</p>
<blockquote>
<p>channel：进行通信的并发模型。<br>worker：channel 两端的发送者/接收者。</p>
</blockquote>
<p>worker 之间不直接彼此联系，而是通过 channel 进行消息发送和接收。</p>
<p>在并发模型中，经常和 CSP 一起讨论的是 Actor 模型。</p>
<h3 id="GO-线程模型"><a href="#GO-线程模型" class="headerlink" title="GO 线程模型"></a>GO 线程模型</h3><p>Go 参考了<strong>两级线程模型</strong>，设计出了 MPG 线程模型。</p>
<h4 id="M"><a href="#M" class="headerlink" title="M"></a>M</h4><p>machine</p>
<p>用户空间内的线程，与 KSE 一一对应，可以理解为 M 代表了 内核线程。</p>
<h4 id="P"><a href="#P" class="headerlink" title="P"></a>P</h4><p>processor</p>
<p>可以理解为用户代码逻辑的处理器，Go 代码片段所必需的上下文环境。</p>
<h4 id="G"><a href="#G" class="headerlink" title="G"></a>G</h4><p>goroutine</p>
<p>Go 代码片段的封装。</p>
<div class="code-wrapper"><pre><code class="hljs actionscript">go <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span>&#123;
<span class="hljs-comment">//  ...</span>
&#125;()</code></pre></div>


<h3 id="GO并发模型"><a href="#GO并发模型" class="headerlink" title="GO并发模型"></a>GO并发模型</h3><h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><p>参考了 <strong>CSP并发模型</strong>。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="goroutine-与-coroutine-的区别"><a href="#goroutine-与-coroutine-的区别" class="headerlink" title="goroutine 与 coroutine 的区别"></a>goroutine 与 coroutine 的区别</h3><h4 id="coroutine"><a href="#coroutine" class="headerlink" title="coroutine"></a>coroutine</h4><p>运行机制属于协作式任务处理，始终顺序执行。</p>
<h4 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h4><p>运行机制属于抢占式任务处理，可能发生并行执行。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Go 的并发模型参考了 CSP并发模型，采用 channel 进行通信。</li>
<li>Go 的线程模型参考了两级线程模型，设计出了 MPG 模型。</li>
<li>goroutine 与 coroutine 的区别就是前者可能发生并行执行，后者始终顺序执行。</li>
</ol>
<h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><h2 id="宏观关系"><a href="#宏观关系" class="headerlink" title="宏观关系"></a>宏观关系</h2><p><img src="/images/golang/scheduling-mpg-01.png" alt="MPG关系图"><br><img src="/images/golang/scheduling-mpg-02.png" alt="MPG关系图"><br><img src="/images/golang/scheduling-mpg-03.png" alt="MPG关系图"></p>
<h2 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h2><table>
<thead>
<tr>
<th>名称</th>
<th>源码</th>
<th>说明</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>全局M列表</td>
<td>runtime.allm</td>
<td>所有M的单链表</td>
<td>创建之后先进全局，随即进行初始化</td>
</tr>
<tr>
<td>全局P列表</td>
<td>runtime.allp</td>
<td>所有P的数组</td>
<td>创建之后先进全局，随即进行初始化</td>
</tr>
<tr>
<td>全局G列表</td>
<td>runtime.allgs</td>
<td>所有P的切片</td>
<td>创建之后先进全局，随即进行初始化</td>
</tr>
<tr>
<td>调度器的空闲M列表</td>
<td>runtime.sched.midle</td>
<td>空闲M的单链表</td>
<td>暂时不用；用时再取</td>
</tr>
<tr>
<td>调度器的空闲P列表</td>
<td>runtime.sched.midle</td>
<td>空闲P的单链表</td>
<td>P不在关联M，P中可运行G为空，加入该列表；M需要P关联，从此列表取；</td>
</tr>
<tr>
<td>调度器的可运行G队列</td>
<td>runtime.sched.runq.head；runtime.sched.runq.tail</td>
<td>可运行的G队列</td>
<td>如果P的可运行G队列满，加入此队列</td>
</tr>
<tr>
<td>调度器的自由G列表</td>
<td>runtime.sched.gFree.stack(有栈)；runtime.sched.gFree.noStack (无栈)</td>
<td>自由的G的两个单链表</td>
<td>本地P自由G列表缺G，此列表给补；本地P自由G列表满G，此列表收取；</td>
</tr>
<tr>
<td>P的可运行G队列</td>
<td>runtime.p.runq；runtime.p.runqhead；runtime.p.runqtail</td>
<td>P中的可运行G的队列</td>
<td>调度器初始化过的G，加入该队列</td>
</tr>
<tr>
<td>P的自由G列表</td>
<td>runtime.p.gfree</td>
<td>P中的自由G的单链表</td>
<td>包含一些已经运行完成的G；go启用G，先从此处寻找现成的G；</td>
</tr>
</tbody></table>
<h2 id="M-1"><a href="#M-1" class="headerlink" title="M"></a>M</h2><h3 id="结构体成员"><a href="#结构体成员" class="headerlink" title="结构体成员"></a>结构体成员</h3><table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>g0</td>
<td>*g</td>
<td>特殊的 goroutine，在 runtime 启动之初创建的，用于执行一些运行时任务</td>
</tr>
<tr>
<td>mstartfn</td>
<td>func()</td>
<td>在新的 M 上启动特殊任务（系统监控、GC辅助、M自旋）</td>
</tr>
<tr>
<td>curg</td>
<td>*g</td>
<td>当前 M 正在运行的 G 的指针</td>
</tr>
<tr>
<td>p</td>
<td>puintptr</td>
<td>当前 M 正在关联的那个 P</td>
</tr>
<tr>
<td>nextp</td>
<td>puintptr</td>
<td>暂存与当前 M 有潜在关联的 P（预连）</td>
</tr>
<tr>
<td>spinning</td>
<td>bool</td>
<td>是否在寻找可运行的 G，寻找过程中 M 自旋</td>
</tr>
<tr>
<td>lockedg</td>
<td>*g</td>
<td>当前 M 锁定的 G</td>
</tr>
</tbody></table>
<h2 id="P-1"><a href="#P-1" class="headerlink" title="P"></a>P</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Pidle</td>
<td>当前 P 未与任何 M 关联</td>
</tr>
<tr>
<td>Prunning</td>
<td>当前 P 正在于 M 关联</td>
</tr>
<tr>
<td>Psyscall</td>
<td>当前 P 中的运行的那个 G 正在进行系统调用</td>
</tr>
<tr>
<td>Pgcstop</td>
<td>运行时系统需要停止调度。例如，运行时系统正在垃圾回收的某些步骤前，就会试图把runtime.allp（全局 P 列表）都置于此状态</td>
</tr>
<tr>
<td>Pdead</td>
<td>当前 P 已经不会再被使用。例如，运行过程中，通过 runtime.GOMAXPROCS 函数减少了 p 的最大数量</td>
</tr>
</tbody></table>
<p><img src="/images/golang/scheduling-p-status-01.png" alt="P状态流转"></p>
<h2 id="G-1"><a href="#G-1" class="headerlink" title="G"></a>G</h2><h3 id="状态-1"><a href="#状态-1" class="headerlink" title="状态"></a>状态</h3><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Gidle</td>
<td>刚被新分配，但还未初始化</td>
</tr>
<tr>
<td>Grunnable</td>
<td>可运行队列中等待运行</td>
</tr>
<tr>
<td>Grunning</td>
<td>运行</td>
</tr>
<tr>
<td>Gsyscall</td>
<td>执行某个系统调用</td>
</tr>
<tr>
<td>Gwaiting</td>
<td>阻塞</td>
</tr>
<tr>
<td>Gdead</td>
<td>闲置</td>
</tr>
<tr>
<td>Gcopystack</td>
<td>栈被移动，移动的原因可能是栈的扩展或收缩</td>
</tr>
<tr>
<td>Gscan</td>
<td>组合状态，发生在 GC 扫描</td>
</tr>
</tbody></table>
<p><img src="/images/golang/scheduling-g-status-01.png" alt="G状态流转"></p>
<h2 id="MPG调度"><a href="#MPG调度" class="headerlink" title="MPG调度"></a>MPG调度</h2><p><img src="/images/golang/scheduling-mpg-04.png" alt="MPG调度"></p>
<ol>
<li>我们通过 go func () 来创建一个 goroutine</li>
<li>有两个存储 G 的队列，一个是局部调度器 P 的本地队列、一个是全局 G 队列。新创建的 G 会先保存在 P 的本地队列中，如果 P 的本地队列已经满了就会保存在全局的队列中</li>
<li>G 只能运行在 M 中，一个 M 必须持有一个 P，M 与 P 是 1：1 的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会想其他的 MP 组合偷取一个可执行的 G 来执行</li>
<li>一个 M 调度 G 执行的过程是一个循环机制</li>
<li>当 M 执行某一个 G 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除 (detach)，然后再创建一个新的操作系统的线程 (如果有空闲的线程可用就复用空闲线程) 来服务于这个 P</li>
<li>当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中</li>
</ol>
<h2 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h2><h3 id="work-stealing"><a href="#work-stealing" class="headerlink" title="work stealing"></a>work stealing</h3><p>当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。</p>
<h3 id="hand-off"><a href="#hand-off" class="headerlink" title="hand off"></a>hand off</h3><ol>
<li>利用并行<br>GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行</li>
<li>抢占<br>在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程，在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方</li>
<li>全局 G 队列<br>在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G</li>
</ol>
<h3 id="gopark"><a href="#gopark" class="headerlink" title="gopark"></a>gopark</h3><p>系统调用；<br>channel读写条件不满足；<br>抢占式调度时间片结束；</p>
<p>解除当前goroutine的m的绑定关系，将当前goroutine状态机切换为等待状态；<br>调用一次schedule()函数，在局部调度器P发起一轮新的调度。</p>
<h3 id="sysmon"><a href="#sysmon" class="headerlink" title="sysmon"></a>sysmon</h3><p>P的数量影响了同时运行go代码的协程数. 如果P被占用很久, 就会影响调度. sysmon协程的一个功能就是进行抢占.<br>sysmon协程是在go runtime初始化之后, 执行用户编写的代码之前, 由runtime启动的不与任何P绑定, 直接由一个M执行的协程. 类似于 linux中的执行一些系统任务的内核线程.<br>可认为是10ms执行一次. (初始运行间隔为20us(微秒), sysmon运行1ms后逐渐翻倍, 最终每10ms运行一次. 如果有发生过抢占成功, 则又恢复成 初始20us的运行间隔, 如此循环)</p>
<h3 id="mcall"><a href="#mcall" class="headerlink" title="mcall"></a>mcall</h3><p>mcall在golang需要进行协程切换时被调用，用来保存被切换出去协程的信息，并在当前线程的g0协程堆栈上执行新的函数。一般情况下，会在新函数中执行一次schedule()来挑选新的协程来运行。接下来我们就看看mcall的实现。</p>
<h3 id="M-的状态"><a href="#M-的状态" class="headerlink" title="M 的状态"></a>M 的状态</h3><p>自旋、非自旋</p>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><h3 id="如何停止长时间占用资源的g，信号协作"><a href="#如何停止长时间占用资源的g，信号协作" class="headerlink" title="如何停止长时间占用资源的g，信号协作"></a>如何停止长时间占用资源的g，信号协作</h3><p>asdf</p>
<h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3>]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>CSP</tag>
        <tag>MPG</tag>
        <tag>调度</tag>
        <tag>线程</tag>
        <tag>goroutine</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Go内存GC</title>
    <url>/golang/memory-gc/</url>
    <content><![CDATA[<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>Golang 一直都在高速发展，每次版本迭代，内存管理相关方面都会有所变化。</p>
<h2 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h2><p>STW 阶段指的是程序暂停所有运行中的协程，否则不会开始垃圾回收阶段。<br>最开始的时候，在垃圾回收阶段只有一个协程执行垃圾回收。<br>目前 并发GC，垃圾回收阶段用户协程与垃圾回收协程并发执行。STW时间，小于100微妙。</p>
<p>尽管 STW 如今已经优化到了半毫秒级别以下，但这个程序被卡死原因是由于需要进入 STW 导致的。原因在于，GC 在需要进入 STW 时，需要通知并让所有的用户态代码停止，但是 for {} 所在的 goroutine 永远都不会被中断，从而始终无法进入 STW 阶段。实际实践中也是如此，当程序的某个 goroutine 长时间得不到停止，强行拖慢进入 STW 的时机，这种情况下造成的影响（卡死）是非常可怕的。好在自 Go 1.14 之后，这类 goroutine 能够被异步地抢占，从而使得进入 STW 的时间不会超过抢占信号触发的周期，程序也不会因为仅仅等待一个 goroutine 的停止而停顿在进入 STW 之前的操作上。</p>
<h2 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h2><ol>
<li>灰色：对象还在标记队列中等待</li>
<li>黑色：对象已被标记，gcmarkBits 对应位为 1 – 该对象不会在本次 GC 中被回收</li>
<li>白色：对象未被标记，gcmarkBits 对应位为 0 – 该对象将会在本次 GC 中被清理</li>
</ol>
<p><img src="/images/golang/memory-manage-gc-01.png" alt="三色标记法"></p>
<p>通过上图，应该对三色标记法有了一个比较直观的了解，那么我们现在来讲讲原理。简单的讲，就是标记内存中那些还在使用中（即被引用了）的部分，而内存中不再使用（即未被引用）的部分，就是要回收的垃圾，需要将其回收，以供后续内存分配使用。上图中的 A、B、D 就是被引用正在使用的内存，而C、F、E 曾经被使用过，但现在没有任何对象引用，就需要被回收掉。</p>
<p>而 Root 区域主要是程序运行到当前时刻的栈和全局数据区域，是实时正在使用到的内存，当然应该优先标记。而考虑到内存块中存放的可能是指针，所以还需要递归的进行标记，待全部标记完后，就会对未被标记的内存进行回收。</p>
<h2 id="内存标记"><a href="#内存标记" class="headerlink" title="内存标记"></a>内存标记</h2><p>golang 中采用 span 数据结构管理内存，span 中维护了一个个内存块，并由一个位图 allocBits 表示内存块的分配情况，而上文中提到的 gcmarkBits 是记录每块内存块被引用情况的。</p>
<p><img src="/images/golang/memory-manage-gc-02.png" alt="内存标记"></p>
<p>如上图，allocBits 记录了每块内存的分配情况，而 gcmarkBits 记录了每块内存的标记情况。在标记阶段会对每块内存进行标记，有对象引用的内存标记为 1，没有对象引用的为 0。而 allocBits 和 gcmarkBits 的数据结构是完全一样的，在结束标记后，将 allocBits 指向 gcmarkBits，则有标记的才是存活的，这样就完成了内存回收。而 gcmarkBits 则会在下次标记时重新分配内存。</p>
<h2 id="垃圾回收优化"><a href="#垃圾回收优化" class="headerlink" title="垃圾回收优化"></a>垃圾回收优化</h2><p>在前文中提到，golang 的垃圾回收算法属于 标记-清除，是需要 STW 的。STW 就是 Stop The World 的意思，在 golang 中就是要停掉所有的 goroutine，专心进行垃圾回收，待垃圾回收结束后再恢复 goroutine。而 STW 时间的长短直接影响了应用的执行，如果时间过长，那将是灾难性的。为了缩短 STW 时间，golang 不对优化垃圾回收算法，其中写屏障（Write Barrier）和辅助GC（Mutator Assist）就是两种优化垃圾回收的方法。</p>
<ul>
<li>写屏障（Write Barrier）：上面说到的 STW 的目的是防止 GC 扫描时内存变化引起的混乱，而写屏障就是让 goroutine 与 GC 同时运行的手段，虽然不能完全消除 STW，但是可以大大减少 STW 的时间。写屏障在 GC 的特定时间开启，开启后指针传递时会把指针标记，即本轮不回收，下次 GC 时再确定。</li>
<li>辅助 GC（Mutator Assist）：为了防止内存分配过快，在 GC 执行过程中，GC 过程中 mutator 线程会并发运行，而 mutator assist 机制会协助 GC 做一部分的工作。</li>
</ul>
<h2 id="垃圾回收触发机制"><a href="#垃圾回收触发机制" class="headerlink" title="垃圾回收触发机制"></a>垃圾回收触发机制</h2><ol>
<li>内存分配量达到阈值：每次内存分配都会检查当前内存分配量是否达到阈值，如果达到阈值则触发 GC。阈值 = 上次 GC 内存分配量 * 内存增长率，内存增长率由环境变量 GOGC 控制，默认为 100，即每当内存扩大一倍时启动 GC。</li>
<li>定时触发 GC：默认情况下，2分钟触发一次 GC，该间隔由 src/runtime/proc.go 中的 forcegcperiod 声明。</li>
<li>手动触发 GC：在代码中，可通过使用 runtime.GC() 手动触发 GC。</li>
</ol>
<h2 id="GC-优化建议"><a href="#GC-优化建议" class="headerlink" title="GC 优化建议"></a>GC 优化建议</h2><p>由上文可知，GC 性能是与对象数量有关的，对象越多 GC 性能越差，对程序的影响也越大。所以在开发中要尽量减少对象分配个数，采用对象复用、将小对象组合成大对象或采用小数据类型（如使用 int8 代替 int）等。</p>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>一门编程语言的垃圾回收机制会直接影响使用其开发应用的性能。在日常开发工作中也因注意到其作用，有助于开发出高性能的应用，这也是 GC 常常在面试中被问到的原因。同时，了解 GC 对了解内存管理也很有帮助。</p>
<h1 id="参考借鉴"><a href="#参考借鉴" class="headerlink" title="参考借鉴"></a>参考借鉴</h1><p><a href="https://developer.aliyun.com/article/775798">浅析 Golang 垃圾回收机制</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>垃圾回收</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>Go面向对象</title>
    <url>/golang/oop/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于 Go 是不是面向对象语言的讨论一直喋喋不休，但讨论的结果并不重要，重要的是验证它的过程。</p>
<p>每门语言都有它独特的设计思想或者语言哲学，我们不能被过往的经验、传统概念所困住，能够使用它更优雅的解决问题，才是一门优秀编程语言价值的体现，至于它到底是白猫还是黑猫，也就没那么重要了。</p>
<span id="more"></span>

<h1 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h1><p>先从大家都熟知的四大特性入手。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</p>
<h3 id="Go的封装"><a href="#Go的封装" class="headerlink" title="Go的封装"></a>Go的封装</h3><p>Go语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而如果我们想要封装一个对象，我们必须将其定义为一个struct。</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-comment">// 重点在大小写，结构体名称、属性</span>
<span class="hljs-keyword">type</span> Html <span class="hljs-keyword">struct</span> &#123;
	Data <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Html)</span> <span class="hljs-title">read</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span></span> &#123;
	h.Data = <span class="hljs-string">&quot;sown&quot;</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Html)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;html&gt;&quot;</span> + h.Data + <span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>
&#125;

<span class="hljs-keyword">type</span> xml <span class="hljs-keyword">struct</span> &#123;
	data <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">read</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span></span> &#123;
	x.data = <span class="hljs-string">&quot;sown&quot;</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;xml&gt;&quot;</span> + x.data + <span class="hljs-string">&quot;&lt;/xml&gt;&quot;</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	h := Html&#123;&#125;
	h.read(<span class="hljs-string">&quot;./xml&quot;</span>)
	fmt.Println(h.format())
	
	x := xml&#123;&#125;
	x.read(<span class="hljs-string">&quot;./xml&quot;</span>)
	fmt.Println(x.format())
&#125;</code></pre></div>

<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p>
<p>我看网上有人用空结构体实现抽象类，我并不提倡这样做，遵循go的”面向接口编程”</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-comment">// 定义接口</span>
<span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;
	read(<span class="hljs-keyword">string</span>)
	format() <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-keyword">type</span> Html <span class="hljs-keyword">struct</span> &#123;
	Data <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Html)</span> <span class="hljs-title">read</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span></span> &#123;
	h.Data = <span class="hljs-string">&quot;sown&quot;</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Html)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;html&gt;&quot;</span> + h.Data + <span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>
&#125;

<span class="hljs-keyword">type</span> xml <span class="hljs-keyword">struct</span> &#123;
	data <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">read</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span></span> &#123;
	x.data = <span class="hljs-string">&quot;sown&quot;</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;xml&gt;&quot;</span> + x.data + <span class="hljs-string">&quot;&lt;/xml&gt;&quot;</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	h := Html&#123;&#125;
	h.read(<span class="hljs-string">&quot;./xml&quot;</span>)
	fmt.Println(h.format())

	x := xml&#123;&#125;
	x.read(<span class="hljs-string">&quot;./xml&quot;</span>)
	fmt.Println(x.format())
&#125;</code></pre></div>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。</p>
<p>继承是用来表示类之间的 is-a 关系，比如猫是一种哺乳动物。从继承关系上来讲，继承可以分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。</p>
<p>继承最大的一个好处就是代码复用。<br>如果我们再上升一个思维层面，去思考继承这一特性，非常符合人类的认知，而且，从设计的角度来说，也有一种结构美感。比如，子承父业，父债子偿。</p>
<p>如果继承层次过深过复杂，就会导致代码可读性、可维护性变差。举个🌰，如果让你穿越过去，寻找你爷爷的爷爷的爷爷的爷爷，然后一定要劝他搬到京城附近安家，这样你现在就不用每天996了。很显然，找人就已经很难了，再把居住的属性给改了，未知的事情就更多了，后来有没有你都是回事儿了（不过~，这样好像也确实摆脱996了）…</p>
<p>所以，有人提出来一种设计思想，就是”多用组合少用继承”。</p>
<p>那么 GO 可以实现继承吗？</p>
<h3 id="Go的单继承（组合）"><a href="#Go的单继承（组合）" class="headerlink" title="Go的单继承（组合）"></a>Go的单继承（组合）</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">&quot;fmt&quot;</span>
)

<span class="hljs-keyword">type</span> file <span class="hljs-keyword">struct</span> &#123;
	data <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *file)</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;
	f.data = <span class="hljs-string">&quot;sown&quot;</span>
&#125;

<span class="hljs-keyword">type</span> Html <span class="hljs-keyword">struct</span> &#123;
	file <span class="hljs-comment">//重点在这</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Html)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> h.data
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	h := Html&#123;&#125;
	h.read() <span class="hljs-comment">//重点在这，等同于 h.file.read()</span>
	fmt.Println(h.format())
&#125;</code></pre></div>

<h3 id="Go的多继承（组合）"><a href="#Go的多继承（组合）" class="headerlink" title="Go的多继承（组合）"></a>Go的多继承（组合）</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">&quot;fmt&quot;</span>
)

<span class="hljs-keyword">type</span> file <span class="hljs-keyword">struct</span> &#123;
	data <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *file)</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;
	f.data = <span class="hljs-string">&quot;file&quot;</span>
&#125;

<span class="hljs-keyword">type</span> db <span class="hljs-keyword">struct</span> &#123;
	data <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *db)</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;
	d.data = <span class="hljs-string">&quot;db&quot;</span>
&#125;

<span class="hljs-keyword">type</span> Html <span class="hljs-keyword">struct</span> &#123;
	file
	db
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Html)</span> <span class="hljs-title">format</span><span class="hljs-params">(data <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;html&gt;&quot;</span> + data + <span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	h := Html&#123;&#125;
	h.file.read() <span class="hljs-comment">//继承（组合）file</span>
	fmt.Println(h.format(h.file.data))

	h.db.read() <span class="hljs-comment">//继承（组合）db</span>
	fmt.Println(h.format(h.db.data))
&#125;</code></pre></div>

<h3 id="继承（组合）的方法调用注意"><a href="#继承（组合）的方法调用注意" class="headerlink" title="继承（组合）的方法调用注意"></a>继承（组合）的方法调用注意</h3><p>其实这里的要注意的问题，不是语法问题，而是要注意在Go中继承并非其他语言中的继承，而是利用组合代替了继承。</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">&quot;fmt&quot;</span>
	<span class="hljs-string">&quot;io/ioutil&quot;</span>
	<span class="hljs-string">&quot;os&quot;</span>
)

<span class="hljs-keyword">type</span> file <span class="hljs-keyword">struct</span> &#123;
	data <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *file)</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> f.format() <span class="hljs-comment">//&lt;-----重点在这里</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *file)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;file.format&quot;</span>
&#125;

<span class="hljs-keyword">type</span> Html <span class="hljs-keyword">struct</span> &#123;
	file
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Html)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;html.format&quot;</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	h := Html&#123;&#125;
	content := h.read()
	fmt.Println(content) <span class="hljs-comment">//file.format</span>
&#125;</code></pre></div>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">&quot;fmt&quot;</span>
)

<span class="hljs-keyword">type</span> i <span class="hljs-keyword">interface</span> &#123;
	format(content <span class="hljs-keyword">string</span>) <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-comment">// 重点在这里</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">format</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>, i i)</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> i.format(content)
&#125;

<span class="hljs-keyword">type</span> Html <span class="hljs-keyword">struct</span> &#123;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Html)</span> <span class="hljs-title">format</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;html&gt;&quot;</span> + content + <span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>
&#125;

<span class="hljs-keyword">type</span> Xml <span class="hljs-keyword">struct</span> &#123;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *Xml)</span> <span class="hljs-title">format</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;xml&gt;&quot;</span> + content + <span class="hljs-string">&quot;&lt;/xml&gt;&quot;</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	h := &amp;Html&#123;&#125;
	x := &amp;Xml&#123;&#125;
	fmt.Println(format(<span class="hljs-string">&quot;sown&quot;</span>, h)) <span class="hljs-comment">//&lt;html&gt;sown&lt;/html&gt;</span>
	fmt.Println(format(<span class="hljs-string">&quot;sown&quot;</span>, x)) <span class="hljs-comment">//&lt;xml&gt;sown&lt;/xml&gt;</span>
&#125;</code></pre></div>

<h1 id="Go特性"><a href="#Go特性" class="headerlink" title="Go特性"></a>Go特性</h1><h2 id="方法的定义：关于指针、值复制"><a href="#方法的定义：关于指针、值复制" class="headerlink" title="方法的定义：关于指针、值复制"></a>方法的定义：关于指针、值复制</h2><p>第一种定义方式在实例对应方法被调用时，实例的成员会进行值复制。<br>第二种方法被调用时，避免了内存拷贝。</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-keyword">type</span> Html <span class="hljs-keyword">struct</span> &#123;
	Data <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h Html)</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;
	h.Data = <span class="hljs-string">&quot;sown&quot;</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h Html)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;html&gt;&quot;</span> + h.Data + <span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>
&#125;

<span class="hljs-keyword">type</span> xml <span class="hljs-keyword">struct</span> &#123;
	data <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;
	x.data = <span class="hljs-string">&quot;sown&quot;</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;xml&gt;&quot;</span> + x.data + <span class="hljs-string">&quot;&lt;/xml&gt;&quot;</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	h := Html&#123;&#125;
	h.read()
	fmt.Println(h.format())	<span class="hljs-comment">//结果是&lt;html&gt;&lt;/html&gt;，期望是&lt;html&gt;sown&lt;/html&gt;</span>

	x := xml&#123;&#125;
	x.read()
	fmt.Println(x.format())	<span class="hljs-comment">//结果是&lt;xml&gt;sown&lt;/html&gt;</span>
&#125;</code></pre></div>
<h2 id="声明为接口类型"><a href="#声明为接口类型" class="headerlink" title="声明为接口类型"></a>声明为接口类型</h2><p>接口中只能定义方法签名，不能包含成员变量。声明一个实例变量为接口类型，这个实例的方法外部将无法访问成员变量。</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;
	read()
	format() <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-keyword">type</span> xml <span class="hljs-keyword">struct</span> &#123;
	data <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;
	x.data = <span class="hljs-string">&quot;sown&quot;</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;xml&gt;&quot;</span> + x.data + <span class="hljs-string">&quot;&lt;/xml&gt;&quot;</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> x I <span class="hljs-comment">//这里声明接口类型</span>
	x = &amp;xml&#123;&#125;
	x.read()
	x.data = <span class="hljs-string">&quot;nwos&quot;</span> <span class="hljs-comment">//这里报错</span>
	fmt.Println(x.format())
&#125;</code></pre></div>

<h2 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h2><p>先看如下代码：</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;
	read()
	format() <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-keyword">type</span> Html <span class="hljs-keyword">struct</span> &#123;
	Data <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h Html)</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;
	h.Data = <span class="hljs-string">&quot;sown&quot;</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h Html)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;html&gt;&quot;</span> + h.Data + <span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>
&#125;

<span class="hljs-keyword">type</span> xml <span class="hljs-keyword">struct</span> &#123;
	data <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;
	x.data = <span class="hljs-string">&quot;sown&quot;</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;xml&gt;&quot;</span> + x.data + <span class="hljs-string">&quot;&lt;/xml&gt;&quot;</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> h I
	h = Html&#123;&#125;
	h.read()
	fmt.Println(h.format())

	<span class="hljs-keyword">var</span> x I
	x = xml&#123;&#125; <span class="hljs-comment">// 这里报错</span>
	x.read()
	fmt.Println(x.format())
&#125;</code></pre></div>
<p>输出如下：</p>
<div class="note note-danger">
            <p>./main.go:41:4: cannot use xml literal (type xml) as type I in assignment:<br>xml does not implement I (format method has pointer receiver)</p>
          </div>
<p>为什么会这样呢？ 首先说几个定义：</p>
<blockquote>
<p>Pointer Receiver：(t T)，例如 <code>func (x xml) read()</code><br>Value Receiver：(t *T)，例如 <code>func (x *xml) read()</code></p>
</blockquote>
<p>方法集 Method set：</p>
<table>
<thead>
<tr>
<th>Values</th>
<th>Methods Receivers</th>
</tr>
</thead>
<tbody><tr>
<td>T</td>
<td>(t T)</td>
</tr>
<tr>
<td>*T</td>
<td>(t T) and (t *T)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Methods Receivers</th>
<th>Values</th>
</tr>
</thead>
<tbody><tr>
<td>(t T)</td>
<td>T and *T</td>
</tr>
<tr>
<td>(t *T)</td>
<td>*T</td>
</tr>
</tbody></table>
<p><strong>为什么T和*T具有不同的方法集？</strong></p>
<blockquote>
<p>如Go规范所述，类型的方法集T由具有接收器类型的所有方法组成T，而相应的指针类型*T的方法集由具有接收器*T或 的所有方法组成T。这意味着的方法集*T 包括的方法集T，但不包括相反的方法集。</p>
<p>之所以出现这种区别，是因为如果接口值包含指针*T，则方法调用可以通过取消引用指针来获取值，但是如果接口值包含value T，则方法调用就没有安全的方法来获取指针。（这样做将允许一种方法修改接口内部值的内容，这是语言规范所不允许的。）</p>
<p>即使在编译器可以将值的地址传递给方法的情况下，如果方法修改了该值，则更改也将在调用方中丢失。作为一个例子，如果该Write方法 bytes.Buffer 中使用的值接收器，而不是一个指针，这样的代码：</p>
<p>var buf bytes.Buffer<br>io.Copy(buf，os.Stdin)</p>
<p>会将标准输入复制到的副本中buf，而不是复制到buf自身中。这几乎从来不是期望的行为。</p>
</blockquote>
<p>来自<a href="https://golang.org/doc/faq#Functions_methods">https://golang.org/doc/faq#Functions_methods</a></p>
<blockquote>
<ol>
<li><p>如果您有a *T，则可以调用具有接收器类型的*T方法以及具有接收器类型的方法T（<a href="https://golang.org/ref/spec#Method_sets">Method Sets</a>）。</p>
</li>
<li><p>如果具有a T并且它是<a href="https://golang.org/ref/spec#Address_operators">可寻址</a>的，则可以调用具有接收器类型的*T方法以及具有接收器类型T的方法，因为该方法调用t.Meth()将等效于(&amp;t).Meth()（<a href="https://golang.org/ref/spec#Calls">Calls</a>）。</p>
</li>
<li><p>如果您有一个T且无法寻址，则只能调用接收者类型为T而不是的方法*T。</p>
</li>
<li><p>如果您有一个接口I，并且I方法集中的某些或全部方法由接收者为的方法提供*T（其余部分由接收者为的方法提供T），则*T满足该接口I，但T不满足。这是因为*T的方法集包括T，但不是（反过来说又回到了第一点）。</p>
</li>
</ol>
<p>简而言之，您可以将方法与值接收器混合使用，将方法与指针接收器混合使用，并将它们与包含值和指针的变量一起使用，而不必担心哪个是哪个。两者都可以使用，并且语法相同。但是，如果需要使用带有指针接收器的方法来满足一个接口，则只能将一个指针分配给该接口-值将无效。</p>
</blockquote>
<p>来自<a href="https://stackoverflow.com/questions/33587227/method-sets-pointer-vs-value-receiver">https://stackoverflow.com/questions/33587227/method-sets-pointer-vs-value-receiver</a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> People <span class="hljs-keyword">struct</span> &#123;
    Name <span class="hljs-keyword">string</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p People)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;print: %v&quot;</span>, p)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
    p := &amp;People&#123;&#125;
    p.String()
&#125;</code></pre></div>

<h1 id="开源学习"><a href="#开源学习" class="headerlink" title="开源学习"></a>开源学习</h1><h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><h2 id="面向协议"><a href="#面向协议" class="headerlink" title="面向协议"></a>面向协议</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>组合代替继承<br>面向接口编程<br>倾向于使用小的接口定义，很多接口只包含一个方法<br>较大的接口定义，可以由多个小接口定义组合而成<br>只依赖于必要功能的最小接口</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Go系列文章索引</title>
    <url>/golang/a/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><ol>
<li><a href="/golang/datastruct-arrayslice/" title="Go数据结构之数组与切片">Go数据结构之数组与切片</a><input type="checkbox" disabled checked="checked"></li>
<li><a href="/golang/oop/" title="Go数据结构之Map">Go数据结构之Map</a><input type="checkbox" disabled >

</li>
</ol>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><ol>
<li><a href="/golang/oop/" title="Go面向对象">Go面向对象</a><input type="checkbox" disabled >

</li>
</ol>
<h1 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h1><ol>
<li><a href="/golang/scheduling/" title="GoMPG与调度">GoMPG与调度</a><input type="checkbox" disabled ></li>
<li><a href="/golang/memory-alloc/" title="Go内存管理、分配">Go内存管理、分配</a><input type="checkbox" disabled ></li>
<li><a href="/golang/memory-gc/" title="Go内存GC">Go内存GC</a><input type="checkbox" disabled ></li>
<li><a href="/golang/memory-leak-escape/" title="Go内存泄漏、逃逸">Go内存泄漏、逃逸</a><input type="checkbox" disabled >

</li>
</ol>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><ol>
<li><a href="/golang/ipc-mutex/" title="Go并发编程之传统同步—(1)互斥锁">Go并发编程之传统同步—(1)互斥锁</a><input type="checkbox" disabled checked="checked"></li>
<li><a href="/golang/ipc-cond/" title="Go并发编程之传统同步—(2)条件变量">Go并发编程之传统同步—(2)条件变量</a><input type="checkbox" disabled checked="checked"></li>
<li><a href="/golang/ipc-atomic/" title="Go并发编程之传统同步—(3)原子操作">Go并发编程之传统同步—(3)原子操作</a><input type="checkbox" disabled checked="checked"></li>
<li>Once、WaitGroup <input type="checkbox" disabled ></li>
<li>Context <input type="checkbox" disabled ></li>
<li>Map <input type="checkbox" disabled ></li>
<li>临时对象池 <input type="checkbox" disabled ></li>
<li>data race <input type="checkbox" disabled ></li>
<li>channel <input type="checkbox" disabled ></li>
</ol>
<h1 id="项目工程"><a href="#项目工程" class="headerlink" title="项目工程"></a>项目工程</h1><ol>
<li><a href="https://lailin.xyz/post/go-training-03.html">Go错误处理</a><input type="checkbox" disabled checked="checked"></li>
</ol>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>1.无锁编程</p>
]]></content>
  </entry>
  <entry>
    <title>Go内存管理、分配</title>
    <url>/golang/memory-alloc/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是以 go 1.15 为基础编写，而就在我写这篇文章的时候，go master 分支已经发生了与 1.15 不同的变化，可能在 1.16 及以后的源码会与文章内容有些出入，但总体差异应该不会太大，比如申请内存的流程、内存的模型设计，所以这篇文章应该不会很快过时。</p>
<h1 id="系统内存"><a href="#系统内存" class="headerlink" title="系统内存"></a>系统内存</h1><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p><img src="/images/golang/memory-manage-vm-01.png" alt="虚拟内存"><br>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。<br>目前，大多数操作系统都使用了虚拟内存，如Windows家族的“虚拟内存”；Linux的“交换空间”等。</p>
<ul>
<li>访问内存，实际访问的是虚拟内存</li>
<li>虚拟内存通过页表查看，当前要访问的虚拟内存地址，是否已经加载到了物理内存，如果已经在物理内存，则取物理内存数据，如果没有对应的物理内存，则从磁盘加载数据到物理内存，并把物理内存地址和虚拟内存地址更新到页表。</li>
<li>每个进程都要各自的虚拟内存，内存的并发访问问题的粒度从多进程级别，可以降低到多线程级别。</li>
</ul>
<h2 id="堆、栈"><a href="#堆、栈" class="headerlink" title="堆、栈"></a>堆、栈</h2><p><img src="/images/golang/memory-manage-vm-02.png" alt="堆、栈"></p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul>
<li>栈在高地址，从高地址向低地址增长；堆在低地址，从低地址向高地址增长。</li>
<li>栈的内存不需要回收；堆需要回收，无论是主动free、垃圾回收。</li>
<li>栈上的内存有更好的局部性；堆上内存访访问2块数据可能在不同的页上。</li>
<li>栈是操作系统管理的；堆是用户管理的</li>
<li>栈是静态内存分配；堆是动态内存分配</li>
</ul>
<h3 id="栈还有以下特点"><a href="#栈还有以下特点" class="headerlink" title="栈还有以下特点"></a>栈还有以下特点</h3><ul>
<li>LIFO，每当一个函数声明一个新变量时，它就被“推”到堆栈的最顶层块上。然后，每当一个函数退出时，最上面的块就会被清除</li>
<li>每个线程一个 stack</li>
</ul>
<h2 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h2><h3 id="1-手动管理"><a href="#1-手动管理" class="headerlink" title="1. 手动管理"></a>1. 手动管理</h3><p>代表语言有 C、C++，需要调用 alloc, realloc, calloc, free 等函数</p>
<h3 id="2-垃圾回收（GC）"><a href="#2-垃圾回收（GC）" class="headerlink" title="2. 垃圾回收（GC）"></a>2. 垃圾回收（GC）</h3><p>在计算机科学中，垃圾回收（英语：Garbage Collection，缩写为GC）是指一种自动的存储器管理机制。当某个程序占用的一部分内存空间不再被这个程序访问时，这个程序会借助垃圾回收算法向操作系统归还这部分内存空间。垃圾回收器可以减轻程序员的负担，也减少程序中的错误。垃圾回收最早起源于LISP语言。</p>
<h4 id="2-1-标记和扫描GC-Mark-sweep"><a href="#2-1-标记和扫描GC-Mark-sweep" class="headerlink" title="2.1 标记和扫描GC(Mark-sweep)"></a>2.1 标记和扫描GC(Mark-sweep)</h4><p>代表语言有 Golang<br>标记和扫描GC，也称为跟踪GC。<br>它通常是一个两阶段的算法，首先将仍然被引用的对象标记为“活的”，然后在下一阶段释放不活的对象的内存。从根变量开始遍历所有引用的对象，标记引用的对象，没有被标记的进行回收</p>
<ul>
<li>优点：解决了引用计数的缺点。</li>
<li>缺点：需要 STW，暂时停掉程序运行。</li>
</ul>
<h4 id="2-2-引用计数GC"><a href="#2-2-引用计数GC" class="headerlink" title="2.2 引用计数GC"></a>2.2 引用计数GC</h4><p>代表语言有 PHP, Perl, and Python<br>在这种方法中，每个对象获得一个引用计数，该引用计数随着对它的引用的改变而增加或减少，当计数变为零时，垃圾收集就完成了，缺点是不能处理循环引用。</p>
<ul>
<li>优点：对象回收快，不会出现内存耗尽或达到某个阈值时才回收。</li>
<li>缺点：不能很好的处理循环引用，而实时维护引用计数也是有损耗的。</li>
</ul>
<h4 id="2-3-标记-压缩-Mark-compact"><a href="#2-3-标记-压缩-Mark-compact" class="headerlink" title="2.3 标记-压缩(Mark-compact)"></a>2.3 标记-压缩(Mark-compact)</h4><h4 id="2-4-半空间复制（Semispace-copy）"><a href="#2-4-半空间复制（Semispace-copy）" class="headerlink" title="2.4 半空间复制（Semispace copy）"></a>2.4 半空间复制（Semispace copy）</h4><h4 id="2-5-分代GC"><a href="#2-5-分代GC" class="headerlink" title="2.5 分代GC"></a>2.5 分代GC</h4><p>代表语言 Java，按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。</p>
<ul>
<li>优点：回收性能好</li>
<li>缺点：算法复杂</li>
</ul>
<h1 id="TCMalloc"><a href="#TCMalloc" class="headerlink" title="TCMalloc"></a>TCMalloc</h1><p><img src="/images/golang/memory-manage-tcmalloc-01.png" alt="TCMalloc"></p>
<p>内存分配策略的实现，我们也可以叫它内存分配器，相当于在用户编写的程序与虚拟内存中间建立了”内存池”，而避免手写内存池。</p>
<p>下面是比较成熟的内存池实现库</p>
<ul>
<li>glibc 的 ptmalloc2</li>
<li>google 的 tcmalloc</li>
<li>facebook 的 jemalloc</li>
</ul>
<p>Golang 正是使用了 <a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">TCMalloc</a> 的设计思想。</p>
<h2 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h2><p>操作系统对内存管理以页为单位，TCMalloc 也是这样，只不过 TCMalloc 里的 Page 大小与操作系统里的大小并不一定相等，而是倍数关系，x64 下 Page 大小是 8KB。</p>
<h2 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h2><p>一组连续的 Page 被称为 Span，比如可以有 2 个页大小的 Span，也可以有 16 页大小的 Span，Span 比 Page 高一个层级，是为了方便管理一定大小的内存区域，Span 是 TCMalloc 中内存管理的基本单位。</p>
<h2 id="ThreadCache"><a href="#ThreadCache" class="headerlink" title="ThreadCache"></a>ThreadCache</h2><p>每个线程各自的 Cache，一个Cache包含多个空闲内存块链表，每个链表连接的都是内存块，同一个链表上内存块的大小是相同的，也可以说按内存块大小，给内存块分了个类，这样可以根据申请的内存大小，快速从合适的链表选择空闲内存块。由于每个线程有自己的 ThreadCache，所以 ThreadCache 访问是无锁的。</p>
<h2 id="CentralCache"><a href="#CentralCache" class="headerlink" title="CentralCache"></a>CentralCache</h2><p>是所有线程共享的缓存，也是保存的空闲内存块链表，链表的数量与 ThreadCache 中链表数量相同，当 ThreadCache 内存块不足时，可以从 CentralCache 取，当 ThreadCache 内存块多时，可以放回 CentralCache。由于 CentralCache 是共享的，所以它的访问是要加锁的。</p>
<h2 id="PageHeap"><a href="#PageHeap" class="headerlink" title="PageHeap"></a>PageHeap</h2><p>PageHeap 是堆内存的抽象，PageHeap 存的也是若干链表，链表保存的是 Span，当 CentralCache 没有内存的时，会从 PageHeap 取，把1个 Span 拆成若干内存块，添加到对应大小的链表中，当 CentralCache 内存多的时候，会放回 PageHeap。毫无疑问，PageHeap 也是要加锁的。</p>
<h2 id="对象大小"><a href="#对象大小" class="headerlink" title="对象大小"></a>对象大小</h2><ul>
<li>小对象大小：0~256KB</li>
<li>中对象大小：257~1024kb</li>
<li>大对象大小：&gt; 1024kb</li>
</ul>
<h1 id="GOMalloc"><a href="#GOMalloc" class="headerlink" title="GOMalloc"></a>GOMalloc</h1><p><img src="/images/golang/memory-manage-gomalloc-01.png" alt="Golang内存管理"></p>
<h2 id="大小维度"><a href="#大小维度" class="headerlink" title="大小维度"></a>大小维度</h2><h2 id="object-size"><a href="#object-size" class="headerlink" title="object size"></a>object size</h2><p>是申请对象的大小，比如，申请一个 8byte object size。</p>
<h2 id="size-class"><a href="#size-class" class="headerlink" title="size class"></a>size class</h2><p><code>object size</code> 的分类、级别，比如 8byte ~ 16byte，16byte ~ 32byte，32byte ~ 48byte …，共 67 个<br>在代码中是这样的：</p>
<div class="code-wrapper"><pre><code class="hljs go">_NumSizeClasses = <span class="hljs-number">67</span></code></pre></div>

<h2 id="span-class"><a href="#span-class" class="headerlink" title="span class"></a>span class</h2><p><code>span</code> 的分类、级别，共 134 个，是 size class 的一倍<br>在代码中是这样的：</p>
<div class="code-wrapper"><pre><code class="hljs go">numSpanClasses = _NumSizeClasses &lt;&lt; <span class="hljs-number">1</span></code></pre></div>
<p>其中 67 个是 scan (对象中含有指针的），另外 67 个是 noscan（对象中不含有指针的）</p>
<h1 id="分配器结构"><a href="#分配器结构" class="headerlink" title="分配器结构"></a>分配器结构</h1><h2 id="page"><a href="#page" class="headerlink" title="page"></a>page</h2><p>与 TCMalloc 中的 Page 定义相同。</p>
<h2 id="mspan"><a href="#mspan" class="headerlink" title="mspan"></a>mspan</h2><p>与 TCMalloc 中的 Span 定义相同。<br>在代码中是这样的：</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mspan <span class="hljs-keyword">struct</span> &#123;
    allocBits  *gcBits
	gcmarkBits *gcBits
&#125;</code></pre></div>

<h2 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h2><p>与 TCMalloc 中的 ThreadCache 定义相同，但在 Golang 中每个 P（MPG中的P）拥有独立的 mcache，可以做到无锁访问。<br>在 mcache 中缓存着 134 个 mspan， 在代码中是这样的：</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mcache <span class="hljs-keyword">struct</span> &#123;
    alloc [numSpanClasses]*mspan</code></pre></div>

<h2 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h2><p>所有 P 的共享缓存，访问是要加锁的。<br>在代码中是这样的：</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mcentral <span class="hljs-keyword">struct</span> &#123;
    nonempty mSpanList <span class="hljs-comment">// 有空闲对象的 mspan 链表</span>
	empty    mSpanList <span class="hljs-comment">// 没有空闲对象或 span 已经被 mcache 缓存的 span 链表</span></code></pre></div>
<p>那 mcentral 有多少个呢？往下看 mheap</p>
<h2 id="mheap"><a href="#mheap" class="headerlink" title="mheap"></a>mheap</h2><p>mcentral 被 mheap 所管理，也是 134 个</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mheap <span class="hljs-keyword">struct</span> &#123;
    arenas [<span class="hljs-number">1</span> &lt;&lt; arenaL1Bits]*[<span class="hljs-number">1</span> &lt;&lt; arenaL2Bits]*heapArena
    
    central [numSpanClasses]<span class="hljs-keyword">struct</span> &#123;
    mcentral mcentral
    pad      [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;)%cpu.CacheLinePadSize]<span class="hljs-keyword">byte</span>
    &#125;</code></pre></div>

<h2 id="pageCache"><a href="#pageCache" class="headerlink" title="pageCache"></a>pageCache</h2><p>在向mheap申请small内存的时候，会先访问 P 中的 pcache，P 结构如下：</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> p <span class="hljs-keyword">struct</span> &#123;
    pcache      pageCache
&#125;</code></pre></div>
<p>pageCache结构如下</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> pageCache <span class="hljs-keyword">struct</span> &#123;
	base  <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// base address of the chunk</span>
	cache <span class="hljs-keyword">uint64</span>  <span class="hljs-comment">// 64-bit bitmap representing free pages (1 means free)</span>
	scav  <span class="hljs-keyword">uint64</span>  <span class="hljs-comment">// 64-bit bitmap representing scavenged pages (1 means scavenged)</span>
&#125;</code></pre></div>

<h2 id="fixalloc"><a href="#fixalloc" class="headerlink" title="fixalloc"></a>fixalloc</h2><p>基于自由列表的固定大小的分配器</p>
<h1 id="分配流程"><a href="#分配流程" class="headerlink" title="分配流程"></a>分配流程</h1><h2 id="小内存"><a href="#小内存" class="headerlink" title="小内存"></a>小内存</h2><p>mcache-&gt;mcentral-&gt;mheap位图查找-&gt;pageCache → mheap基数树查找→操作系统分配</p>
<h2 id="大内存"><a href="#大内存" class="headerlink" title="大内存"></a>大内存</h2><p>大对象是大小大于32KB的内存，不与 mcache 和 mcentral 沟通，并直接通过 mheap 进行分配。经历mheap基数树查找→操作系统分配 的过程。每一个大对象是一个特殊的span, 它的class是0。</p>
<h2 id="寻找-span"><a href="#寻找-span" class="headerlink" title="寻找 span"></a>寻找 span</h2><ol>
<li>计算对象所需内存大小size</li>
<li>根据size到size class映射，计算出所需的size class</li>
<li>根据size class和对象是否包含指针计算出span class</li>
<li>获取该span class指向的span。</li>
</ol>
<p>以分配一个不包含指针的，大小为24Byte的对象为例。</p>
<p>根据映射表：</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// class  bytes/obj  bytes/span  objects  tail waste  max waste</span>
<span class="hljs-comment">//     1          8        8192     1024           0     87.50%</span>
<span class="hljs-comment">//     2         16        8192      512           0     43.75%</span>
<span class="hljs-comment">//     3         32        8192      256           0     46.88%</span>
<span class="hljs-comment">//     4         48        8192      170          32     31.52%</span>
<span class="hljs-comment">//     5         64        8192      128           0     23.44%</span>
<span class="hljs-comment">//     6         80        8192      102          32     19.07%</span>
<span class="hljs-comment">//     7         96        8192       85          32     15.95%</span>
<span class="hljs-comment">//     8        112        8192       73          16     13.56%</span>
<span class="hljs-comment">//     9        128        8192       64           0     11.72%</span>
<span class="hljs-comment">//    10        144        8192       56         128     11.82%</span>
<span class="hljs-comment">//    11        160        8192       51          32      9.73%</span></code></pre></div>
<p>size class 3，它的对象大小范围是(16,32]Byte，24Byte刚好在此区间，所以此对象的size class为3。<br>Size class到span class的计算如下：</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// noscan为true代表对象不包含指针</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeSpanClass</span><span class="hljs-params">(sizeclass <span class="hljs-keyword">uint8</span>, noscan <span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">spanClass</span></span> &#123;
	<span class="hljs-keyword">return</span> spanClass(sizeclass&lt;&lt;<span class="hljs-number">1</span>) | spanClass(bool2int(noscan))
&#125;</code></pre></div>
<p>所以，对应的span class为：</p>
<div class="code-wrapper"><pre><code class="hljs go">span class = <span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span> = <span class="hljs-number">7</span></code></pre></div>
<p>所以该对象需要的是span class 7指向的span。</p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>在 GO 目前的版本中，内存管理使用了 位图（bitmap）、基数树（radix tree）。</p>
<h2 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h2><p>图（Bitmap），即位（Bit）的集合，是一种数据结构，可用于记录大量的0-1状态，在很多地方都会用到，比如Linux内核（如inode，磁盘块）、Bloom Filter算法等，其优势是可以在一个非常高的空间利用率下保存大量0-1状态。<br>BitMap算法的核心思想是用bit数组来记录0-1两种状态，然后再将具体数据映射到这个比特数组的具体位置，这个比特位设置成0表示数据不存在，设置成1表示数据存在。<br>BitMap算在在大量数据查询、去重等应用场景中使用的比较多，这个算法具有比较高的空间利用率。<br>在《编程珠玑》第一章中，就有利用bitmap进行大量文件的排序。<br>JDK<br>google</p>
<h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><p><img src="/images/golang/memory-manage-trie-01.png" alt="前缀树"><br>在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。<br>应用场景<br>trie树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p>
<h2 id="基数树"><a href="#基数树" class="headerlink" title="基数树"></a>基数树</h2><p><img src="/images/golang/memory-manage-radix-01.png" alt="基数树"><br>在计算机科学中，基数树，或称Patricia trie/tree，或crit bit tree，压缩前缀树，是一种更节省空间的Trie（前缀树）。对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。<br>应用场景<br>用于IP 路由。 信息检索中用于文本文档的倒排索引。</p>
<h2 id="go-内存管理中的位图、基数树"><a href="#go-内存管理中的位图、基数树" class="headerlink" title="go 内存管理中的位图、基数树"></a>go 内存管理中的位图、基数树</h2><p>在Go1.12的时候,Go语言采用了 Treap 进行内存的管理，Treap 是一种引入了随机数的二叉树搜索树，其实现简单，并且引入的随机数以及必要时的旋转保证了比较好的平衡特性。</p>
<h3 id="mspan-的实现-基数树（radix-tree）"><a href="#mspan-的实现-基数树（radix-tree）" class="headerlink" title="mspan 的实现 基数树（radix tree）"></a>mspan 的实现 基数树（radix tree）</h3><p>管理线性的地址空间的位图结构叫做基数树<br>mpagealloc.go</p>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><ul>
<li>mpagealloc.go：Page allocator、radix tree</li>
<li>malloc.go：mallocgc() 申请内存的入口</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>bitmap 管理内存页<br>radix tree 内存管理的结构</p>
<h1 id="参考借鉴"><a href="#参考借鉴" class="headerlink" title="参考借鉴"></a>参考借鉴</h1><p><a href="https://lessisbetter.site/2019/07/06/go-memory-allocation/">Go内存分配那些事，就这么简单！</a><br><a href="https://www.bilibili.com/video/av288263284/">GopherCon 2020: Michael Knyszek - Evolving the Go Memory Manager’s RAM</a><br><a href="https://juejin.cn/post/6844903769201704973">漫画：什么是Bitmap算法？</a><br><a href="http://c.biancheng.net/view/1270.html">什么是虚拟内存，虚拟内存及其作用详解</a></p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
        <tag>内存分配</tag>
      </tags>
  </entry>
  <entry>
    <title>Go内存泄漏、逃逸</title>
    <url>/golang/memory-leak-escape/</url>
    <content><![CDATA[<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p><a href="https://segmentfault.com/a/1190000019222661">实战Go内存泄露</a></p>
<h1 id="内存逃逸"><a href="#内存逃逸" class="headerlink" title="内存逃逸"></a>内存逃逸</h1><h2 id="关于-堆和栈"><a href="#关于-堆和栈" class="headerlink" title="关于 堆和栈"></a>关于 堆和栈</h2><p>栈 可以简单得理解成一次函数调用内部申请到的内存，它们会随着函数的返回把内存还给系统。</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F</span><span class="hljs-params">()</span></span> &#123;
	temp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>)
	...
&#125;</code></pre></div>
<p>类似于上面代码里面的temp变量，只是内函数内部申请的临时变量，并不会作为返回值返回，它就是被编译器申请到栈里面。</p>
<p>申请到 栈内存 好处：函数返回直接释放，不会引起垃圾回收，对性能没有影响。</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F</span><span class="hljs-params">()</span> []<span class="hljs-title">int</span></span>&#123;
	a := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>)
	<span class="hljs-keyword">return</span> a
&#125;</code></pre></div>
<p>而上面这段代码，申请的代码一模一样，但是申请后作为返回值返回了，编译器会认为变量之后还会被使用，当函数返回之后并不会将其内存归还，那么它就会被申请到 堆 上面了。</p>
<p>申请到堆上面的内存才会引起垃圾回收，如果这个过程（特指垃圾回收不断被触发）过于高频就会导致 gc 压力过大，程序性能出问题。</p>
<p>我们再看看如下几个例子：</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F</span><span class="hljs-params">()</span></span> &#123;
	a := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>)     <span class="hljs-comment">// 栈 空间小</span>
	b := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20000</span>) <span class="hljs-comment">// 堆 空间过大</span>
 
	l := <span class="hljs-number">20</span>
	c := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, l) <span class="hljs-comment">// 堆 动态分配不定空间</span>
&#125;</code></pre></div>
<p>像是 b 这种 即使是临时变量，申请过大也会在堆上面申请。<br>对于 c 编译器对于这种不定长度的申请方式，也会在堆上面申请，即使申请的长度很短。</p>
<h2 id="逃逸分析（Escape-analysis）"><a href="#逃逸分析（Escape-analysis）" class="headerlink" title="逃逸分析（Escape analysis）"></a>逃逸分析（Escape analysis）</h2><p>所谓逃逸分析（Escape analysis）是指由编译器决定内存分配的位置，不需要程序员指定。</p>
<p>在函数中申请一个新的对象：</p>
<ul>
<li>如果分配 在栈中，则函数执行结束可自动将内存回收；</li>
<li>如果分配在堆中，则函数执行结束可交给GC（垃圾回收）处理;<br>注意，对于函数外部没有引用的对象，也有可能放到堆中，比如内存过大超过栈的存储能力。</li>
</ul>
<h2 id="逃逸场景（什么情况才分配到堆中）"><a href="#逃逸场景（什么情况才分配到堆中）" class="headerlink" title="逃逸场景（什么情况才分配到堆中）"></a>逃逸场景（什么情况才分配到堆中）</h2><h3 id="指针逃逸"><a href="#指针逃逸" class="headerlink" title="指针逃逸"></a>指针逃逸</h3><p>Go可以返回局部变量指针，这其实是一个典型的变量逃逸案例，示例代码如下：</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;
    Name <span class="hljs-keyword">string</span>
    Age  <span class="hljs-keyword">int</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StudentRegister</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, age <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">Student</span></span> &#123;
    s := <span class="hljs-built_in">new</span>(Student) <span class="hljs-comment">//局部变量s逃逸到堆</span>

    s.Name = name
    s.Age = age

    <span class="hljs-keyword">return</span> s
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
    StudentRegister(<span class="hljs-string">&quot;Jim&quot;</span>, <span class="hljs-number">18</span>)
&#125;</code></pre></div>
<p>虽然 在函数 StudentRegister() 内部 s 为局部变量，其值通过函数返回值返回，s 本身为一指针，其指向的内存地址不会是栈而是堆，这就是典型的逃逸案例。</p>
<p>终端运行命令查看逃逸分析日志：<br><code>go build -gcflags=-m</code><br>可见在StudentRegister()函数中，也即代码第9行显示”escapes to heap”，代表该行内存分配发生了逃逸现象。</p>
<h3 id="栈空间不足逃逸（空间开辟过大）"><a href="#栈空间不足逃逸（空间开辟过大）" class="headerlink" title="栈空间不足逃逸（空间开辟过大）"></a>栈空间不足逃逸（空间开辟过大）</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Slice</span><span class="hljs-params">()</span></span> &#123;
    s := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>)

    <span class="hljs-keyword">for</span> index, _ := <span class="hljs-keyword">range</span> s &#123;
        s[index] = index
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
    Slice()
&#125;</code></pre></div>
<p>上面代码Slice()函数中分配了一个1000个长度的切片，是否逃逸取决于栈空间是否足够大。 直接查看编译提示，如下：</p>
<p>所以只是1000的长度还不足以发生逃逸现象。然后就x10倍吧</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Slice</span><span class="hljs-params">()</span></span> &#123;
    s := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>)

    <span class="hljs-keyword">for</span> index, _ := <span class="hljs-keyword">range</span> s &#123;
        s[index] = index
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
    Slice()
&#125;</code></pre></div>
<p>分析如下：<br>当切片长度扩大到10000时就会逃逸。<br>实际上当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中。</p>
<h3 id="动态类型逃逸（不确定长度大小）"><a href="#动态类型逃逸（不确定长度大小）" class="headerlink" title="动态类型逃逸（不确定长度大小）"></a>动态类型逃逸（不确定长度大小）</h3><p>很多函数参数为interface类型，比如fmt.Println(a …interface{})，编译期间很难确定其参数的具体类型，也能产生逃逸。</p>
<p>如下代码所示：</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
    s := <span class="hljs-string">&quot;Escape&quot;</span>
    fmt.Println(s)
&#125;</code></pre></div>
<div class="code-wrapper"><pre><code class="hljs shell">D:\SourceCode\GoExpert\src&gt;go build -gcflags=-m
<span class="hljs-meta">#</span><span class="bash"> _/D_/SourceCode/GoExpert/src</span>
.\main.go:7: s escapes to heap
.\main.go:7: main ... argument does not escape</code></pre></div>
<p>又或者像前面提到的例子：</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F</span><span class="hljs-params">()</span></span> &#123;
	a := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>)     <span class="hljs-comment">// 栈 空间小</span>
	b := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20000</span>) <span class="hljs-comment">// 堆 空间过大 逃逸</span>
 
	l := <span class="hljs-number">20</span>
	c := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, l) <span class="hljs-comment">// 堆 动态分配不定空间 逃逸</span>
&#125;</code></pre></div>
<h3 id="闭包引用对象逃逸"><a href="#闭包引用对象逃逸" class="headerlink" title="闭包引用对象逃逸"></a>闭包引用对象逃逸</h3><p>Fibonacci数列的函数：</p>
<div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;
    a, b := <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;
        a, b = b, a+b
        <span class="hljs-keyword">return</span> a
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
    f := Fibonacci()

    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;
        fmt.Printf(<span class="hljs-string">&quot;Fibonacci: %d\n&quot;</span>, f())
    &#125;
&#125;</code></pre></div>
<p>输出如下：</p>
<div class="code-wrapper"><pre><code class="hljs shell">~/go/src/gitHub/test/pool  go run main.go
Fibonacci: 1
Fibonacci: 1
Fibonacci: 2
Fibonacci: 3
Fibonacci: 5
Fibonacci: 8
Fibonacci: 13
Fibonacci: 21
Fibonacci: 34
Fibonacci: 55</code></pre></div>
<p>逃逸如下：</p>
<div class="code-wrapper"><pre><code class="hljs shell"> ~/go/src/gitHub/test/pool  go build -gcflags=-m
<span class="hljs-meta">#</span><span class="bash"> gitHub/<span class="hljs-built_in">test</span>/pool</span>
./main.go:7:9: can inline Fibonacci.func1
./main.go:7:9: func literal escapes to heap
./main.go:7:9: func literal escapes to heap
./main.go:8:10: &amp;b escapes to heap
./main.go:6:5: moved to heap: b
./main.go:8:13: &amp;a escapes to heap
./main.go:6:2: moved to heap: a
./main.go:17:34: f() escapes to heap
./main.go:17:13: main ... argument does not escape</code></pre></div>
<p>Fibonacci()函数中原本属于局部变量的a和b由于闭包的引用，不得不将二者放到堆上，以致产生逃逸。</p>
<h2 id="逃逸分析的作用是什么呢？"><a href="#逃逸分析的作用是什么呢？" class="headerlink" title="逃逸分析的作用是什么呢？"></a>逃逸分析的作用是什么呢？</h2><ul>
<li>逃逸分析的好处是为了减少gc的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要gc标记清除。</li>
<li>逃逸分析完后可以确定哪些变量可以分配在栈上，栈的分配比堆快，性能好(逃逸的局部变量会在堆上分配 ,而没有发生逃逸的则有编译器在栈上分配)。</li>
<li>同步消除，如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。</li>
</ul>
<h2 id="逃逸总结："><a href="#逃逸总结：" class="headerlink" title="逃逸总结："></a>逃逸总结：</h2><ul>
<li>栈上分配内存比在堆中分配内存有更高的效率</li>
<li>栈上分配的内存不需要GC处理</li>
<li>堆上分配的内存使用完毕会交给GC处理</li>
<li>逃逸分析目的是决定内分配地址是栈还是堆</li>
<li>逃逸分析在编译阶段完成</li>
</ul>
<h2 id="提问：函数传递指针真的比传值效率高吗？"><a href="#提问：函数传递指针真的比传值效率高吗？" class="headerlink" title="提问：函数传递指针真的比传值效率高吗？"></a>提问：函数传递指针真的比传值效率高吗？</h2><p>我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的。<br>在官网 (golang.org) FAQ 上有一个关于变量分配的问题如下：<br>From a correctness standpoint, you don’t need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.</p>
<p>The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function’s stack frame.</p>
<p>However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.</p>
<p>In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.</p>
<p>翻译如下：</p>
<p>如何得知变量是分配在栈（stack）上还是堆（heap）上？</p>
<p>准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。</p>
<p>知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。 然而，如果编译器不能确保变量在函数 return之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。</p>
<p>当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上。然而，还要对这些变量做逃逸分析，如果函数return之后，变量不再被引用，则将其分配到栈上。</p>
<h1 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h1><h1 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h1>]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>Go内存泄漏、逃逸</tag>
      </tags>
  </entry>
</search>
