<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>实战Go内存泄露(转载)</title>
    <link href="/golang/memory-leak/"/>
    <url>/golang/memory-leak/</url>
    
    <content type="html"><![CDATA[<p>最近解决了我们项目中的一个内存泄露问题，事实再次证明pprof是一个好工具，但掌握好工具的正确用法，才能发挥好工具的威力，不然就算你手里有屠龙刀，也成不了天下第一，本文就是带你用pprof定位内存泄露问题。</p><a id="more"></a><p>关于Go的内存泄露有这么一句话不知道你听过没有：</p><blockquote><p>10次内存泄露，有9次是goroutine泄露。</p></blockquote><p>我所解决的问题，也是goroutine泄露导致的内存泄露，所以<strong>这篇文章主要介绍Go程序的goroutine泄露，掌握了如何定位和解决goroutine泄露，就掌握了内存泄露的大部分场景</strong>。</p><blockquote><p>本文草稿最初数据都是生产坏境数据，为了防止敏感内容泄露，全部替换成了demo数据，demo的数据比生产环境数据简单多了，更适合入门理解，有助于掌握pprof。</p></blockquote><hr><h1 id="go-pprof基本知识"><a href="#go-pprof基本知识" class="headerlink" title="go pprof基本知识"></a>go pprof基本知识</h1><p>定位goroutine泄露会使用到pprof，pprof是Go的性能工具，在开始介绍内存泄露前，先简单介绍下pprof的基本使用，更详细的使用给大家推荐了资料。</p><h2 id="什么是pprof"><a href="#什么是pprof" class="headerlink" title="什么是pprof"></a>什么是pprof</h2><p>pprof是Go的性能分析工具，在程序运行过程中，可以记录程序的运行信息，可以是CPU使用情况、内存使用情况、goroutine运行情况等，当需要性能调优或者定位Bug时候，这些记录的信息是相当重要。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>使用pprof有多种方式，Go已经现成封装好了1个：<code>net/http/pprof</code>，使用简单的几行命令，就可以开启pprof，记录运行信息，并且提供了Web服务，能够通过浏览器和命令行2种方式获取运行数据。</p><p>看个最简单的pprof的例子：</p><p><em>文件：<a href="https://github.com/Shitaibin/golang_step_by_step/blob/master/pprof/pprof/demo.go">golang_step_by_step/pprof/pprof/demo.go</a></em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 开启pprof，监听请求</span></span><br><span class="line">ip := <span class="string">&quot;0.0.0.0:6060&quot;</span></span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(ip, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;start pprof failed on %s\n&quot;</span>, ip)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>提醒：本文所有代码部分可左右滑动</em></p><h3 id="浏览器方式"><a href="#浏览器方式" class="headerlink" title="浏览器方式"></a>浏览器方式</h3><p><img src="https://lessisbetter.site/images/2019-05-image-20190516173924325-7999564.png" alt="image-20190516173924325"></p><p>输入网址<code>ip:port/debug/pprof/</code>打开pprof主页，从上到下依次是<strong>5类profile信息</strong>：</p><ol><li><strong>block</strong>：goroutine的阻塞信息，本例就截取自一个goroutine阻塞的demo，但block为0，没掌握block的用法</li><li><strong>goroutine</strong>：所有goroutine的信息，下面的<code>full goroutine stack dump</code>是输出所有goroutine的调用栈，是goroutine的debug=2，后面会详细介绍。</li><li><strong>heap</strong>：堆内存的信息</li><li><strong>mutex</strong>：锁的信息</li><li><strong>threadcreate</strong>：线程信息</li></ol><p>这篇文章我们主要关注goroutine和heap，这两个都会打印调用栈信息，goroutine里面还会包含goroutine的数量信息，heap则是内存分配信息，本文用不到的地方就不展示了，最后推荐几篇文章大家去看。</p><h3 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h3><p>当连接在服务器终端上的时候，是没有浏览器可以使用的，Go提供了命令行的方式，能够获取以上5类信息，这种方式用起来更方便。</p><p>使用命令<code>go tool pprof url</code>可以获取指定的profile文件，此命令会发起http请求，然后下载数据到本地，之后进入交互式模式，就像gdb一样，可以使用命令查看运行信息，以下是5类请求的方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载cpu profile，默认从当前开始收集30s的cpu使用情况，需要等待30s</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/profile   <span class="comment"># 30-second CPU profile</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/profile?seconds=120     <span class="comment"># wait 120s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载heap profile</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/heap      <span class="comment"># heap profile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载goroutine profile</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/goroutine <span class="comment"># goroutine profile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载block profile</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/block     <span class="comment"># goroutine blocking profile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载mutex profile</span></span><br><span class="line">go tool pprof http://localhost:6060/debug/pprof/mutex</span><br></pre></td></tr></table></figure><p>上面的<code>pprof/demo.go</code>太简单了，如果去获取内存profile，几乎获取不到什么，换一个Demo进行内存profile的展示：</p><p><em>文件：<a href="https://github.com/Shitaibin/golang_step_by_step/blob/master/pprof/heap/demo2.go">golang_step_by_step/pprof/heap/demo2.go</a></em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 展示内存增长和pprof，并不是泄露</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行一段时间：fatal error: runtime: out of memory</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 开启pprof</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ip := <span class="string">&quot;0.0.0.0:6060&quot;</span></span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(ip, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;start pprof failed on %s\n&quot;</span>, ip)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">tick := time.Tick(time.Second / <span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> buf []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> tick &#123;</span><br><span class="line">buf = <span class="built_in">append</span>(buf, <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>)...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个demo会不断的申请内存，把它编译运行起来，然后执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:6060/debug/pprof/heap</span></span><br><span class="line"></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:6060/debug/pprof/heap</span></span><br><span class="line">Saved profile in /home/ubuntu/pprof/pprof.demo.alloc_objects.alloc_space.inuse_objects.inuse_space<span class="number">.001</span>.pb.gz       <span class="comment">//&lt;--- 下载到的内存profile文件</span></span><br><span class="line">File: demo <span class="comment">// 程序名称</span></span><br><span class="line">Build ID: a9069a125ee9c0df3713b2149ca859e8d4d11d5a</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">8</span>:<span class="number">55</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) help  <span class="comment">// 使用help打印所有可用命令</span></span><br><span class="line">  Commands:</span><br><span class="line">    callgrind        Outputs a graph in callgrind format</span><br><span class="line">    comments         Output all profile comments</span><br><span class="line">    disasm           Output assembly listings annotated with samples</span><br><span class="line">    dot              Outputs a graph in DOT format</span><br><span class="line">    eog              Visualize graph through eog</span><br><span class="line">    evince           Visualize graph through evince</span><br><span class="line">    gif              Outputs a graph image in GIF format</span><br><span class="line">    gv               Visualize graph through gv</span><br><span class="line">    kcachegrind      Visualize report in KCachegrind</span><br><span class="line">    list             Output annotated source <span class="keyword">for</span> functions matching regexp</span><br><span class="line">    pdf              Outputs a graph in PDF format</span><br><span class="line">    peek             Output callers/callees of functions matching regexp</span><br><span class="line">    png              Outputs a graph image in PNG format</span><br><span class="line">    proto            Outputs the profile in compressed protobuf format</span><br><span class="line">    ps               Outputs a graph in PS format</span><br><span class="line">    raw              Outputs a text representation of the raw profile</span><br><span class="line">    svg              Outputs a graph in SVG format</span><br><span class="line">    tags             Outputs all tags in the profile</span><br><span class="line">    text             Outputs top entries in text form</span><br><span class="line">    top              Outputs top entries in text form</span><br><span class="line">    topproto         Outputs top entries in compressed protobuf format</span><br><span class="line">    traces           Outputs all profile samples in text form</span><br><span class="line">    tree             Outputs a text rendering of call graph</span><br><span class="line">    web              Visualize graph through web browser</span><br><span class="line">    weblist          Display annotated source in a web browser</span><br><span class="line">    o/options        List options and their current values</span><br><span class="line">    quit/exit/^D     Exit pprof</span><br><span class="line">    </span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p>以上信息我们只关注2个地方：</p><ol><li>下载得到的文件：<code>/home/ubuntu/pprof/pprof.demo.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz</code>，这其中包含了程序名<code>demo</code>，profile类型<code>alloc</code>已分配的内存，<code>inuse</code>代表使用中的内存。</li><li><code>help</code>可以获取帮助，最先会列出支持的命令，想掌握pprof，要多看看，多尝试。</li></ol><p>关于命令，本文只会用到3个，我认为也是最常用的：<code>top</code>、<code>list</code>、<code>traces</code>，分别介绍一下。</p><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>按指标大小列出前10个函数，比如内存是按内存占用多少，CPU是按执行时间多少。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">814.62</span>MB, <span class="number">100</span>% of <span class="number">814.62</span>MB total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">  <span class="number">814.62</span>MB   <span class="number">100</span>%   <span class="number">100</span>%   <span class="number">814.62</span>MB   <span class="number">100</span>%  main.main</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%   <span class="number">814.62</span>MB   <span class="number">100</span>%  runtime.main</span><br></pre></td></tr></table></figure><p>top会列出5个统计数据：</p><ul><li>flat: 本函数占用的内存量。</li><li>flat%: 本函数内存占使用中内存总量的百分比。</li><li>sum%: 前面每一行flat百分比的和，比如第2行虽然的100% 是 100% + 0%。</li><li>cum: 是累计量，加入main函数调用了函数f，函数f占用的内存量，也会记进来。</li><li>cum%: 是累计量占总量的百分比。</li></ul><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>查看某个函数的代码，以及该函数每行代码的指标信息，如果函数名不明确，会进行模糊匹配，比如<code>list main</code>会列出<code>main.main</code>和<code>runtime.main</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(pprof) list main.main  <span class="comment">// 精确列出函数</span></span><br><span class="line">Total: <span class="number">814.62</span>MB</span><br><span class="line">ROUTINE ======================== main.main in /home/ubuntu/heap/demo2.<span class="keyword">go</span></span><br><span class="line">  <span class="number">814.62</span>MB   <span class="number">814.62</span>MB (flat, cum)   <span class="number">100</span>% of Total</span><br><span class="line">         .          .     <span class="number">20</span>:&#125;()</span><br><span class="line">         .          .     <span class="number">21</span>:</span><br><span class="line">         .          .     <span class="number">22</span>:tick := time.Tick(time.Second / <span class="number">100</span>)</span><br><span class="line">         .          .     <span class="number">23</span>:<span class="keyword">var</span> buf []<span class="keyword">byte</span></span><br><span class="line">         .          .     <span class="number">24</span>:<span class="keyword">for</span> <span class="keyword">range</span> tick &#123;</span><br><span class="line">  <span class="number">814.62</span>MB   <span class="number">814.62</span>MB     <span class="number">25</span>:buf = <span class="built_in">append</span>(buf, <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>)...)</span><br><span class="line">         .          .     <span class="number">26</span>:&#125;</span><br><span class="line">         .          .     <span class="number">27</span>:&#125;</span><br><span class="line">         .          .     <span class="number">28</span>:</span><br><span class="line">(pprof) list main  <span class="comment">// 匹配所有函数名带main的函数</span></span><br><span class="line">Total: <span class="number">814.62</span>MB</span><br><span class="line">ROUTINE ======================== main.main in /home/ubuntu/heap/demo2.<span class="keyword">go</span></span><br><span class="line">  <span class="number">814.62</span>MB   <span class="number">814.62</span>MB (flat, cum)   <span class="number">100</span>% of Total</span><br><span class="line">         .          .     <span class="number">20</span>:&#125;()</span><br><span class="line">         .          .     <span class="number">21</span>:</span><br><span class="line">..... <span class="comment">// 省略几行</span></span><br><span class="line">         .          .     <span class="number">28</span>:</span><br><span class="line">ROUTINE ======================== runtime.main in /usr/lib/<span class="keyword">go</span><span class="number">-1.10</span>/src/runtime/proc.<span class="keyword">go</span></span><br><span class="line">         <span class="number">0</span>   <span class="number">814.62</span>MB (flat, cum)   <span class="number">100</span>% of Total</span><br><span class="line">         .          .    <span class="number">193</span>:<span class="comment">// A program compiled with -buildmode=c-archive or c-shared</span></span><br><span class="line">..... <span class="comment">// 省略几行</span></span><br></pre></td></tr></table></figure><p>可以看到在<code>main.main</code>中的第25行占用了814.62MB内存，左右2个数据分别是flat和cum，含义和top中解释的一样。</p><h4 id="traces"><a href="#traces" class="headerlink" title="traces"></a>traces</h4><p>打印所有调用栈，以及调用栈的指标信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(pprof) traces</span><br><span class="line">File: demo2</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">7</span>:<span class="number">08</span>pm (CST)</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">     bytes:  <span class="number">813.46</span>MB</span><br><span class="line">  <span class="number">813.46</span>MB   main.main</span><br><span class="line">             runtime.main</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">     bytes:  <span class="number">650.77</span>MB</span><br><span class="line">         <span class="number">0</span>   main.main</span><br><span class="line">             runtime.main</span><br><span class="line">....... <span class="comment">// 省略几十行</span></span><br></pre></td></tr></table></figure><p>每个<code>- - - - -</code> 隔开的是一个调用栈，能看到<code>runtime.main</code>调用了<code>main.main</code>，并且<code>main.main</code>中占用了813.46MB内存。</p><p>其他的profile操作和内存是类似的，这里就不展示了。</p><p>这里只是简单介绍本文用到的pprof的功能，pprof功能很强大，也经常和benchmark结合起来，但这不是本文的重点，所以就不多介绍了，为大家推荐几篇文章，一定要好好研读、实践：</p><ol><li>Go官方博客关于pprof的介绍，很详细，也包含样例，可以实操：<a href="https://blog.golang.org/profiling-go-programs">Profiling Go Programs</a>。</li><li>跟煎鱼也讨论过pprof，煎鱼的这篇文章也很适合入门： <a href="https://github.com/EDDYCJY/blog/blob/master/golang/2018-09-15-Golang%20%E5%A4%A7%E6%9D%80%E5%99%A8%E4%B9%8B%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90%20PProf.md">Golang 大杀器之性能剖析 PProf</a>。</li></ol><hr><h1 id="什么是内存泄露"><a href="#什么是内存泄露" class="headerlink" title="什么是内存泄露"></a>什么是内存泄露</h1><p>内存泄露指的是程序运行过程中已不再使用的内存，没有被释放掉，导致这些内存无法被使用，直到程序结束这些内存才被释放的问题。</p><p>Go虽然有GC来回收不再使用的堆内存，减轻了开发人员对内存的管理负担，但这并不意味着Go程序不再有内存泄露问题。在Go程序中，如果没有Go语言的编程思维，也不遵守良好的编程实践，就可能埋下隐患，造成内存泄露问题。</p><h1 id="怎么发现内存泄露"><a href="#怎么发现内存泄露" class="headerlink" title="怎么发现内存泄露"></a>怎么发现内存泄露</h1><p>在Go中发现内存泄露有2种方法，一个是通用的监控工具，另一个是go pprof：</p><ol><li><strong>监控工具</strong>：固定周期对进程的内存占用情况进行采样，数据可视化后，根据内存占用走势（持续上升），很容易发现是否发生内存泄露。</li><li><strong>go pprof</strong>：适合没有监控工具的情况，使用Go提供的pprof工具判断是否发生内存泄露。</li></ol><p>这2种方式分别介绍一下。</p><h2 id="监控工具查看进程内在占用情况"><a href="#监控工具查看进程内在占用情况" class="headerlink" title="监控工具查看进程内在占用情况"></a>监控工具查看进程内在占用情况</h2><p><strong>如果使用云平台部署Go程序</strong>，云平台都提供了内存查看的工具，可以查看OS的内存占用情况和某个进程的内存占用情况，比如阿里云，我们在1个云主机上只部署了1个Go服务，所以OS的内存占用情况，基本是也反映了进程内存占用情况，OS内存占用情况如下，可以看到<strong>随着时间的推进，内存的占用率在不断的提高，这是内存泄露的最明显现象</strong>：</p><p><img src="https://lessisbetter.site/images/2019-05-image-20190512111200988-7630721.png" alt="image-20190512111200988"></p><p><strong>如果没有云平台这种内存监控工具，可以制作一个简单的内存记录工具。</strong></p><p>1、建立一个脚本<code>prog_mem.sh</code>，获取进程占用的物理内存情况，脚本内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">prog_name=<span class="string">&quot;your_programe_name&quot;</span></span><br><span class="line">prog_mem=$(pidstat  -r -u -h -C <span class="variable">$prog_name</span> |awk <span class="string">&#x27;NR==4&#123;print $12&#125;&#x27;</span>)</span><br><span class="line">time=$(date <span class="string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$time</span><span class="string">&quot;\tmemory(Byte)\t&quot;</span><span class="variable">$prog_mem</span> &gt;&gt;~/record/prog_mem.log</span><br></pre></td></tr></table></figure><p>2、然后使用<code>crontab</code>建立定时任务，每分钟记录1次。使用<code>crontab -e</code>编辑crontab配置，在最后增加1行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * ~/record/prog_mem.sh</span><br></pre></td></tr></table></figure><p>脚本输出的内容保存在<code>prog_mem.log</code>，只要大体浏览一下就可以发现内存的增长情况，判断是否存在内存泄露。如果需要可视化，可以直接黏贴<code>prog_mem.log</code>内容到Excel等表格工具，绘制内存占用图。</p><p><img src="https://lessisbetter.site/images/2019-05-image-20190512172935195-7653375.png" alt="image-20190512172935195"></p><h2 id="go-pprof发现存在内存问题"><a href="#go-pprof发现存在内存问题" class="headerlink" title="go pprof发现存在内存问题"></a>go pprof发现存在内存问题</h2><blockquote><p>有情提醒：如果对pprof不了解，可以先看[go pprof基本知识](#go pprof基本知识)，这是下一节，看完再倒回来看。</p></blockquote><p>如果你Google或者百度，Go程序内存泄露的文章，它总会告诉你使用<strong>pprof heap</strong>，能够生成漂亮的调用路径图，火焰图等等，然后你根据调用路径就能定位内存泄露问题，我最初也是对此深信不疑，尝试了若干天后，只是发现内存泄露跟某种场景有关，根本找不到内存泄露的根源，<strong>如果哪位朋友用heap就能定位内存泄露的线上问题，麻烦介绍下</strong>。</p><p>后来读了Dave的<a href="https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html#using_more_than_one_cpu">《High Performance Go Workshop》</a>，刷新了对heap的认识，内存pprof的简要内容如下：</p><p><img src="https://lessisbetter.site/images/2019-05-image-20190512114048868-7632448.png" alt="image-20190512114048868"></p><p>Dave讲了以下几点：</p><ol><li><strong>内存profiling记录的是堆内存分配的情况，以及调用栈信息</strong>，并不是进程完整的内存情况，猜测这也是在go pprof中称为heap而不是memory的原因。</li><li><strong>栈内存的分配是在调用栈结束后会被释放的内存，所以并不在内存profile中</strong>。</li><li>内存profiling是基于抽样的，默认是每1000次堆内存分配，执行1次profile记录。</li><li>因为内存profiling是基于抽样和它跟踪的是已分配的内存，而不是使用中的内存，（比如有些内存已经分配，看似使用，但实际以及不使用的内存，比如内存泄露的那部分），所以<strong>不能使用内存profiling衡量程序总体的内存使用情况</strong>。</li><li><strong>Dave个人观点：使用内存profiling不能够发现内存泄露</strong>。</li></ol><p>基于目前对heap的认知，我有2个观点：</p><ol><li><strong>heap能帮助我们发现内存问题，但不一定能发现内存泄露问题</strong>，这个看法与Dave是类似的。heap记录了内存分配的情况，我们能通过heap观察内存的变化，增长与减少，内存主要被哪些代码占用了，程序存在内存问题，这只能说明内存有使用不合理的地方，但并不能说明这是内存泄露。</li><li><strong>heap在帮助定位内存泄露原因上贡献的力量微乎其微</strong>。如第一条所言，能通过heap找到占用内存多的位置，但这个位置通常不一定是内存泄露，就算是内存泄露，也只是内存泄露的结果，并不是真正导致内存泄露的根源。</li></ol><p>接下来，我介绍怎么用heap发现问题，然后再解释为什么heap几乎不能定位内存泄露的根因。</p><h3 id="怎么用heap发现内存问题"><a href="#怎么用heap发现内存问题" class="headerlink" title="怎么用heap发现内存问题"></a>怎么用heap发现内存问题</h3><p>使用pprof的heap能够获取程序运行时的内存信息，在程序平稳运行的情况下，每个一段时间使用heap获取内存的profile，<strong>然后使用<code>base</code>能够对比两个profile文件的差别，就像<code>diff</code>命令一样显示出增加和减少的变化</strong>，使用一个简单的demo来说明heap和base的使用，依然使用demo2进行展示。</p><p><em>文件：<a href="https://github.com/Shitaibin/golang_step_by_step/blob/master/pprof/heap/demo2.go">golang_step_by_step/pprof/heap/demo2.go</a></em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 展示内存增长和pprof，并不是泄露</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行一段时间：fatal error: runtime: out of memory</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 开启pprof</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ip := <span class="string">&quot;0.0.0.0:6060&quot;</span></span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(ip, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;start pprof failed on %s\n&quot;</span>, ip)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">tick := time.Tick(time.Second / <span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> buf []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> tick &#123;</span><br><span class="line">buf = <span class="built_in">append</span>(buf, <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>)...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面代码运行起来，执行以下命令获取profile文件，Ctrl-D退出，1分钟后再获取1次。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof http://localhost:6060/debug/pprof/heap</span><br></pre></td></tr></table></figure><p>我已经获取到了两个profile文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz</span><br><span class="line">pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space.002.pb.gz</span><br></pre></td></tr></table></figure><p>使用<code>base</code>把001文件作为基准，然后用002和001对比，先执行<code>top</code>看<code>top</code>的对比，然后执行<code>list main</code>列出<code>main</code>函数的内存对比，结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> tool pprof -base pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space<span class="number">.001</span>.pb.gz pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space<span class="number">.002</span>.pb.gz</span><br><span class="line"></span><br><span class="line">File: demo2</span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: May <span class="number">14</span>, <span class="number">2019</span> at <span class="number">2</span>:<span class="number">33</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">970.34</span>MB, <span class="number">32.30</span>% of <span class="number">3003.99</span>MB total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">  <span class="number">970.34</span>MB <span class="number">32.30</span>% <span class="number">32.30</span>%   <span class="number">970.34</span>MB <span class="number">32.30</span>%  main.main   <span class="comment">// 看这</span></span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>% <span class="number">32.30</span>%   <span class="number">970.34</span>MB <span class="number">32.30</span>%  runtime.main</span><br><span class="line">(pprof)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) list main.main</span><br><span class="line">Total: <span class="number">2.93</span>GB</span><br><span class="line">ROUTINE ======================== main.main in /home/ubuntu/heap/demo2.<span class="keyword">go</span></span><br><span class="line">  <span class="number">970.34</span>MB   <span class="number">970.34</span>MB (flat, cum) <span class="number">32.30</span>% of Total</span><br><span class="line">         .          .     <span class="number">20</span>:&#125;()</span><br><span class="line">         .          .     <span class="number">21</span>:</span><br><span class="line">         .          .     <span class="number">22</span>:tick := time.Tick(time.Second / <span class="number">100</span>)</span><br><span class="line">         .          .     <span class="number">23</span>:<span class="keyword">var</span> buf []<span class="keyword">byte</span></span><br><span class="line">         .          .     <span class="number">24</span>:<span class="keyword">for</span> <span class="keyword">range</span> tick &#123;</span><br><span class="line">  <span class="number">970.34</span>MB   <span class="number">970.34</span>MB     <span class="number">25</span>:buf = <span class="built_in">append</span>(buf, <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>)...) <span class="comment">// 看这</span></span><br><span class="line">         .          .     <span class="number">26</span>:&#125;</span><br><span class="line">         .          .     <span class="number">27</span>:&#125;</span><br><span class="line">         .          .     <span class="number">28</span>:</span><br></pre></td></tr></table></figure><p><code>top</code>列出了<code>main.main</code>和<code>runtime.main</code>，<code>main.main</code>就是我们编写的main函数，<code>runtime.main</code>是runtime包中的main函数，也就是所有main函数的入口，这里不多介绍了，有兴趣可以看之前的调度器文章<a href="http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/">《Go调度器系列（2）宏观看调度器》</a>。</p><p><code>top</code>显示<code>main.main</code> 第2次内存占用，比第1次内存占用多了970.34MB。</p><p><code>list main.main</code>告诉了我们增长的内存都在这一行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf = <span class="built_in">append</span>(buf, <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>)...)</span><br></pre></td></tr></table></figure><p>001和002 profile的文件不进去看了，你本地测试下计算差值，绝对是刚才对比出的970.34MB。</p><h3 id="heap“不能”定位内存泄露"><a href="#heap“不能”定位内存泄露" class="headerlink" title="heap“不能”定位内存泄露"></a>heap“不能”定位内存泄露</h3><p>heap能显示内存的分配情况，以及哪行代码占用了多少内存，我们能轻易的找到占用内存最多的地方，如果这个地方的数值还在不断怎大，基本可以认定这里就是内存泄露的位置。</p><p>曾想按图索骥，从内存泄露的位置，根据调用栈向上查找，总能找到内存泄露的原因，这种方案看起来是不错的，但实施起来却找不到内存泄露的原因，结果是事半功倍。</p><p>原因在于一个Go程序，其中有大量的goroutine，这其中的调用关系也许有点复杂，也许内存泄露是在某个三方包里。举个栗子，比如下面这幅图，每个椭圆代表1个goroutine，其中的数字为编号，箭头代表调用关系。heap profile显示g111（最下方标红节点）这个协程的代码出现了泄露，任何一个从g101到g111的调用路径都可能造成了g111的内存泄露，有2类可能：</p><ol><li>该goroutine只调用了少数几次，但消耗了大量的内存，说明每个goroutine调用都消耗了不少内存，<strong>内存泄露的原因基本就在该协程内部</strong>。</li><li>该goroutine的调用次数非常多，虽然每个协程调用过程中消耗的内存不多，但该调用路径上，协程数量巨大，造成消耗大量的内存，并且这些goroutine由于某种原因无法退出，占用的内存不会释放，<strong>内存泄露的原因在到g111调用路径上某段代码实现有问题，造成创建了大量的g111</strong>。</li></ol><p><strong>第2种情况，就是goroutine泄露，这是通过heap无法发现的，所以heap在定位内存泄露这件事上，发挥的作用不大</strong>。</p><p><img src="https://lessisbetter.site/images/2019-05-image-20190512144150064-7643310.png" alt="image-20190512144150064"></p><hr><h1 id="goroutine泄露怎么导致内存泄露"><a href="#goroutine泄露怎么导致内存泄露" class="headerlink" title="goroutine泄露怎么导致内存泄露"></a>goroutine泄露怎么导致内存泄露</h1><h2 id="什么是goroutine泄露"><a href="#什么是goroutine泄露" class="headerlink" title="什么是goroutine泄露"></a>什么是goroutine泄露</h2><p>如果你启动了1个goroutine，但并没有符合预期的退出，直到程序结束，此goroutine才退出，这种情况就是goroutine泄露。</p><blockquote><p>提前思考：什么会导致goroutine无法退出/阻塞？</p></blockquote><h2 id="goroutine泄露怎么导致内存泄露-1"><a href="#goroutine泄露怎么导致内存泄露-1" class="headerlink" title="goroutine泄露怎么导致内存泄露"></a>goroutine泄露怎么导致内存泄露</h2><p>每个goroutine占用2KB内存，泄露1百万goroutine至少泄露<code>2KB * 1000000 = 2GB</code>内存，为什么说至少呢？</p><p>goroutine执行过程中还存在一些变量，如果这些变量指向堆内存中的内存，GC会认为这些内存仍在使用，不会对其进行回收，这些内存谁都无法使用，造成了内存泄露。</p><p>所以goroutine泄露有2种方式造成内存泄露：</p><ol><li>goroutine本身的栈所占用的空间造成内存泄露。</li><li>goroutine中的变量所占用的堆内存导致堆内存泄露，这一部分是能通过heap profile体现出来的。</li></ol><p>Dave在文章中也提到了，如果不知道何时停止一个goroutine，这个goroutine就是潜在的内存泄露：</p><blockquote><p><a href="https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html#know_when_to_stop_a_goroutine">7.1.1 Know when to stop a goroutine</a></p><p>If you don’t know the answer, that’s a potential memory leak as the goroutine will pin its stack’s memory on the heap, as well as any heap allocated variables reachable from the stack.</p></blockquote><h2 id="怎么确定是goroutine泄露引发的内存泄露"><a href="#怎么确定是goroutine泄露引发的内存泄露" class="headerlink" title="怎么确定是goroutine泄露引发的内存泄露"></a>怎么确定是goroutine泄露引发的内存泄露</h2><p>掌握了前面的pprof命令行的基本用法，很快就可以确认是否是goroutine泄露导致内存泄露，如果你不记得了，马上回去看一下[go pprof基本知识](#go pprof基本知识)。</p><p><strong>判断依据：在节点正常运行的情况下，隔一段时间获取goroutine的数量，如果后面获取的那次，某些goroutine比前一次多，如果多获取几次，是持续增长的，就极有可能是goroutine泄露</strong>。</p><p>goroutine导致内存泄露的demo：</p><p><em>文件：<a href="https://github.com/Shitaibin/golang_step_by_step/blob/master/pprof/goroutine/leak_demo1.go">golang_step_by_step/pprof/goroutine/leak_demo1.go</a></em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// goroutine泄露导致内存泄露</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 开启pprof</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ip := <span class="string">&quot;0.0.0.0:6060&quot;</span></span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(ip, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;start pprof failed on %s\n&quot;</span>, ip)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">outCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 死代码，永不读取</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">&lt;-outCh</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每s起100个goroutine，goroutine会阻塞，不释放内存</span></span><br><span class="line">tick := time.Tick(time.Second / <span class="number">100</span>)</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> tick &#123;</span><br><span class="line">i++</span><br><span class="line">fmt.Println(i)</span><br><span class="line">alloc1(outCh)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alloc1</span><span class="params">(outCh <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> alloc2(outCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alloc2</span><span class="params">(outCh <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;alloc-fm exit&quot;</span>)</span><br><span class="line"><span class="comment">// 分配内存，假用一下</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>)</span><br><span class="line">_ = <span class="built_in">len</span>(buf)</span><br><span class="line">fmt.Println(<span class="string">&quot;alloc done&quot;</span>)</span><br><span class="line"></span><br><span class="line">outCh &lt;- <span class="number">0</span> <span class="comment">// 53行</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行以上代码，然后使用<code>go tool pprof</code>获取gorourine的profile文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool pprof http:&#x2F;&#x2F;localhost:6060&#x2F;debug&#x2F;pprof&#x2F;goroutine</span><br></pre></td></tr></table></figure><p>已经通过pprof命令获取了2个goroutine的profile文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">/home/ubuntu/pprof/pprof.leak_demo.goroutine.001.pb.gz</span><br><span class="line">/home/ubuntu/pprof/pprof.leak_demo.goroutine.002.pb.gz</span><br></pre></td></tr></table></figure><p>同heap一样，我们可以使用<code>base</code>对比2个goroutine profile文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">go</span> tool pprof -base pprof.leak_demo.goroutine<span class="number">.001</span>.pb.gz pprof.leak_demo.goroutine<span class="number">.002</span>.pb.gz</span><br><span class="line"></span><br><span class="line">File: leak_demo</span><br><span class="line">Type: goroutine</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">2</span>:<span class="number">44</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">20312</span>, <span class="number">100</span>% of <span class="number">20312</span> total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">     <span class="number">20312</span>   <span class="number">100</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.gopark</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  main.alloc2</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  main.alloc2.func1</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.chansend</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.chansend1</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.goparkunlock</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure><p>可以看到运行到<code>runtime.gopark</code>的goroutine数量增加了20312个。再通过002文件，看一眼执行到<code>gopark</code>的goroutine数量，即挂起的goroutine数量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> tool pprof pprof.leak_demo.goroutine<span class="number">.002</span>.pb.gz</span><br><span class="line">File: leak_demo</span><br><span class="line">Type: goroutine</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">2</span>:<span class="number">47</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">24330</span>, <span class="number">100</span>% of <span class="number">24331</span> total</span><br><span class="line">Dropped <span class="number">32</span> nodes (cum &lt;= <span class="number">121</span>)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">     <span class="number">24330</span>   <span class="number">100</span>%   <span class="number">100</span>%      <span class="number">24330</span>   <span class="number">100</span>%  runtime.gopark</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">24326</span>   <span class="number">100</span>%  main.alloc2</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">24326</span>   <span class="number">100</span>%  main.alloc2.func1</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">24326</span>   <span class="number">100</span>%  runtime.chansend</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">24326</span>   <span class="number">100</span>%  runtime.chansend1</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">24327</span>   <span class="number">100</span>%  runtime.goparkunlock</span><br></pre></td></tr></table></figure><p>显示有24330个goroutine被挂起，这不是goroutine泄露这是啥？已经能确定八九成goroutine泄露了。</p><p>是什么导致如此多的goroutine被挂起而无法退出？接下来就看怎么定位goroutine泄露。</p><hr><h1 id="定位goroutine泄露的2种方法"><a href="#定位goroutine泄露的2种方法" class="headerlink" title="定位goroutine泄露的2种方法"></a>定位goroutine泄露的2种方法</h1><p>使用pprof有2种方式，一种是web网页，一种是<code>go tool pprof</code>命令行交互，这两种方法查看goroutine都支持，但有轻微不同，也有各自的优缺点。</p><p>我们先看Web的方式，再看命令行交互的方式，这两种都很好使用，结合起来用也不错。</p><h2 id="Web可视化查看"><a href="#Web可视化查看" class="headerlink" title="Web可视化查看"></a>Web可视化查看</h2><p>Web方式适合web服务器的端口能访问的情况，使用起来方便，有2种方式：</p><ol><li><strong>查看某条调用路径上，当前阻塞在此goroutine的数量</strong></li><li>查看所有goroutine的运行栈（调用路径），可以<strong>显示阻塞在此的时间</strong></li></ol><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>url请求中设置debug=1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ip:port&#x2F;debug&#x2F;pprof&#x2F;goroutine?debug&#x3D;1</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://lessisbetter.site/images/2019-05-image-20190516143740567-7988660.png"></p><p>看起来密密麻麻的，其实简单又十分有用，看上图标出来的部分，手机上图看起来可能不方便，那就放大图片，或直接看下面各字段的含义：</p><ol><li><code>goroutine profile: total 32023</code>：32023是<strong>goroutine的总数量</strong>，</li><li><code>32015 @ 0x42e15a 0x42e20e 0x40534b 0x4050e5 ...</code>：32015代表当前有32015个goroutine运行这个调用栈，并且停在相同位置，@后面的十六进制，现在用不到这个数据，所以暂不深究了。</li><li>下面是当前goroutine的<strong>调用栈</strong>，列出了<strong>函数和所在文件的行数，这个行数对定位很有帮助</strong>，如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">32015 @ 0x42e15a 0x42e20e 0x40534b 0x4050e5 0x6d8559 0x6d831b 0x45abe1</span><br><span class="line">#0x6d8558main.alloc2.func1+0xf8&#x2F;home&#x2F;ubuntu&#x2F;heap&#x2F;leak_demo.go:53</span><br><span class="line">#0x6d831amain.alloc2+0x2a&#x2F;home&#x2F;ubuntu&#x2F;heap&#x2F;leak_demo.go:54</span><br></pre></td></tr></table></figure><p>根据上面的提示，就能判断32015个goroutine运行到<code>leak_demo.go</code>的53行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alloc2</span><span class="params">(outCh <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;alloc-fm exit&quot;</span>)</span><br><span class="line"><span class="comment">// 分配内存，假用一下</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>)</span><br><span class="line">_ = <span class="built_in">len</span>(buf)</span><br><span class="line">fmt.Println(<span class="string">&quot;alloc done&quot;</span>)</span><br><span class="line"></span><br><span class="line">outCh &lt;- <span class="number">0</span> <span class="comment">// 53行</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻塞的原因是outCh这个写操作无法完成，outCh是无缓冲的通道，并且由于以下代码是死代码，所以goroutine始终没有从outCh读数据，造成outCh阻塞，进而造成无数个alloc2的goroutine阻塞，形成内存泄露：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">    &lt;-outCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>url请求中设置debug=2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ip:port&#x2F;debug&#x2F;pprof&#x2F;goroutine?debug&#x3D;2</span><br></pre></td></tr></table></figure><p><img src="https://lessisbetter.site/images/2019-05-image-20190516143537339-7988537.png"></p><p>第2种方式和第1种方式是互补的，它可以看到每个goroutine的信息：</p><ol><li><code>goroutine 20 [chan send, 2 minutes]</code>：20是goroutine id，<code>[]</code>中是当前goroutine的状态，阻塞在写channel，并且阻塞了2分钟，长时间运行的系统，你能看到阻塞时间更长的情况。</li><li>同时，也可以看到调用栈，看当前执行停到哪了：<code>leak_demo.go</code>的53行，</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goroutine <span class="number">20</span> [<span class="keyword">chan</span> send, <span class="number">2</span> minutes]:</span><br><span class="line">main.alloc2.func1(<span class="number">0xc42015e060</span>)</span><br><span class="line">/home/ubuntu/heap/leak_demo.<span class="keyword">go</span>:<span class="number">53</span> +<span class="number">0xf9</span>  <span class="comment">// 这</span></span><br><span class="line">main.alloc2(<span class="number">0xc42015e060</span>)</span><br><span class="line">/home/ubuntu/heap/leak_demo.<span class="keyword">go</span>:<span class="number">54</span> +<span class="number">0x2b</span></span><br><span class="line">created by main.alloc1</span><br><span class="line">/home/ubuntu/heap/leak_demo.<span class="keyword">go</span>:<span class="number">42</span> +<span class="number">0x3f</span></span><br></pre></td></tr></table></figure><h2 id="命令行交互式方法"><a href="#命令行交互式方法" class="headerlink" title="命令行交互式方法"></a>命令行交互式方法</h2><p>Web的方法是简单粗暴，无需登录服务器，浏览器打开看看就行了。但就像前面提的，没有浏览器可访问时，命令行交互式才是最佳的方式，并且也是手到擒来，感觉比Web一样方便。</p><p>命令行交互式只有1种获取goroutine profile的方法，不像Web网页分<code>debug=1</code>和<code>debug=2</code>2中方式，并将profile文件保存到本地：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意命令没有`debug=1`，debug=1，加debug有些版本的go不支持</span></span><br><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//0.0.0.0:6060/debug/pprof/goroutine</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:6061/debug/pprof/goroutine</span></span><br><span class="line">Saved profile in /home/ubuntu/pprof/pprof.leak_demo.goroutine<span class="number">.001</span>.pb.gz  <span class="comment">// profile文件保存位置</span></span><br><span class="line">File: leak_demo</span><br><span class="line">Type: goroutine</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">2</span>:<span class="number">44</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure><p>命令行只需要掌握3个命令就好了，上面介绍过了，详细的倒回去看<a href="#top">top</a>, <a href="#list">list</a>, <a href="#traces">traces</a>：</p><ol><li><strong>top</strong>：显示正运行到某个函数goroutine的数量</li><li><strong>traces</strong>：显示所有goroutine的调用栈</li><li><strong>list</strong>：列出代码详细的信息。</li></ol><p>我们依然使用<code>leak_demo.go</code>这个demo，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$  <span class="keyword">go</span> tool pprof -base pprof.leak_demo.goroutine<span class="number">.001</span>.pb.gz pprof.leak_demo.goroutine<span class="number">.002</span>.pb.gz</span><br><span class="line">File: leak_demo</span><br><span class="line">Type: goroutine</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">2</span>:<span class="number">44</span>pm (CST)</span><br><span class="line">Entering interactive mode (<span class="keyword">type</span> <span class="string">&quot;help&quot;</span> <span class="keyword">for</span> commands, <span class="string">&quot;o&quot;</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">20312</span>, <span class="number">100</span>% of <span class="number">20312</span> total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">     <span class="number">20312</span>   <span class="number">100</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.gopark</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  main.alloc2</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  main.alloc2.func1</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.chansend</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.chansend1</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%   <span class="number">100</span>%      <span class="number">20312</span>   <span class="number">100</span>%  runtime.goparkunlock</span><br><span class="line">(pprof)</span><br><span class="line">(pprof) traces</span><br><span class="line">File: leak_demo</span><br><span class="line">Type: goroutine</span><br><span class="line">Time: May <span class="number">16</span>, <span class="number">2019</span> at <span class="number">2</span>:<span class="number">44</span>pm (CST)</span><br><span class="line">-----------+-------------------------------------------------------</span><br><span class="line">     <span class="number">20312</span>   runtime.gopark</span><br><span class="line">             runtime.goparkunlock</span><br><span class="line">             runtime.chansend</span><br><span class="line">             runtime.chansend1 <span class="comment">// channel发送</span></span><br><span class="line">             main.alloc2.func1 <span class="comment">// alloc2中的匿名函数</span></span><br><span class="line">             main.alloc2</span><br><span class="line">-----------+-------------------------------------------------------</span><br></pre></td></tr></table></figure><p>top命令在<a href="#%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%E6%98%AFgoroutine%E6%B3%84%E9%9C%B2%E5%BC%95%E5%8F%91%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2">怎么确定是goroutine泄露引发的内存泄露</a>介绍过了，直接看traces命令，traces能列出002中比001中多的那些goroutine的调用栈，这里只有1个调用栈，有20312个goroutine都执行这个调用路径，可以看到alloc2中的匿名函数<code>alloc2.func1</code>调用了写channel的操作，然后阻塞挂起了goroutine，使用list列出<code>alloc2.func1</code>的代码，显示有20312个goroutine阻塞在53行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(pprof) list main.alloc2.func1</span><br><span class="line">Total: <span class="number">20312</span></span><br><span class="line">ROUTINE ======================== main.alloc2.func1 in /home/ubuntu/heap/leak_demo.<span class="keyword">go</span></span><br><span class="line">         <span class="number">0</span>      <span class="number">20312</span> (flat, cum)   <span class="number">100</span>% of Total</span><br><span class="line">         .          .     <span class="number">48</span>:<span class="comment">// 分配内存，假用一下</span></span><br><span class="line">         .          .     <span class="number">49</span>:buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">10</span>)</span><br><span class="line">         .          .     <span class="number">50</span>:_ = <span class="built_in">len</span>(buf)</span><br><span class="line">         .          .     <span class="number">51</span>:fmt.Println(<span class="string">&quot;alloc done&quot;</span>)</span><br><span class="line">         .          .     <span class="number">52</span>:</span><br><span class="line">         .      <span class="number">20312</span>     <span class="number">53</span>:outCh &lt;- <span class="number">0</span>  <span class="comment">// 看这</span></span><br><span class="line">         .          .     <span class="number">54</span>:&#125;()</span><br><span class="line">         .          .     <span class="number">55</span>:&#125;</span><br><span class="line">         .          .     <span class="number">56</span>:</span><br></pre></td></tr></table></figure><p><strong>友情提醒：使用list命令的前提是程序的源码在当前机器，不然可没法列出源码。</strong>服务器上，通常没有源码，那我们咋办呢？刚才介绍了Web查看的方式，那里会列出代码行数，我们可以使用<code>wget</code>下载网页：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://localhost:6060/debug/pprof/goroutine?debug=1</span><br></pre></td></tr></table></figure><p>下载网页后，使用编辑器打开文件，使用关键字<code>main.alloc2.func1</code>进行搜索，找到与当前相同的调用栈，就可以看到该goroutine阻塞在哪一行了，不要忘记使用<code>debug=2</code>还可以看到阻塞了多久和原因，Web方式中已经介绍了，此处省略代码几十行。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>文章略长，但全是干货，感谢阅读到这。然读到着了，跟定很想掌握pprof，建议实践一把，现在和大家温习一把本文的主要内容。</p><h2 id="goroutine泄露的本质"><a href="#goroutine泄露的本质" class="headerlink" title="goroutine泄露的本质"></a>goroutine泄露的本质</h2><p>goroutine泄露的本质是channel阻塞，无法继续向下执行，导致此goroutine关联的内存都无法释放，进一步造成内存泄露。</p><h2 id="goroutine泄露的发现和定位"><a href="#goroutine泄露的发现和定位" class="headerlink" title="goroutine泄露的发现和定位"></a>goroutine泄露的发现和定位</h2><p>利用好go pprof获取goroutine profile文件，然后利用3个命令top、traces、list定位内存泄露的原因。</p><h2 id="goroutine泄露的场景"><a href="#goroutine泄露的场景" class="headerlink" title="goroutine泄露的场景"></a>goroutine泄露的场景</h2><p>泄露的场景不仅限于以下两类，但因channel相关的泄露是最多的。</p><ol><li>channel的读或者写：<ol><li>无缓冲channel的阻塞通常是写操作因为没有读而阻塞</li><li>有缓冲的channel因为缓冲区满了，写操作阻塞</li><li>期待从channel读数据，结果没有goroutine写</li></ol></li><li>select操作，select里也是channel操作，如果所有case上的操作阻塞，goroutine也无法继续执行。</li></ol><h2 id="编码goroutine泄露的建议"><a href="#编码goroutine泄露的建议" class="headerlink" title="编码goroutine泄露的建议"></a>编码goroutine泄露的建议</h2><p>为避免goroutine泄露造成内存泄露，启动goroutine前要思考清楚：</p><ol><li>goroutine如何退出？</li><li>是否会有阻塞造成无法退出？如果有，那么这个路径是否会创建大量的goroutine？</li></ol><h1 id="示例源码"><a href="#示例源码" class="headerlink" title="示例源码"></a>示例源码</h1><p><strong>本文所有示例源码，及历史文章、代码都存储在Github，阅读原文可直接跳转</strong>，Github：<a href="https://github.com/Shitaibin/golang_step_by_step/tree/master/pprof">https://github.com/Shitaibin/golang_step_by_step/tree/master/pprof</a> 。</p><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p>这些既是参考资料也是推荐阅读的文章，不容错过。</p><p>【Go Blog关于pprof详细介绍和Demo】 <a href="https://blog.golang.org/profiling-go-programs">https://blog.golang.org/profiling-go-programs</a></p><p>【Dave关于高性能Go程序的workshop】 <a href="https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html#using_more_than_one_cpu">https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html#using_more_than_one_cpu</a></p><p>【煎鱼pprof文章，很适合入门 Golang大杀器之性能剖析PProf】 <a href="https://segmentfault.com/a/1190000016412013">https://segmentfault.com/a/1190000016412013</a></p><p>【SO上goroutine调用栈各字段的介绍】<a href="https://stackoverflow.com/a/38414527/4296218">https://stackoverflow.com/a/38414527/4296218</a></p><p>【我的老文，有runtime.main的介绍，想学习调度器，可以看下系列文章 Go调度器系列（2）宏观看调度器】<a href="http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/">http://lessisbetter.site/2019/03/26/golang-scheduler-2-macro-view/</a></p><blockquote><ol><li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li><li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li><li>如果喜欢本文，随意转载，但请保留此原文链接：<a href="http://lessisbetter.site/2019/05/18/go-goroutine-leak/">http://lessisbetter.site/2019/05/18/go-goroutine-leak/</a></li></ol></blockquote><div style="color:#0096FF; text-align:center">关注公众号，获取最新Golang文章</div><img src="https://lessisbetter.site/images/2019-01-article_qrcode.jpg" style="border:0"  align=center />]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存</tag>
      
      <tag>泄漏</tag>
      
      <tag>pprof</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redash Gunicorn 超时</title>
    <link href="/gunicorn/timeout/"/>
    <url>/gunicorn/timeout/</url>
    
    <content type="html"><![CDATA[<p>最近总有用户反馈说Redash下载比较大的Excel就会出现“失败 - 服务器出现问题”，而且每次从点了下载到出现错误提示时间都是差不多的。我先查看了Nginx的error日志，显示 <code>upstream prematurely closed connection while sending to client</code>，第一反应应该是超时导致的。</p><a id="more"></a><h2 id="1-修改Redash配置"><a href="#1-修改Redash配置" class="headerlink" title="1. 修改Redash配置"></a>1. 修改Redash配置</h2><ul><li>.env文件修改log级别为调试 <code>REDASH_LOG_LEVEL=&quot;DEBUG&quot;</code></li><li>.env文件加上超时配置 <code>REDASH_BIGQUERY_HTTP_TIMEOUT=600</code></li><li>Redash的启动命令后面增加 <code>-t 600</code> 参数。<br>10分钟应该够用了！重启redash进程后，进行尝试试，不好使！好吧，也许是配置参数写错了，那改成 <code>--timeout 600</code> 再试一下，发现还不好使！继续。。。</li></ul><h2 id="2-修改Nginx配置"><a href="#2-修改Nginx配置" class="headerlink" title="2. 修改Nginx配置"></a>2. 修改Nginx配置</h2><ul><li>请求超时：keepalive_timeout、client_header_timeout、client_body_timeout</li><li>后端服务器处理请求的时间设置：proxy_connect_timeout、proxy_read_timeout<br>重启Nginx，下载还是失败！！！看来不是超时导致的了？！</li></ul><h2 id="3-查看进程使用的资源"><a href="#3-查看进程使用的资源" class="headerlink" title="3. 查看进程使用的资源"></a>3. 查看进程使用的资源</h2><p>先执行：<br><code>top</code><br>再尝试下载操作，发现名叫<code>gunicorn</code>（Redash的server是用gunicorn启动的）的<code>COMMAND</code>CPU占用CPU到了100%，并且持续一定时间后，进程消失，新的进程启动后，CPU占用恢复正常值。那接下来就看看此进程都执行了哪些操作。</p><h2 id="4-进程跟踪"><a href="#4-进程跟踪" class="headerlink" title="4. 进程跟踪"></a>4. 进程跟踪</h2><p>跟踪CPU占用超高的 <code>gunicorn</code> 进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ strace -T -tt -e trace&#x3D;all -p 进程ID</span><br></pre></td></tr></table></figure><p>显式进程一直在 <code>read</code>、<code>write</code> 的系统调用，最后一行输出<br><code>+++ killed by SIGKILL +++</code><br>后，跟踪就停止了。难道是触发了系统的<code>ulimit</code>限制，然后被系统杀掉了？</p><h2 id="5-设置ulimit参数"><a href="#5-设置ulimit参数" class="headerlink" title="5. 设置ulimit参数"></a>5. 设置ulimit参数</h2><p>设置 <code>gunicorn</code> 运行用户的 <code>ulimit</code>，重新尝试，没有解决。看来也不是这个问题。。。那是被谁 <code>kill</code> 掉的呢？</p><h2 id="6-捕捉kill信号"><a href="#6-捕捉kill信号" class="headerlink" title="6. 捕捉kill信号"></a>6. 捕捉kill信号</h2><p>使用 <code>auditctl</code>，添加捕捉规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ auditctl -a exit,always -F arch&#x3D;b64 -S kill -F a1&#x3D;9</span><br></pre></td></tr></table></figure><p>进行下载文件操作，等待进程被杀死之后，显式捕捉到结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ausearch -sc kill</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time-&gt;Fri Dec  6 16:13:26 2019</span><br><span class="line">type&#x3D;PROCTITLE msg&#x3D;audit(1575620006.444:103711): proctitle&#x3D;2F6F70742F6D6F64756C65732F7265646173682D372E302E302F7265646173682F62696E2F707974686F6E322E37002F6F70742F7265646173682F7265646173682F62696E2F67756E69636F726E002D62003132372E302E302E313A35303030002D2D6E616D6500726564617368002D770034002D2D6D61782D726571756573</span><br><span class="line">type&#x3D;OBJ_PID msg&#x3D;audit(1575620006.444:103711): opid&#x3D;11646 oauid&#x3D;0 ouid&#x3D;1001 oses&#x3D;14406 ocomm&#x3D;&quot;gunicorn&quot;</span><br><span class="line">type&#x3D;SYSCALL msg&#x3D;audit(1575620006.444:103711): arch&#x3D;c000003e syscall&#x3D;62 success&#x3D;yes exit&#x3D;0 a0&#x3D;2d7e a1&#x3D;9 a2&#x3D;0 a3&#x3D;0 items&#x3D;0 ppid&#x3D;11490 pid&#x3D;11494 auid&#x3D;0 uid&#x3D;1001 gid&#x3D;1001 euid&#x3D;1001 suid&#x3D;1001 fsuid&#x3D;1001 egid&#x3D;1001 sgid&#x3D;1001 fsgid&#x3D;1001 tty&#x3D;(none) ses&#x3D;14406 comm&#x3D;&quot;gunicorn&quot; exe&#x3D;&quot;&#x2F;opt&#x2F;modules&#x2F;redash-7.0.0&#x2F;redash&#x2F;bin&#x2F;python2.7&quot; key&#x3D;(null)</span><br></pre></td></tr></table></figure><p>原来是被父进程搞死了。。。</p><h2 id="7-查看gunicorn日志"><a href="#7-查看gunicorn日志" class="headerlink" title="7. 查看gunicorn日志"></a>7. 查看gunicorn日志</h2><p>进入supervisord控制台，通过<code>tail -f </code> 打印 <code>gunicorn</code>进程的输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[CRITICAL] WORKER TIMEOUT (pid:15577)</span><br><span class="line">[INFO] Worker exiting (pid: 15577)</span><br><span class="line">[INFO] Booting worker with pid: 15646</span><br></pre></td></tr></table></figure><p><code>timeout</code>…原因就是最开始猜测的超时问题。</p><p><code>gunicorn</code> 给子进程的执行时间就有30秒，如果超过这个限制就会被父进程kill。可是timeout的超时配置并不生效。。。</p><h2 id="8-最终解决方案"><a href="#8-最终解决方案" class="headerlink" title="8.最终解决方案"></a>8.最终解决方案</h2><p><code>Gunicorn</code> 运行命令增加 <code>-k gevent</code> 配置</p><p><code>Gunicorn</code> 是 <code>pre-fork</code> 模型，<code>worker</code> 默认是 <code>sync</code> 改为 <code>gevent</code></p>]]></content>
    
    
    <categories>
      
      <category>gunicorn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gunicorn</tag>
      
      <tag>timeout</tag>
      
      <tag>redash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程之并发模型—(1)概念</title>
    <link href="/golang/parallel-concept/"/>
    <url>/golang/parallel-concept/</url>
    
    <content type="html"><![CDATA[<p>在开始学习 Go 特性的并发编程之前，先来简单了解一些基础概念，这对理解学习 Go 并发模型会有一些帮助。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h3><p>也被称为内核空间，是系统内核的运行空间，与用户空间隔离。控制计算机的硬件资源。</p><h3 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h3><p>也被称为用户空间，代码运行在较低的特权级别上，不能直接访问内核空间和硬件设备。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>用户空间不能直接调用系统资源，必须通过调用系统接口，由内核完成相关指令。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是操作系统分配资源的最小单元。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>有时也被称为轻量级进程（LWP），是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。</p><h3 id="KSE"><a href="#KSE" class="headerlink" title="KSE"></a>KSE</h3><p>理论上说 Linux 内核是没有线程这个概念的，只有内核调度实体（Kernal Scheduling Entry）这个概念。</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>有时也被称为微线程（Coroutine），只不过这个线程是用户态的，不需要操作系统参与。</p><p>调度过程示例：</p><ol><li>coroutine A 进行 网络I/O，使用 write() 发送数据后调用 read() 等待数据的返回，但是不一定什么时候能够读到数据，所以将 Socket Fd 放入 EventLoop 中。</li><li>coroutine A 让出 CPU 给 其它 coroutine 使用 —— <strong>挂起（yield）</strong></li><li>待 read() 有返回数据后，继续执行 coroutine A  —— <strong>恢复（resume）</strong></li></ol><p><em>EventLoop：无限循环着的事件分发器，一旦有事件发生，它就会回调预先定义好的回调函数，完成事件的处理。</em></p><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p><strong>M:1</strong> 多个用户空间的线程，对应一个内核空间的 KSE。</p><h4 id="系统级线程"><a href="#系统级线程" class="headerlink" title="系统级线程"></a>系统级线程</h4><p><strong>1:1</strong> 1个用户空间的线程，对应1个内核空间的 KSE。</p><h4 id="两级线程模型（混合式线程模型）"><a href="#两级线程模型（混合式线程模型）" class="headerlink" title="两级线程模型（混合式线程模型）"></a>两级线程模型（混合式线程模型）</h4><p><strong>M:N</strong> 多个用户空间的线程，对应多个内核空间的 KSE。</p><h3 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h3><p>并发模型指定了系统中的线程如何通过协作来完成分配给它们的作业。不同的并发模型采用不同的方式拆分作业，同时线程间的协作和交互方式也不相同。</p><p>常见的有：</p><ul><li>线程&amp;锁</li><li>Actor</li><li>CSP</li><li>Lambda 架构</li></ul><h3 id="并发模型—CSP"><a href="#并发模型—CSP" class="headerlink" title="并发模型—CSP"></a>并发模型—CSP</h3><p>Communicating Sequential Processes 通信顺序进程。</p><p>看这个名字就能知道，在CSP模型中主角是<strong>通信</strong>。</p><blockquote><p>channel：进行通信的并发模型。<br>worker：channel 两端的发送者/接收者。</p></blockquote><p>worker 之间不直接彼此联系，而是通过 channel 进行消息发送和接收。</p><p>在并发模型中，经常和 CSP 一起讨论的是 Actor 模型。</p><h3 id="GO-线程模型"><a href="#GO-线程模型" class="headerlink" title="GO 线程模型"></a>GO 线程模型</h3><p>Go 参考了<strong>两级线程模型</strong>，设计出了 MPG 线程模型。</p><h4 id="M"><a href="#M" class="headerlink" title="M"></a>M</h4><p>machine</p><p>用户空间内的线程，与 KSE 一一对应，可以理解为 M 代表了 内核线程。</p><h4 id="P"><a href="#P" class="headerlink" title="P"></a>P</h4><p>processor</p><p>可以理解为用户代码逻辑的处理器，Go 代码片段所必需的上下文环境。</p><h4 id="G"><a href="#G" class="headerlink" title="G"></a>G</h4><p>goroutine</p><p>Go 代码片段的封装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go function ()&#123;</span><br><span class="line">&#x2F;&#x2F;  ...</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3 id="GO并发模型"><a href="#GO并发模型" class="headerlink" title="GO并发模型"></a>GO并发模型</h3><h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><p>参考了 <strong>CSP并发模型</strong>。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="goroutine-与-coroutine-的区别"><a href="#goroutine-与-coroutine-的区别" class="headerlink" title="goroutine 与 coroutine 的区别"></a>goroutine 与 coroutine 的区别</h3><h4 id="coroutine"><a href="#coroutine" class="headerlink" title="coroutine"></a>coroutine</h4><p>运行机制属于协作式任务处理，始终顺序执行。</p><h4 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h4><p>运行机制属于抢占式任务处理，可能发生并行执行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Go 的并发模型参考了 CSP并发模型，采用 channel 进行通信。</li><li>Go 的线程模型参考了两级线程模型，设计出了 MPG 模型。</li><li>goroutine 与 coroutine 的区别就是前者可能发生并行执行，后者始终顺序执行。</li></ol>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go数据结构之数组与切片</title>
    <link href="/golang/datastruct-arrayslice/"/>
    <url>/golang/datastruct-arrayslice/</url>
    
    <content type="html"><![CDATA[<p>数组的长度是声明的时候就固定好的，后面不可能变大，而且长度和容量相等。</p><p>切片的长度和容量后面可以随着元素增多而增长，但是容量不可能小于长度。</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="声明-amp-初始化"><a href="#声明-amp-初始化" class="headerlink" title="声明&amp;初始化"></a>声明&amp;初始化</h3><p>在 Go 中声明即初始化，如果在声明的时候没有初始化值，那么就会赋值为声明类型的「零值」。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo1(t *testing.T) &#123;</span><br><span class="line">&#x2F;&#x2F; 数组</span><br><span class="line">var array1 [5]int        &#x2F;&#x2F; 只需设置长度，后面不可变</span><br><span class="line">var array2 &#x3D; new([5]int) &#x2F;&#x2F; 返回指针</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 切片</span><br><span class="line">var slice1 []int</span><br><span class="line">var slice2 &#x3D; make([]int, 5, 5) &#x2F;&#x2F; 设置长度、容量，后面可变</span><br><span class="line"></span><br><span class="line">t.Log(&quot;array1 val:&quot;, array1)      &#x2F;&#x2F; [0 0 0 0 0]</span><br><span class="line">t.Log(&quot;array1 len:&quot;, len(array1)) &#x2F;&#x2F; 5</span><br><span class="line">t.Log(&quot;array1 cap:&quot;, cap(array1)) &#x2F;&#x2F; 5</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">t.Log(&quot;array2 val:&quot;, array2)      &#x2F;&#x2F; &amp;[0 0 0 0 0]</span><br><span class="line">t.Log(&quot;array2 len:&quot;, len(array2)) &#x2F;&#x2F; 5</span><br><span class="line">t.Log(&quot;array2 cap:&quot;, cap(array2)) &#x2F;&#x2F; 5</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">t.Log(&quot;slice1 val:&quot;, slice1)      &#x2F;&#x2F; []</span><br><span class="line">t.Log(&quot;slice1 len:&quot;, len(slice1)) &#x2F;&#x2F; 0</span><br><span class="line">t.Log(&quot;slice1 cap:&quot;, cap(slice1)) &#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">t.Log(&quot;slice2 val:&quot;, slice2)      &#x2F;&#x2F; [0 0 0 0 0]</span><br><span class="line">t.Log(&quot;slice2 len:&quot;, len(slice2)) &#x2F;&#x2F; 5</span><br><span class="line">t.Log(&quot;slice2 cap:&quot;, cap(slice2)) &#x2F;&#x2F; 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在声明的时候就初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo2(t *testing.T) &#123;</span><br><span class="line">&#x2F;&#x2F; 数组</span><br><span class="line">var array1 &#x3D; [5]int&#123;4: 1, 2: 5&#125;</span><br><span class="line">var array2 &#x3D; [...]int&#123;4: 1, 2: 5&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 切片</span><br><span class="line">var slice1 &#x3D; []int&#123;4: 1, 2: 5&#125;</span><br><span class="line">var slice2 &#x3D; array1[:] &#x2F;&#x2F; 从数组截取来的切片</span><br><span class="line"></span><br><span class="line">t.Log(&quot;array1 val:&quot;, array1)      &#x2F;&#x2F; [0 0 5 0 1]</span><br><span class="line">t.Log(&quot;array1 len:&quot;, len(array1)) &#x2F;&#x2F; 5</span><br><span class="line">t.Log(&quot;array1 cap:&quot;, cap(array1)) &#x2F;&#x2F; 5</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">t.Log(&quot;array2 val:&quot;, array2)      &#x2F;&#x2F; [0 0 5 0 1]</span><br><span class="line">t.Log(&quot;array2 len:&quot;, len(array2)) &#x2F;&#x2F; 5</span><br><span class="line">t.Log(&quot;array2 cap:&quot;, cap(array2)) &#x2F;&#x2F; 5</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">t.Log(&quot;slice1 val:&quot;, slice1)      &#x2F;&#x2F; [0 0 5 0 1]</span><br><span class="line">t.Log(&quot;slice1 len:&quot;, len(slice1)) &#x2F;&#x2F; 5</span><br><span class="line">t.Log(&quot;slice1 cap:&quot;, cap(slice1)) &#x2F;&#x2F; 5</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">t.Log(&quot;slice2 val:&quot;, slice2)      &#x2F;&#x2F; [0 0 5 0 1]</span><br><span class="line">t.Log(&quot;slice2 len:&quot;, len(slice2)) &#x2F;&#x2F; 5</span><br><span class="line">t.Log(&quot;slice2 cap:&quot;, cap(slice2)) &#x2F;&#x2F; 5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加-amp-更新元素值"><a href="#添加-amp-更新元素值" class="headerlink" title="添加&amp;更新元素值"></a>添加&amp;更新元素值</h3><p>数组因为长度固定，且的值都是初始化好了的，所以只有更新。</p><p>切片更新操作和数据一样，只不过新增元素只能通过 append() 方法。</p><blockquote><p>append()：将元素追加大切片的末尾，如果容量不够，会进行扩容。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo3(t *testing.T) &#123;</span><br><span class="line">&#x2F;&#x2F; 数组</span><br><span class="line">var array1 &#x3D; [5]int&#123;4: 1, 2: 5&#125;</span><br><span class="line">array1[0] &#x3D; 100 &#x2F;&#x2F; 更新</span><br><span class="line">array1[4] &#x3D; 100 &#x2F;&#x2F; 更新</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 切片</span><br><span class="line">var slice1 &#x3D; []int&#123;4: 1, 2: 5&#125;</span><br><span class="line">array1[4] &#x3D; 100 &#x2F;&#x2F; 更新</span><br><span class="line">&#x2F;&#x2F;array1[5] &#x3D; 100 &#x2F;&#x2F; 报错</span><br><span class="line">slice1 &#x3D; append(slice1, 1) &#x2F;&#x2F; 切片增加元素只能使用此方法</span><br><span class="line"></span><br><span class="line">t.Log(&quot;array1 val:&quot;, array1)      &#x2F;&#x2F; [100 0 5 0 100]</span><br><span class="line">t.Log(&quot;array1 len:&quot;, len(array1)) &#x2F;&#x2F; 5</span><br><span class="line">t.Log(&quot;array1 cap:&quot;, cap(array1)) &#x2F;&#x2F; 5</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">t.Log(&quot;slice1 val:&quot;, slice1)      &#x2F;&#x2F; [0 0 5 0 1 1]</span><br><span class="line">t.Log(&quot;slice1 len:&quot;, len(slice1)) &#x2F;&#x2F; 6</span><br><span class="line">t.Log(&quot;slice1 cap:&quot;, cap(slice1)) &#x2F;&#x2F; 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>数组与切片，都可以使用表达式截取，截取之后的数据它的类型为切片。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo4(t *testing.T) &#123;</span><br><span class="line">array1 :&#x3D; [10]int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 4&#125;</span><br><span class="line"></span><br><span class="line">slice1 :&#x3D; array1[3:]              &#x2F;&#x2F; 从 index 3 取到 index end</span><br><span class="line">t.Log(&quot;slice1 val:&quot;, slice1)      &#x2F;&#x2F; [3 0 5 6 2 8 4]</span><br><span class="line">t.Log(&quot;slice1 len:&quot;, len(slice1)) &#x2F;&#x2F; 7</span><br><span class="line">t.Log(&quot;slice1 cap:&quot;, cap(slice1)) &#x2F;&#x2F; 7</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">slice2 :&#x3D; array1[3:4]             &#x2F;&#x2F; 从 index 3 取到 index 4</span><br><span class="line">t.Log(&quot;slice2 val:&quot;, slice2)      &#x2F;&#x2F; [3]</span><br><span class="line">t.Log(&quot;slice2 len:&quot;, len(slice2)) &#x2F;&#x2F; 1</span><br><span class="line">t.Log(&quot;slice2 cap:&quot;, cap(slice2)) &#x2F;&#x2F; 7</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">slice3 :&#x3D; array1[3:6:6]           &#x2F;&#x2F; 从 index 3 取到 index 6，容量取到 index 6</span><br><span class="line">t.Log(&quot;slice3 val:&quot;, slice3)      &#x2F;&#x2F; [3 0 5]</span><br><span class="line">t.Log(&quot;slice3 len:&quot;, len(slice3)) &#x2F;&#x2F; 3</span><br><span class="line">t.Log(&quot;slice3 cap:&quot;, cap(slice3)) &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">slice4 :&#x3D; array1[3:6:9]           &#x2F;&#x2F; 从 index 3 取到 index 6，容量取到 index 9</span><br><span class="line">t.Log(&quot;slice4 val:&quot;, slice4)      &#x2F;&#x2F; [3 0 5]</span><br><span class="line">t.Log(&quot;slice4 len:&quot;, len(slice4)) &#x2F;&#x2F; 3</span><br><span class="line">t.Log(&quot;slice4 cap:&quot;, cap(slice4)) &#x2F;&#x2F; 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>使用 for、range</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo5(t *testing.T) &#123;</span><br><span class="line">array1 :&#x3D; [...]int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 4&#125;</span><br><span class="line">slice1 :&#x3D; make([]int, 5, 5)</span><br><span class="line">for k, v :&#x3D; range array1 &#123;</span><br><span class="line">fmt.Println(k, &quot;-&quot;, v)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">for k, v :&#x3D; range slice1 &#123;</span><br><span class="line">fmt.Println(k, &quot;-&quot;, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>数组与数组可以使用 == 比较，不能与 nil 比较</p><p>切片与切片不能使用 == 比较，可以使用 reflect.DeepEqual 比较，可以与 nil 比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo6(t *testing.T) &#123;</span><br><span class="line">array1 :&#x3D; [...]int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 4&#125;</span><br><span class="line">array2 :&#x3D; [...]int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 9&#125;</span><br><span class="line">array3 :&#x3D; [...]int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 9&#125;</span><br><span class="line"></span><br><span class="line">t.Logf(&quot;array1 &#x3D;&#x3D; array2 %t\n&quot;, array1 &#x3D;&#x3D; array2) &#x2F;&#x2F; false</span><br><span class="line">t.Logf(&quot;array2 &#x3D;&#x3D; array3 %t\n&quot;, array2 &#x3D;&#x3D; array3) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F;t.Logf(&quot;%t\n&quot;, array2 &#x3D;&#x3D; nil) &#x2F;&#x2F; 会报错，数组不能与nil比</span><br><span class="line"></span><br><span class="line">slice1 :&#x3D; make([]int, 5, 5)</span><br><span class="line">var slice2 []int</span><br><span class="line">slice3 :&#x3D; []int&#123;4: 0&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; t.Logf(&quot;%t\n&quot;, slice1 &#x3D;&#x3D; slice2) &#x2F;&#x2F; 会报错，切片与切片不能比</span><br><span class="line">t.Logf(&quot;slice1 &#x3D;&#x3D; nil %t\n&quot;, slice1 &#x3D;&#x3D; nil) &#x2F;&#x2F; false</span><br><span class="line">t.Logf(&quot;slice2 &#x3D;&#x3D; nil %t\n&quot;, slice2 &#x3D;&#x3D; nil) &#x2F;&#x2F; true</span><br><span class="line">t.Logf(&quot;slice3 &#x3D;&#x3D; nil %t\n&quot;, slice3 &#x3D;&#x3D; nil) &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">t.Logf(&quot;slice1 &#x3D;&#x3D; slice2 %t\n&quot;, reflect.DeepEqual(slice1, slice2)) &#x2F;&#x2F; false</span><br><span class="line">t.Logf(&quot;slice2 &#x3D;&#x3D; slice3 %t\n&quot;, reflect.DeepEqual(slice2, slice3)) &#x2F;&#x2F; false</span><br><span class="line">t.Logf(&quot;slice1 &#x3D;&#x3D; slice3 %t\n&quot;, reflect.DeepEqual(slice1, slice3)) &#x2F;&#x2F; true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>需使用 append()、切片表达式 结合来完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo7(t *testing.T) &#123;</span><br><span class="line">slice1 :&#x3D; []int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 4&#125;</span><br><span class="line">slice1 &#x3D; append(slice1[:2], slice1[3:]...)</span><br><span class="line">t.Log(slice1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="数组与切片的关系"><a href="#数组与切片的关系" class="headerlink" title="数组与切片的关系"></a>数组与切片的关系</h3><p><strong>数组为值类型，切片为引用类型</strong>，他们又有何关系呢？</p><p>程序示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo8(t *testing.T) &#123;</span><br><span class="line">array1 :&#x3D; [10]int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 4&#125;</span><br><span class="line"></span><br><span class="line">slice1 :&#x3D; array1[:]</span><br><span class="line"></span><br><span class="line">t.Log(&quot;slice1 val:&quot;, slice1)      &#x2F;&#x2F; [9 1 7 3 0 5 6 2 8 4]</span><br><span class="line">t.Log(&quot;slice1 len:&quot;, len(slice1)) &#x2F;&#x2F; 10</span><br><span class="line">t.Log(&quot;slice1 cap:&quot;, cap(slice1)) &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">array1[9] &#x3D; 96969696 &#x2F;&#x2F; array1 的修改会影响到 slice1</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">t.Log(&quot;slice1 val:&quot;, slice1)      &#x2F;&#x2F; [9 1 7 3 0 5 6 2 8 96969696]</span><br><span class="line">t.Log(&quot;slice1 len:&quot;, len(slice1)) &#x2F;&#x2F; 10</span><br><span class="line">t.Log(&quot;slice1 cap:&quot;, cap(slice1)) &#x2F;&#x2F; 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例程序中，可以说 slice1 是 array1 的引用。</p><p>不光是在示例程序中，这种在数组上通过表达式截取出的切片，为数组的引用，就算在程序中，直接声明一个新切片（var slice1 []int），在切片的底层实现，其实也是引用了一个数组。</p><p>他们的关系就是：<strong>数组是切片的底层实现，切片是数组的引用。</strong></p><h3 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h3><p>在示例程序 TestDemo8 中，slice1 会一直引用 array1 么？</p><p>一般情况下是这样，但有种情况下引用会发生变化，就是在 slice 发生扩容的情况下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo9(t *testing.T) &#123;</span><br><span class="line">array1 :&#x3D; [10]int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 4&#125;</span><br><span class="line">slice1 :&#x3D; array1[:] &#x2F;&#x2F; 从 array1 截取出 slice1</span><br><span class="line"></span><br><span class="line">t.Log(&quot;slice1 val:&quot;, slice1)      &#x2F;&#x2F; [9 1 7 3 0 5 6 2 8 4]</span><br><span class="line">t.Log(&quot;slice1 len:&quot;, len(slice1)) &#x2F;&#x2F; 10</span><br><span class="line">t.Log(&quot;slice1 cap:&quot;, cap(slice1)) &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">slice1 &#x3D; append(slice1, 9) &#x2F;&#x2F; 进行扩容后，slice1 指向了新的底层数组，不在是 array1 的引用</span><br><span class="line">array1[9] &#x3D; 96969696</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">t.Log(&quot;slice1 val:&quot;, slice1)      &#x2F;&#x2F; [9 1 7 3 0 5 6 2 8 4 9]</span><br><span class="line">t.Log(&quot;slice1 len:&quot;, len(slice1)) &#x2F;&#x2F; 11</span><br><span class="line">t.Log(&quot;slice1 cap:&quot;, cap(slice1)) &#x2F;&#x2F; 20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当切片添加新元素，发现容量不够时，会开辟一个新的底层数组，然后把旧数组的数据和添加的新元素一并拷贝到新数组中。</p><h4 id="扩容策略："><a href="#扩容策略：" class="headerlink" title="扩容策略："></a>扩容策略：</h4><ul><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）</li><li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）</li><li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）</li></ul><h3 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h3><p>靠扩容解决引用问题，显得不是那么优雅。</p><p>可以使用 copy() 进行深复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo10(t *testing.T) &#123;</span><br><span class="line">array1 :&#x3D; [10]int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 4&#125;</span><br><span class="line"></span><br><span class="line">var slice1 &#x3D; make([]int, 10, 10)</span><br><span class="line">copy(slice1, array1[:]) &#x2F;&#x2F; 深复制，slice1 不会引用 array1</span><br><span class="line">array1[9] &#x3D; 96969696</span><br><span class="line"></span><br><span class="line">t.Log(&quot;slice1 val:&quot;, slice1)      &#x2F;&#x2F; [9 1 7 3 0 5 6 2 8 4]</span><br><span class="line">t.Log(&quot;slice1 len:&quot;, len(slice1)) &#x2F;&#x2F; 10</span><br><span class="line">t.Log(&quot;slice1 cap:&quot;, cap(slice1)) &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">t.Log(&quot;array1 val:&quot;, array1)      &#x2F;&#x2F; [9 1 7 3 0 5 6 2 8 96969696]</span><br><span class="line">t.Log(&quot;array1 len:&quot;, len(array1)) &#x2F;&#x2F; 10</span><br><span class="line">t.Log(&quot;array1 cap:&quot;, cap(array1)) &#x2F;&#x2F; 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="传递"><a href="#传递" class="headerlink" title="传递"></a>传递</h3><p>切片，如果不使用 copy() 进行深复制出一个新的切片，直接传递过去的切片底层还是同一个数组，当然，append() 发生了扩容之后，就不会是同一个数组了。</p><p>数组，直接传递会变成两个数组，如果运用了指针，会指向同一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo11(t *testing.T) &#123;</span><br><span class="line">&#x2F;&#x2F; 切片，底层引用的还是同一个数组</span><br><span class="line">slice1 :&#x3D; []int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 4&#125;</span><br><span class="line">go func(v []int) &#123;</span><br><span class="line">&#x2F;&#x2F;v &#x3D; append(v, 20) &#x2F;&#x2F; 扩容后底层数组就变了</span><br><span class="line">v[0] &#x3D; 99999</span><br><span class="line">t.Log(v)</span><br><span class="line">&#125;(slice1)</span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">t.Log(&quot;slice1&quot;, slice1) &#x2F;&#x2F; slice1 [99999 1 7 3 0 5 6 2 8 4]</span><br><span class="line"></span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 切片，copy() 深复制后，底层不是同一个数组</span><br><span class="line">slice2 :&#x3D; []int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 4&#125;</span><br><span class="line">slice2Copy :&#x3D; make([]int, 10, 10)</span><br><span class="line">copy(slice2Copy, slice2)</span><br><span class="line">go func(v []int) &#123;</span><br><span class="line">v[0] &#x3D; 99999</span><br><span class="line">&#125;(slice2Copy)</span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">t.Log(&quot;slice2&quot;, slice2) &#x2F;&#x2F; slice2 [9 1 7 3 0 5 6 2 8 4]</span><br><span class="line"></span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数组，不是同一个</span><br><span class="line">array1 :&#x3D; [10]int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 4&#125;</span><br><span class="line">go func(v [10]int) &#123;</span><br><span class="line">v[0] &#x3D; 99999</span><br><span class="line">&#125;(array1)</span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">t.Log(&quot;array1&quot;, array1) &#x2F;&#x2F; array1 [9 1 7 3 0 5 6 2 8 4]</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数组，同一个</span><br><span class="line">array2 :&#x3D; [10]int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 4&#125;</span><br><span class="line">go func(v *[10]int) &#123;</span><br><span class="line">v[0] &#x3D; 99999</span><br><span class="line">&#125;(&amp;array2)</span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">t.Log(&quot;array2&quot;, array2) &#x2F;&#x2F; array2 [99999 1 7 3 0 5 6 2 8 4]</span><br><span class="line"></span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数组 同一个</span><br><span class="line">array3 :&#x3D; new([10]int)</span><br><span class="line">go func(v *[10]int) &#123;</span><br><span class="line">v[0] &#x3D; 99999</span><br><span class="line">&#125;(array3)</span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">t.Log(&quot;array3&quot;, array3) &#x2F;&#x2F; array3 &amp;[99999 0 0 0 0 0 0 0 0 0]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果和下面一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo12(t *testing.T) &#123;</span><br><span class="line">array1 :&#x3D; [10]int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 4&#125;</span><br><span class="line">array2 :&#x3D; array1</span><br><span class="line">array2[0] &#x3D; 999</span><br><span class="line">t.Log(&quot;array1&quot;, array1) &#x2F;&#x2F; array1 [9 1 7 3 0 5 6 2 8 4]</span><br><span class="line">t.Log(&quot;array2&quot;, array2) &#x2F;&#x2F; array2 [999 1 7 3 0 5 6 2 8 4]</span><br><span class="line"></span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">slice1 :&#x3D; []int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 4&#125;</span><br><span class="line">slice2 :&#x3D; slice1</span><br><span class="line">slice2[0] &#x3D; 999</span><br><span class="line">t.Log(&quot;slice1&quot;, slice1) &#x2F;&#x2F; slice1 [999 1 7 3 0 5 6 2 8 4]</span><br><span class="line">t.Log(&quot;slice2&quot;, slice2) &#x2F;&#x2F; slice2 [999 1 7 3 0 5 6 2 8 4]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>一段连续的内存空间。</p><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>make 只能用于 slice、map、channel，返回的初始化后的（非零）值。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul><li>切片</li><li>字典</li><li>通道</li><li>函数</li></ul><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><ul><li>数组</li><li>基础数据类型</li><li>结构体类型</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>切片是数组的引用，数组是切片的底层实现。</li><li>数组的长度(len)等于容量(cap)，切片的长度(len)小于等于容量(cap)。</li><li>数组声明的时候默认就会初始化，值为类型的「零值」；切片声明的时候，如果不初始化，值是 nil。</li><li>使用 copy() 深复制解决引用问题。</li></ol><p><a href="https://github.com/zuoshuwen/go-example/blob/master/e005/a01_test.go">文章示例代码</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>切片</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程之传统同步—(3)原子操作</title>
    <link href="/golang/ipc-atomic/"/>
    <url>/golang/ipc-atomic/</url>
    
    <content type="html"><![CDATA[<p>之前文章中介绍的互斥锁虽然能够保证同串行化，但是却保证不了执行过程中的中断。<br>要么成功、要么失败，没有中断的情况，我们叫它叫原子性，这种由硬件 CPU 提供支持的特性，是非常可靠的。</p><p><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C">百度百科</a>上关于原子操作的介绍。</p><a id="more"></a><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>由 sync/atomic 包提供操作支持。</p><h3 id="加法（add）"><a href="#加法（add）" class="headerlink" title="加法（add）"></a>加法（add）</h3><p>实现累加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo1(t *testing.T) &#123;</span><br><span class="line">var counter int64 &#x3D; 0</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; 100; i++ &#123;</span><br><span class="line">go func() &#123;</span><br><span class="line">atomic.AddInt64(&amp;counter, 1)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(2 * time.Second)</span><br><span class="line">log.Println(&quot;counter:&quot;, atomic.LoadInt64(&amp;counter))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDemo1</span><br><span class="line">2020&#x2F;10&#x2F;11 00:24:56 counter: 100</span><br><span class="line">--- PASS: TestDemo1 (2.00s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><h3 id="减法（add）"><a href="#减法（add）" class="headerlink" title="减法（add）"></a>减法（add）</h3><p>对于做减法，是没有直接提供的方法的，而 Add（-1）这种是不能对 uint 类型使用的，可以通过补码的方式实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo2(t *testing.T) &#123;</span><br><span class="line">var counter uint64 &#x3D; 100</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; 100; i++ &#123;</span><br><span class="line">go func() &#123;</span><br><span class="line">atomic.AddUint64(&amp;counter, ^uint64(-(-1)-1))</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(2 * time.Second)</span><br><span class="line">log.Println(&quot;counter:&quot;, atomic.LoadUint64(&amp;counter))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDemo2</span><br><span class="line">2020&#x2F;10&#x2F;11 00:32:05 counter: 0</span><br><span class="line">--- PASS: TestDemo2 (2.00s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><h3 id="比较并交换（compare-and-swap，简称-CAS）"><a href="#比较并交换（compare-and-swap，简称-CAS）" class="headerlink" title="比较并交换（compare and swap，简称 CAS）"></a>比较并交换（compare and swap，简称 CAS）</h3><p>并发编程中，在没有使用互斥锁的前提下，对共享数据先取出做判断，再根据判断的结果做后续操作，必然是会出问题的，使用 CAS 可以避免这种问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo3(t *testing.T) &#123;</span><br><span class="line">var first int64 &#x3D; 0</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 1; i &lt;&#x3D; 10000; i++ &#123;</span><br><span class="line">go func(i int) &#123;</span><br><span class="line">if atomic.CompareAndSwapInt64(&amp;first, 0, int64(i)) &#123;</span><br><span class="line">log.Println(&quot;抢先运行的是 goroutine&quot;, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(2 * time.Second)</span><br><span class="line">log.Println(&quot;num:&quot;, atomic.LoadInt64(&amp;first))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDemo3</span><br><span class="line">2020&#x2F;10&#x2F;11 00:42:10 抢先运行的是 goroutine 3</span><br><span class="line">2020&#x2F;10&#x2F;11 00:42:12 num: 3</span><br><span class="line">--- PASS: TestDemo3 (2.01s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><h3 id="加载（load）"><a href="#加载（load）" class="headerlink" title="加载（load）"></a>加载（load）</h3><p>加载操作在进行时只会有一个，不会有其它的读写操作同时进行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo4(t *testing.T) &#123;</span><br><span class="line">var counter int64 &#x3D; 0</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; 100; i++ &#123;</span><br><span class="line">go func() &#123;</span><br><span class="line">atomic.AddInt64(&amp;counter, 1)</span><br><span class="line">log.Println(&quot;counter:&quot;, atomic.LoadInt64(&amp;counter))</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(2 * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="存储（store）"><a href="#存储（store）" class="headerlink" title="存储（store）"></a>存储（store）</h3><p>存储操作在进行时只会有一个，不会有其它的读写操作同时进行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo5(t *testing.T) &#123;</span><br><span class="line">var counter int64 &#x3D; 0</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">go func(i int) &#123;</span><br><span class="line">atomic.StoreInt64(&amp;counter, int64(i))</span><br><span class="line">log.Println(&quot;counter:&quot;, atomic.LoadInt64(&amp;counter))</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(2 * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交换（swap）"><a href="#交换（swap）" class="headerlink" title="交换（swap）"></a>交换（swap）</h3><p>swap 方法返回被替换之前的旧值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo6(t *testing.T) &#123;</span><br><span class="line">var counter int64 &#x3D; 0</span><br><span class="line"></span><br><span class="line">for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">go func(i int) &#123;</span><br><span class="line">log.Println(&quot;counter old:&quot;, atomic.SwapInt64(&amp;counter, int64(i)))</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(2 * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDemo6</span><br><span class="line">2020&#x2F;10&#x2F;11 00:43:36 counter old: 0</span><br><span class="line">2020&#x2F;10&#x2F;11 00:43:36 counter old: 9</span><br><span class="line">2020&#x2F;10&#x2F;11 00:43:36 counter old: 5</span><br><span class="line">2020&#x2F;10&#x2F;11 00:43:36 counter old: 1</span><br><span class="line">2020&#x2F;10&#x2F;11 00:43:36 counter old: 2</span><br><span class="line">2020&#x2F;10&#x2F;11 00:43:36 counter old: 3</span><br><span class="line">2020&#x2F;10&#x2F;11 00:43:36 counter old: 6</span><br><span class="line">2020&#x2F;10&#x2F;11 00:43:36 counter old: 4</span><br><span class="line">2020&#x2F;10&#x2F;11 00:43:36 counter old: 7</span><br><span class="line">2020&#x2F;10&#x2F;11 00:43:36 counter old: 0</span><br><span class="line">--- PASS: TestDemo6 (2.00s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><h3 id="原子值（value）"><a href="#原子值（value）" class="headerlink" title="原子值（value）"></a>原子值（value）</h3><p>value是一个结构体，内部值定义为 interface{}，所以它是可以接受任何类型的值。</p><p>第一次赋值的时候，原子值的类型就确认了，后面不能赋值其它类型的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo7(t *testing.T) &#123;</span><br><span class="line">var value atomic.Value</span><br><span class="line">var counter uint64 &#x3D; 1</span><br><span class="line"></span><br><span class="line">value.Store(counter)</span><br><span class="line">log.Println(&quot;counter:&quot;, value.Load())</span><br><span class="line"></span><br><span class="line">value.Store(uint64(10))</span><br><span class="line">log.Println(&quot;counter:&quot;, value.Load())</span><br><span class="line"></span><br><span class="line">value.Store(100) &#x2F;&#x2F; 引发 panic</span><br><span class="line">log.Println(&quot;counter:&quot;, value.Load())</span><br><span class="line"></span><br><span class="line">time.Sleep(2 * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDemo7</span><br><span class="line">2020&#x2F;10&#x2F;11 10:14:58 counter: 0</span><br><span class="line">2020&#x2F;10&#x2F;11 10:14:58 counter: 10</span><br><span class="line">--- FAIL: TestDemo7 (0.00s)</span><br><span class="line">panic: sync&#x2F;atomic: store of inconsistently typed value into Value [recovered]</span><br><span class="line">panic: sync&#x2F;atomic: store of inconsistently typed value into Value</span><br><span class="line">                ...</span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="无锁编程"><a href="#无锁编程" class="headerlink" title="无锁编程"></a>无锁编程</h3><p><em>此处暂时先介绍一下，后面有机会出文章再一起学习进步。</em></p><p>放弃互斥锁，采用原子操作，常见方法有以下几种：</p><h4 id="针对计数器"><a href="#针对计数器" class="headerlink" title="针对计数器"></a>针对计数器</h4><p>可以使用例如上面介绍的 Add 方法。</p><h4 id="单生产、消费者"><a href="#单生产、消费者" class="headerlink" title="单生产、消费者"></a>单生产、消费者</h4><p>单生产者、单消费者可以做到免锁访问环形缓冲区（Ring Buffer）。<br>比如，Linux kernel 中的 kfifo 的实现。</p><h4 id="RCU（Read-Copy-Update）"><a href="#RCU（Read-Copy-Update）" class="headerlink" title="RCU（Read Copy Update）"></a>RCU（Read Copy Update）</h4><p>新旧副本切换机制，对于旧副本可以采用延迟释放的做法。</p><h4 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare And Swap）"></a>CAS（Compare And Swap）</h4><p>如无锁栈，无锁队列等待</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>原子操作性能是高于互斥锁的，但带来的复杂性也会提高，真正用好并不容易。</li><li>互斥锁、条件变量，方法内部的实现也都用到了原子操作，特别是CAS。</li></ol><p><a href="https://github.com/zuoshuwen/go-example/blob/master/e003/a01_test.go">文章示例代码</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同步</tag>
      
      <tag>原子操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程之传统同步—(2)条件变量</title>
    <link href="/golang/ipc-cond/"/>
    <url>/golang/ipc-cond/</url>
    
    <content type="html"><![CDATA[<p>回顾上篇文章 <a href="/golang/ipc-mutex/" title="Go并发编程之传统同步—(1)互斥锁">Go并发编程之传统同步—(1)互斥锁</a> 其中说到，同步最终是为了达到以下两种目的：</p><blockquote><ul><li><strong>维持共享数据一致性，并发安全</strong></li><li><strong>控制流程管理，更好的协同工作</strong></li></ul></blockquote><p>示例程序通过使用互斥锁，达到了数据一致性目的，那么流程管理应该怎么做呢？</p><a id="more"></a><h2 id="传统同步"><a href="#传统同步" class="headerlink" title="传统同步"></a>传统同步</h2><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>上篇文章的示例程序，仅仅实现了累加功能，但在现实的工作场景中，需求往往不可能这么简单，现在扩展一下这个程序，给它加上累减的功能。</p><p>加上了累减的示例程序，可以抽象的理解为一个固定容量的“储水池”，可以注水、排水。</p><h4 id="仅用互斥锁"><a href="#仅用互斥锁" class="headerlink" title="仅用互斥锁"></a>仅用互斥锁</h4><p>当水注满以后，停止注水，开始排水，当水排空以后，开始注水，反反复复…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo1(t *testing.T) &#123;</span><br><span class="line">var mut sync.Mutex</span><br><span class="line">maxSize :&#x3D; 10</span><br><span class="line">counter :&#x3D; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 排水口</span><br><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">mut.Lock()</span><br><span class="line">if counter &#x3D;&#x3D; maxSize &#123;</span><br><span class="line">for i :&#x3D; 0; i &lt; maxSize; i++ &#123;</span><br><span class="line">counter--</span><br><span class="line">log.Printf(&quot;OUTPUT counter &#x3D; %d&quot;, counter)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mut.Unlock()</span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注水口</span><br><span class="line">for &#123;</span><br><span class="line">mut.Lock()</span><br><span class="line">if counter &#x3D;&#x3D; 0 &#123;</span><br><span class="line">for i :&#x3D; 0; i &lt; maxSize; i++ &#123;</span><br><span class="line">counter++</span><br><span class="line">log.Printf(&quot; INPUT counter &#x3D; %d&quot;, counter)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mut.Unlock()</span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDemo1</span><br><span class="line">                ···</span><br><span class="line">2020&#x2F;10&#x2F;06 13:52:50  INPUT counter &#x3D; 8</span><br><span class="line">2020&#x2F;10&#x2F;06 13:52:50  INPUT counter &#x3D; 9</span><br><span class="line">2020&#x2F;10&#x2F;06 13:52:50  INPUT counter &#x3D; 10</span><br><span class="line">2020&#x2F;10&#x2F;06 13:52:50 OUTPUT counter &#x3D; 9</span><br><span class="line">2020&#x2F;10&#x2F;06 13:52:50 OUTPUT counter &#x3D; 8</span><br><span class="line">2020&#x2F;10&#x2F;06 13:52:50 OUTPUT counter &#x3D; 7</span><br><span class="line">                ···</span><br></pre></td></tr></table></figure><p>看着没有什么问题，一切正常，但就是这样工作的策略效率太低。</p><h4 id="优化互斥锁"><a href="#优化互斥锁" class="headerlink" title="优化互斥锁"></a>优化互斥锁</h4><p>优化策略，不用等注满水再排水，也不用放空之后，再注水，注水口和排水口一起工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo2(t *testing.T) &#123;</span><br><span class="line">var mut sync.Mutex</span><br><span class="line">maxSize :&#x3D; 10</span><br><span class="line">counter :&#x3D; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 排水口</span><br><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">mut.Lock()</span><br><span class="line">if counter !&#x3D; 0 &#123;</span><br><span class="line">counter--</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(&quot;OUTPUT counter &#x3D; %d&quot;, counter)</span><br><span class="line">mut.Unlock()</span><br><span class="line">time.Sleep(5 * time.Second) &#x2F;&#x2F; 为了演示效果，睡眠5秒</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注水口</span><br><span class="line">for &#123;</span><br><span class="line">mut.Lock()</span><br><span class="line">if counter !&#x3D; maxSize &#123;</span><br><span class="line">counter++</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(&quot; INPUT counter &#x3D; %d&quot;, counter)</span><br><span class="line">mut.Unlock()</span><br><span class="line">time.Sleep(1 * time.Second) &#x2F;&#x2F; 为了演示效果，睡眠1秒</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDemo2</span><br><span class="line">                ···</span><br><span class="line">2020&#x2F;10&#x2F;06 14:11:46  INPUT counter &#x3D; 7</span><br><span class="line">2020&#x2F;10&#x2F;06 14:11:47  INPUT counter &#x3D; 8</span><br><span class="line">2020&#x2F;10&#x2F;06 14:11:48 OUTPUT counter &#x3D; 7</span><br><span class="line">2020&#x2F;10&#x2F;06 14:11:48  INPUT counter &#x3D; 8</span><br><span class="line">2020&#x2F;10&#x2F;06 14:11:49  INPUT counter &#x3D; 9</span><br><span class="line">2020&#x2F;10&#x2F;06 14:11:50  INPUT counter &#x3D; 10</span><br><span class="line">2020&#x2F;10&#x2F;06 14:11:51  INPUT counter &#x3D; 10</span><br><span class="line">2020&#x2F;10&#x2F;06 14:11:52  INPUT counter &#x3D; 10</span><br><span class="line">2020&#x2F;10&#x2F;06 14:11:53 OUTPUT counter &#x3D; 9</span><br><span class="line">2020&#x2F;10&#x2F;06 14:11:53  INPUT counter &#x3D; 10</span><br><span class="line">2020&#x2F;10&#x2F;06 14:11:54  INPUT counter &#x3D; 10</span><br><span class="line">2020&#x2F;10&#x2F;06 14:11:55  INPUT counter &#x3D; 10</span><br><span class="line">2020&#x2F;10&#x2F;06 14:11:56  INPUT counter &#x3D; 10</span><br><span class="line">2020&#x2F;10&#x2F;06 14:11:57  INPUT counter &#x3D; 10</span><br><span class="line">2020&#x2F;10&#x2F;06 14:11:58 OUTPUT counter &#x3D; 9</span><br><span class="line">2020&#x2F;10&#x2F;06 14:11:58  INPUT counter &#x3D; 10</span><br><span class="line">2020&#x2F;10&#x2F;06 14:11:59  INPUT counter &#x3D; 10</span><br><span class="line">                ···</span><br></pre></td></tr></table></figure><p>通过日志输出，可以看到程序达到了需求，运作正常。</p><p>但是，通过日志输出发现，当排水口效率低下的时候，注水口一直在轮询，这里频繁的上锁操作造成的开销很是浪费。</p><h4 id="条件变量：单发通知"><a href="#条件变量：单发通知" class="headerlink" title="条件变量：单发通知"></a>条件变量：单发通知</h4><p>那有没有什么好的办法，省去不必要的轮询？如果注水口和排水口能互相“通知”就好了！这个功能，<strong>条件变量</strong>可以做到。</p><p>条件变量总是与互斥锁组合使用，除了可以使用 Lock、Unlock，还有如下三个方法：</p><blockquote><ul><li>Wait 等待通知</li><li>Signal 单发通知</li><li>Broadcast 广播通知</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo3(t *testing.T) &#123;</span><br><span class="line">cond :&#x3D; sync.NewCond(new(sync.Mutex)) &#x2F;&#x2F; 初始化条件变量</span><br><span class="line">maxSize :&#x3D; 10</span><br><span class="line">counter :&#x3D; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 排水口</span><br><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">cond.L.Lock() &#x2F;&#x2F; 上锁</span><br><span class="line">if counter &#x3D;&#x3D; 0 &#123; &#x2F;&#x2F; 没水了</span><br><span class="line">cond.Wait() &#x2F;&#x2F; 啥时候来水？等通知！</span><br><span class="line">&#125;</span><br><span class="line">counter--</span><br><span class="line">log.Printf(&quot;OUTPUT counter &#x3D; %d&quot;, counter)</span><br><span class="line">cond.Signal() &#x2F;&#x2F; 单发通知：已排水</span><br><span class="line">cond.L.Unlock() &#x2F;&#x2F; 解锁</span><br><span class="line">time.Sleep(5 * time.Second) &#x2F;&#x2F; 为了演示效果，睡眠5秒</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注水口</span><br><span class="line">for &#123;</span><br><span class="line">cond.L.Lock() &#x2F;&#x2F; 上锁</span><br><span class="line">if counter &#x3D;&#x3D; maxSize &#123; &#x2F;&#x2F; 水满了</span><br><span class="line">cond.Wait() &#x2F;&#x2F; 啥时候排水？等待通知！</span><br><span class="line">&#125;</span><br><span class="line">counter++</span><br><span class="line">log.Printf(&quot; INPUT counter &#x3D; %d&quot;, counter)</span><br><span class="line">cond.Signal() &#x2F;&#x2F; 单发通知：已来水</span><br><span class="line">cond.L.Unlock() &#x2F;&#x2F; 解锁</span><br><span class="line">time.Sleep(1 * time.Second) &#x2F;&#x2F; 为了演示效果，睡眠1秒</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDemo3</span><br><span class="line">                ···</span><br><span class="line">2020&#x2F;10&#x2F;06 14:51:22  INPUT counter &#x3D; 7</span><br><span class="line">2020&#x2F;10&#x2F;06 14:51:23  INPUT counter &#x3D; 8</span><br><span class="line">2020&#x2F;10&#x2F;06 14:51:24 OUTPUT counter &#x3D; 7</span><br><span class="line">2020&#x2F;10&#x2F;06 14:51:24  INPUT counter &#x3D; 8</span><br><span class="line">2020&#x2F;10&#x2F;06 14:51:25  INPUT counter &#x3D; 9</span><br><span class="line">2020&#x2F;10&#x2F;06 14:51:26  INPUT counter &#x3D; 10</span><br><span class="line">2020&#x2F;10&#x2F;06 14:51:29 OUTPUT counter &#x3D; 9</span><br><span class="line">2020&#x2F;10&#x2F;06 14:51:29  INPUT counter &#x3D; 10</span><br><span class="line">2020&#x2F;10&#x2F;06 14:51:34 OUTPUT counter &#x3D; 9</span><br><span class="line">2020&#x2F;10&#x2F;06 14:51:34  INPUT counter &#x3D; 10</span><br><span class="line">                ···</span><br></pre></td></tr></table></figure><p>通过日志输出，可以看出来，注水口没有一直轮询了，而是等到排水口发通知后，再进行注水，注水口一直再等排水口。那么新的问题又来了，如何提高排水口的效率呢？</p><h4 id="条件变量：广播通知"><a href="#条件变量：广播通知" class="headerlink" title="条件变量：广播通知"></a>条件变量：广播通知</h4><p>多制造出一个排水口，提高排水效率。</p><p>那就不能继续使用单发通知了（Signal），因为单发通知只会通知到一个等待（Wait），针对多等待的这种情况，就需要使用广播通知（Broadcast）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">func TestDemo4(t *testing.T) &#123;</span><br><span class="line">cond :&#x3D; sync.NewCond(new(sync.Mutex)) &#x2F;&#x2F; 初始化条件变量</span><br><span class="line">maxSize :&#x3D; 10</span><br><span class="line">counter :&#x3D; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 排水口 1</span><br><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">cond.L.Lock() &#x2F;&#x2F; 上锁</span><br><span class="line">if counter &#x3D;&#x3D; 0 &#123; &#x2F;&#x2F; 没水了</span><br><span class="line">&#x2F;&#x2F;for counter &#x3D;&#x3D; 0 &#123; &#x2F;&#x2F; 没水了</span><br><span class="line">cond.Wait() &#x2F;&#x2F; 啥时候来水？等通知！</span><br><span class="line">&#125;</span><br><span class="line">counter--</span><br><span class="line">log.Printf(&quot;OUTPUT A counter &#x3D; %d&quot;, counter)</span><br><span class="line">cond.Broadcast() &#x2F;&#x2F; 单发通知：已排水</span><br><span class="line">cond.L.Unlock() &#x2F;&#x2F; 解锁</span><br><span class="line">&#x2F;&#x2F;time.Sleep(2 * time.Second) &#x2F;&#x2F; 为了演示效果，睡眠5秒</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 排水口 2</span><br><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">cond.L.Lock() &#x2F;&#x2F; 上锁</span><br><span class="line">if counter &#x3D;&#x3D; 0 &#123; &#x2F;&#x2F; 没水了</span><br><span class="line">&#x2F;&#x2F;for counter &#x3D;&#x3D; 0 &#123; &#x2F;&#x2F; 没水了</span><br><span class="line">cond.Wait() &#x2F;&#x2F; 啥时候来水？等通知！</span><br><span class="line">&#125;</span><br><span class="line">counter--</span><br><span class="line">log.Printf(&quot;OUTPUT B counter &#x3D; %d&quot;, counter)</span><br><span class="line">cond.Broadcast() &#x2F;&#x2F; 单发通知：已排水</span><br><span class="line">cond.L.Unlock() &#x2F;&#x2F; 解锁</span><br><span class="line">&#x2F;&#x2F;time.Sleep(2 * time.Second) &#x2F;&#x2F; 为了演示效果，睡眠5秒</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注水口</span><br><span class="line">for &#123;</span><br><span class="line">cond.L.Lock() &#x2F;&#x2F; 上锁</span><br><span class="line">if counter &#x3D;&#x3D; maxSize &#123; &#x2F;&#x2F; 水满了</span><br><span class="line">&#x2F;&#x2F;for counter &#x3D;&#x3D; maxSize &#123; &#x2F;&#x2F; 水满了</span><br><span class="line">cond.Wait() &#x2F;&#x2F; 啥时候排水？等待通知！</span><br><span class="line">&#125;</span><br><span class="line">counter++</span><br><span class="line">log.Printf(&quot; INPUT   counter &#x3D; %d&quot;, counter)</span><br><span class="line">cond.Broadcast() &#x2F;&#x2F; 单发通知：已来水</span><br><span class="line">cond.L.Unlock() &#x2F;&#x2F; 解锁</span><br><span class="line">&#x2F;&#x2F;time.Sleep(1 * time.Second) &#x2F;&#x2F; 为了演示效果，睡眠1秒</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDemo4</span><br><span class="line">                ···</span><br><span class="line">2020&#x2F;10&#x2F;07 20:57:30 OUTPUT B counter &#x3D; 2</span><br><span class="line">2020&#x2F;10&#x2F;07 20:57:30 OUTPUT B counter &#x3D; 1</span><br><span class="line">2020&#x2F;10&#x2F;07 20:57:30 OUTPUT B counter &#x3D; 0</span><br><span class="line">2020&#x2F;10&#x2F;07 20:57:30 OUTPUT A counter &#x3D; -1</span><br><span class="line">2020&#x2F;10&#x2F;07 20:57:30 OUTPUT A counter &#x3D; -2</span><br><span class="line">2020&#x2F;10&#x2F;07 20:57:30 OUTPUT A counter &#x3D; -3</span><br><span class="line">2020&#x2F;10&#x2F;07 20:57:30 OUTPUT A counter &#x3D; -4</span><br><span class="line">                ···</span><br><span class="line">2020&#x2F;10&#x2F;07 20:57:31 OUTPUT B counter &#x3D; -7605</span><br><span class="line">2020&#x2F;10&#x2F;07 20:57:31  INPUT   counter &#x3D; -7604</span><br><span class="line">2020&#x2F;10&#x2F;07 20:57:31 OUTPUT A counter &#x3D; -7605</span><br><span class="line">2020&#x2F;10&#x2F;07 20:57:31 OUTPUT A counter &#x3D; -7606</span><br><span class="line">                ···</span><br></pre></td></tr></table></figure><p>通过日志输出可以看到，刚开始的时候还很正常，到后面的时候就变成负值了，一直在负增长，What？</p><p>在 <a href="/golang/ipc-mutex/" title="Go并发编程之传统同步—(1)互斥锁">Go并发编程之传统同步—(1)互斥锁</a> 文章中，程序因为没有加上互斥锁，出现过 counter 值异常的情况。</p><p>但这次程序这次加了互斥锁，按理说形成了一个临界区应该是没有问题了，所以问题应该不是出在临界区上，难道问题出在 <strong>Wait</strong> 上？</p><p>通过IDE<strong>追踪一下Wait的源码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func (c *Cond) Wait() &#123;</span><br><span class="line">&#x2F;&#x2F; 检查 c 是否是被复制的，如果是就 panic</span><br><span class="line">c.checker.check()</span><br><span class="line">&#x2F;&#x2F; 将当前 goroutine 加入等待队列</span><br><span class="line">t :&#x3D; runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line">c.L.Unlock()</span><br><span class="line">&#x2F;&#x2F; 等待当前 goroutine 被唤醒</span><br><span class="line">runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line">c.L.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来 Wait 内部的执行流程是，先执行了解锁，然后进入等待状态，接到通知之后，再执行加锁操作。</p><p>那按照这个代码逻辑结合输出日志，走一程序遍流程，看看能不能复现出 counter 为负值的情况：</p><blockquote><ol><li><p>注水口将 counter 累加到 10 之后，发送广播通知（Broadcast）。</p></li><li><p>goroutine A 在“第1步”之前的时候进入了等待通知（Wait），现在接收到了广播通知（Broadcast），从 runtime_notifyListWait() 返回，并且成功执行了加锁（Lock）操作。</p></li><li><p>goroutine B 在“第1步”之前的时候进入了等待通知（Wait），现在接收到了广播通知（Broadcast），从 runtime_notifyListWait() 返回，在执行加锁（Lock）操作的时候，发现 goroutine A 先抢占了临界区，所以一直阻塞在 c.L.Lock()。</p></li><li><p>goroutine A 虽然完成任务后会释放锁，但是每次也成功将锁抢占，所以就这样 一直将 counter 减到了 0，然后发送广播通知（Broadcast）、解锁（Unlock）。</p></li><li><p>goroutine B 在 goroutine A 解锁后，成功获得锁并从 Lock 方法中返回，接下来跳出 Wait 方法、跳出 if 判断，执行 counter–（0–），这时候 counter 的值是 -1</p></li></ol></blockquote><p>图示</p><p><img src="/images/golang/ipc-cond-01.jpg" alt="ipc-cond-01"></p><p>问题就出现在第五步，只要 goroutine B 加锁成功的时候，再判断一下 counter 是否为 0 就好了。</p><p>所以将 if counter == 0 改成 for counter == 0，这样上面的“第五步”就变成了</p><blockquote><p>5.goroutine B 在 goroutine A 解锁后，成功加锁（Lock）并从阻塞总返回，接下来跳出 Wait 方法、再次进入 for 循环，判断 counter == 0 结果为真，再次进入等待（Wait）。</p></blockquote><p>代码做出相应的修改后，再执行看结果，没有问题了。</p><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><h3 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h3><p>等待通知（Wait）肯定是要在临界区里面的，那发送通知（Signal、Broadcast）在哪里更好呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Luck()</span><br><span class="line">Wait()</span><br><span class="line">Broadcast()&#x2F;&#x2F; Signal()</span><br><span class="line">Unlock()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line"></span><br><span class="line">Luck()</span><br><span class="line">Wait()</span><br><span class="line">Unlock()</span><br><span class="line">Broadcast()&#x2F;&#x2F; Signal()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 两种写法都不会报错 </span><br></pre></td></tr></table></figure><p>在 go 的发送通知方法（Broadcast、Signal）上有这么一段话：</p><blockquote><p>// It is allowed but not required for the caller to hold c.L<br>// during the call.</p></blockquote><p>在我以往的 C 多线程开发的时候，发送通知总是在锁中的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;thread-&gt;mutex);</span><br><span class="line">&#x2F;&#x2F;              ...</span><br><span class="line">pthread_cond_signal(&amp;thread-&gt;cond);</span><br><span class="line">pthread_mutex_unlock(&amp;thread-&gt;mutex);</span><br></pre></td></tr></table></figure><p>在 <a href="https://linux.die.net/man/3/pthread_cond_signal">man</a> 手册中有写到：</p><blockquote><p>The pthread_cond_broadcast() or pthread_cond_signal() functions may be called by a thread whether or not it currently owns the mutex that threads calling pthread_cond_wait() or pthread_cond_timedwait() have associated with the condition variable during their waits; however, if predictable scheduling behavior is required, then that mutex shall be locked by the thread calling pthread_cond_broadcast() or pthread_cond_signal().</p></blockquote><p>个人对此并没有什么见解，就不乱下定论了，有想法的小伙伴可以在文章下面留言，一起讨论。</p><h3 id="等待通知"><a href="#等待通知" class="headerlink" title="等待通知"></a>等待通知</h3><p>消息通知是有即时性的，如果没有 goroutine 在等待通知，那么这次通知直接被丢弃。</p><h3 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h3><p><a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/fifo.go">https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/fifo.go</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Wait() 内会执行解锁、等待、加锁。</li><li>Wait() 必须在 for 循环里面。</li><li>Wait() 方法会把当前的 goroutine 添加到通知队列的队尾。</li><li>单发通知，唤醒通知队列第一个排队的 goroutine。</li><li>广播通知，唤醒通知队列里面全部的 goroutine。</li><li>程序示例只是为了演示效果，实际的开发中，生产者和消费者应该是异步消费，不应该使用同一个互斥锁。</li></ol><p><a href="https://github.com/zuoshuwen/go-example/blob/master/e002/a01_test.go">文章示例代码</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同步</tag>
      
      <tag>条件变量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程之传统同步—(1)互斥锁</title>
    <link href="/golang/ipc-mutex/"/>
    <url>/golang/ipc-mutex/</url>
    
    <content type="html"><![CDATA[<p>先回顾一下，在 C 或者其它编程语言的并发编程中，主要存在两种<strong>通信</strong>（IPC）：</p><blockquote><ul><li><strong>进程间通信</strong>：管道、消息队列、信号等</li><li><strong>线程间通信</strong>：互斥锁、条件变量等</li></ul></blockquote><p>利用以上通信手段采取的同步措施，最终是为了达到以下两种目的：</p><blockquote><ul><li><strong>维持共享数据一致性，并发安全</strong></li><li><strong>控制流程管理，更好的协同工作</strong></li></ul></blockquote><p>Go语言中除了保留了传统的同步支持，还提供了特有的 CSP 并发编程模型。</p><a id="more"></a><h2 id="传统同步"><a href="#传统同步" class="headerlink" title="传统同步"></a>传统同步</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>接下来通过一个“做累加”的示例程序，展示<strong>竞争状态</strong>（race condition）。</p><h4 id="不加锁"><a href="#不加锁" class="headerlink" title="不加锁"></a>不加锁</h4><p>开启 5000 个 goroutine，让每个 goroutine 给 counter 加 1，最终在所有 goroutine 都完成任务时 counter 的值应该为 5000，先试下不加锁的示例程序表现如何</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDemo1</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">counter := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">counter++</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">t.Logf(<span class="string">&quot;counter = %d&quot;</span>, counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDemo1</span><br><span class="line">    a1_test.go:18: counter &#x3D; 4663</span><br><span class="line">--- PASS: TestDemo1 (1.00s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><p>多试几次，结果一直是小于 5000 的不定值。<br>竞争状态下程序行为的图像表示<br><img src="/images/golang/ipc-mutex-01.jpg" alt="ipc-mutex-01"></p><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>将刚刚的代码稍作改动</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDemo2</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> mut sync.Mutex <span class="comment">// 声明锁</span></span><br><span class="line">counter := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">mut.Lock() <span class="comment">// 加锁</span></span><br><span class="line">counter++</span><br><span class="line">mut.Unlock() <span class="comment">// 解锁</span></span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">t.Logf(<span class="string">&quot;counter = %d&quot;</span>, counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDemo2</span><br><span class="line">    a1_test.go:35: counter &#x3D; 5000</span><br><span class="line">--- PASS: TestDemo2 (1.01s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><p>counter = 5000，返回的结果对了。</p><p>这就是<strong>互斥锁</strong>，在代码上创建一个<strong>临界区</strong>（critical section），保证串行操作（同一时间只有一个 goroutine 执行临界区代码）。</p><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>那么互斥锁是怎么串行的呢？把每一步的执行过程打印出来看下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDemo3</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> mut sync.Mutex</span><br><span class="line">counter := <span class="number">0</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">mut.Lock()</span><br><span class="line">log.Println(<span class="string">&quot;goroutine B Lock&quot;</span>)</span><br><span class="line">counter = <span class="number">1</span></span><br><span class="line">log.Println(<span class="string">&quot;goroutine B counter =&quot;</span>, counter)</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">mut.Unlock()</span><br><span class="line">log.Println(<span class="string">&quot;goroutine B Unlock&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">mut.Lock()</span><br><span class="line">log.Println(<span class="string">&quot;goroutine A Lock&quot;</span>)</span><br><span class="line">counter = <span class="number">2</span></span><br><span class="line">log.Println(<span class="string">&quot;goroutine A counter =&quot;</span>, counter)</span><br><span class="line">mut.Unlock()</span><br><span class="line">log.Println(<span class="string">&quot;goroutine A Unlock&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDemo3</span><br><span class="line">2020&#x2F;09&#x2F;30 22:14:00 goroutine B Lock</span><br><span class="line">2020&#x2F;09&#x2F;30 22:14:00 goroutine B counter &#x3D; 1</span><br><span class="line">2020&#x2F;09&#x2F;30 22:14:05 goroutine B Unlock</span><br><span class="line">2020&#x2F;09&#x2F;30 22:14:05 goroutine A Lock</span><br><span class="line">2020&#x2F;09&#x2F;30 22:14:05 goroutine A counter &#x3D; 2</span><br><span class="line">2020&#x2F;09&#x2F;30 22:14:05 goroutine A Unlock</span><br><span class="line">--- PASS: TestDemo3 (5.00s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><p>通过每个操作记录下来的时间可以看出，goroutine A 的 Lock 一直阻塞到了 goroutine B 的 Unlock。<br><img src="/images/golang/ipc-mutex-02.jpg" alt="ipc-mutex-01"></p><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>这时候有个疑问，那 goroutine B 上的锁，goroutine A 能解锁吗？修改一下刚才的代码，试一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDemo5</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> mut sync.Mutex</span><br><span class="line">counter := <span class="number">0</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">mut.Lock()</span><br><span class="line">log.Println(<span class="string">&quot;goroutine B Lock&quot;</span>)</span><br><span class="line">counter = <span class="number">1</span></span><br><span class="line">log.Println(<span class="string">&quot;goroutine B counter =&quot;</span>, counter)</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line"><span class="comment">//mut.Unlock()</span></span><br><span class="line"><span class="comment">//log.Println(&quot;goroutine B Unlock&quot;)</span></span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">mut.Unlock()</span><br><span class="line">log.Println(<span class="string">&quot;goroutine A Unlock&quot;</span>)</span><br><span class="line">counter = <span class="number">2</span></span><br><span class="line">log.Println(<span class="string">&quot;goroutine A counter =&quot;</span>, counter)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDemo5</span><br><span class="line">2020&#x2F;09&#x2F;30 22:15:03 goroutine B Lock</span><br><span class="line">2020&#x2F;09&#x2F;30 22:15:03 goroutine B counter &#x3D; 1</span><br><span class="line">2020&#x2F;09&#x2F;30 22:15:04 goroutine A Unlock</span><br><span class="line">2020&#x2F;09&#x2F;30 22:15:04 goroutine A counter &#x3D; 2</span><br><span class="line">--- PASS: TestDemo5 (3.01s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><p>测试通过，未报错，counter 的值也被成功修改，证明B上的锁，是可以被A解开的。</p><p>再进一步，goroutine A 不解锁，直接修改已经被 goroutine B 锁住的 counter 的值可以吗？试一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDemo6</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> mut sync.Mutex</span><br><span class="line">counter := <span class="number">0</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">mut.Lock()</span><br><span class="line">log.Println(<span class="string">&quot;goroutine B Lock&quot;</span>)</span><br><span class="line">counter = <span class="number">1</span></span><br><span class="line">log.Println(<span class="string">&quot;goroutine B counter =&quot;</span>, counter)</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">mut.Unlock()</span><br><span class="line">log.Println(<span class="string">&quot;goroutine B Unlock&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="comment">//log.Println(&quot;goroutine A Unlock&quot;)</span></span><br><span class="line"><span class="comment">//mut.Unlock()</span></span><br><span class="line">counter = <span class="number">2</span></span><br><span class="line">log.Println(<span class="string">&quot;goroutine A counter =&quot;</span>, counter)</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D; RUN   TestDemo6</span><br><span class="line">2020&#x2F;09&#x2F;30 22:15:43 goroutine B Lock</span><br><span class="line">2020&#x2F;09&#x2F;30 22:15:43 goroutine B counter &#x3D; 1</span><br><span class="line">2020&#x2F;09&#x2F;30 22:15:44 goroutine A counter &#x3D; 2</span><br><span class="line">2020&#x2F;09&#x2F;30 22:15:48 goroutine B Unlock</span><br><span class="line">--- PASS: TestDemo6 (11.00s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><p>测试通过，未报错，证明B上的锁，A可以不用解锁直接改。</p><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><h3 id="锁的两种通常处理方式"><a href="#锁的两种通常处理方式" class="headerlink" title="锁的两种通常处理方式"></a>锁的两种通常处理方式</h3><ul><li>一种是没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁叫做<strong>自旋锁</strong>，它不用将线程阻塞起来(NON-BLOCKING)；</li><li>还有一种处理方式就是把自己阻塞起来，等待重新调度请求，这种叫做互斥锁。</li></ul><h3 id="饥饿模式"><a href="#饥饿模式" class="headerlink" title="饥饿模式"></a>饥饿模式</h3><p>当互斥锁不断地试图获得一个永远无法获得的锁时，它可能会遇到饥饿问题。<br>在版本1.9中，Go通过添加一个新的饥饿模式来解决先前的问题，所有等待锁定超过一毫秒的 goroutine，也称为有界等待，将被标记为饥饿。当标记为饥饿时，解锁方法现在将把锁直接移交给第一位等待着。</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁和上面的多也差不多，有这么几种情况</p><ul><li>在写锁已被锁定的情况下试图锁定写锁，会阻塞当前的 goroutine。</li><li>在写锁已被锁定的情况下试图锁定读锁，会阻塞当前的 goroutine。</li><li>在读锁已被锁定的情况下试图锁定写锁，会阻塞当前的 goroutine。</li><li>在读锁已被锁定的情况下试图锁定读锁，不会阻塞当前的 goroutine。</li></ul><h3 id="panic错误"><a href="#panic错误" class="headerlink" title="panic错误"></a>panic错误</h3><p>无论是互斥锁还是读写锁在程序运行时一定是成对的，不然就会引发不可恢复的panic。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>锁一定要用对地方，特别是要注意Lock产生的阻塞对性能的影响。</li><li>在各种程序的逻辑分支下，都要确保锁的成对出现。</li><li>读写锁是对互斥锁的一个扩展，提高了程序的可读性。</li><li>临界区是需要每个 goroutine 主动遵守的，说白了就是每个 goroutine 的代码都存在 Lock。</li></ol><p><a href="https://github.com/zuoshuwen/go-example/blob/master/e001/a01_test.go">文章示例代码</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同步</tag>
      
      <tag>互斥锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello Sown</title>
    <link href="/Hello-Sown/"/>
    <url>/Hello-Sown/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/hello-world/"/>
    <url>/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
