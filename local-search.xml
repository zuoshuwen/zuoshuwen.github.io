<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>学习资源索引</title>
    <link href="/index/"/>
    <url>/index/</url>
    
    <content type="html"><![CDATA[<h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><p><a href="https://hardcore.feishu.cn/docs/doccngKKrYQWSYu4Rr3puVq20wc">硬核课堂</a><br><a href="https://strikefreedom.top/">strikefreedom</a></p><h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><p><a href="https://lessisbetter.site/">Go语言充电站</a><br><a href="https://eddycjy.com/">煎鱼</a><br><a href="https://lailin.xyz/">mohuishou</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis文章索引</title>
    <link href="/redis/a/"/>
    <url>/redis/a/</url>
    
    <content type="html"><![CDATA[<p>总结=&gt;背</p><h1 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h1><ol><li><a href="/redis/use/" title="Redis核心技术与实战">Redis核心技术与实战</a></li><li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzIyOTYxNDI5OA==&action=getalbum&album_id=1699766580538032128&scene=173&subscene=&sessionid=undefined&enterid=0&from_msgid=2247484679&from_itemidx=1&count=3&nolastread=1#wechat_redirect" title="" target="_blank">水滴与银弹</a></li></ol><h1 id=""><a href="#" class="headerlink" title="====================================="></a>=====================================</h1><h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="https://strikefreedom.top/multiple-threaded-network-model-in-redis">Redis 多线程网络模型全面揭秘</a><br><a href="http://gk.link/a/10keR">极客时间《Redis核心技术与实战》</a><br><a href="https://u.jd.com/6J6Ebnu">《Redis设计与实现》</a><br><a href="https://u.jd.com/6r61kdn">《Redis使用手册》</a><br><a href="http://wonderxxf.gitee.io/coderfan/categories/Redis/">奔跑的小石头</a><br><a href="http://zhangtielei.com/">张铁蕾</a></p><h1 id="全局哈希表"><a href="#全局哈希表" class="headerlink" title="全局哈希表"></a>全局哈希表</h1><p>保存了每个键和值<br><img src="/images/redis/global-hashtable-01.png" height=100 alt="全局哈希表"/></p><h1 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h1><p>用来封装各种数据结构的结构，包含信息：元数据（8Byte）、ptr(实际数据指针，8Byte)</p><h1 id="数据类型与底层数据结构对应关系"><a href="#数据类型与底层数据结构对应关系" class="headerlink" title="数据类型与底层数据结构对应关系"></a>数据类型与底层数据结构对应关系</h1><p>5 v 6<br><img src="/images/redis/datastruct-01.png" height=100 alt="数据类型与底层数据结构对应关系"/></p><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>底层使用 简单动态字符串（Simple Dynamic String，SDS。占用64Byte大小。<br><img src="/images/redis/string-sds-01.png" height=100 alt="SDS"/></p><h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><h1 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h1><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h1 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h1><h1 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h1><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><h2 id="性能因素"><a href="#性能因素" class="headerlink" title="性能因素"></a>性能因素</h2><ul><li>CPU</li><li>内存</li><li>存储持久化</li><li>网络通信</li></ul><h2 id="两大维度，三大主线"><a href="#两大维度，三大主线" class="headerlink" title="两大维度，三大主线"></a>两大维度，三大主线</h2><p><img src="/images/redis/redis-01.png" alt="两大维度，三大主线"></p><h2 id="Redis问题画像"><a href="#Redis问题画像" class="headerlink" title="Redis问题画像"></a>Redis问题画像</h2><p><img src="/images/redis/redis-02.png" alt="Redis问题画像"></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h4 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h4><p><img src="/images/redis/global-hashtable-02.png" alt="哈希冲突"></p><h4 id="双hashtable渐进式"><a href="#双hashtable渐进式" class="headerlink" title="双hashtable渐进式"></a>双hashtable渐进式</h4><p><img src="/images/redis/global-hashtable-03.png" alt="双hashtable渐进式"></p><h3 id="压缩表"><a href="#压缩表" class="headerlink" title="压缩表"></a>压缩表</h3><p><img src="/images/redis/ziplist-01.png" alt="压缩表"></p><h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p><img src="/images/redis/skiplist-01.png" alt="跳表"></p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><img src="/images/redis/O-01.png" alt="时间复杂度"></p><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p><img src="/images/redis/io-epoll-01.png" alt="IO模型"></p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="AOF-1"><a href="#AOF-1" class="headerlink" title="AOF"></a>AOF</h3><p><img src="/images/redis/storage-aof-01.png" alt="aof"></p><ul><li>always：同步写回</li><li>everysec：每秒写回</li><li>no：操作系统控制写回</li></ul><p><img src="/images/redis/storage-aof-02.png" alt="对比"></p><h4 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h4><p>只保存最新的命令，减小AOF大小</p><ul><li>后台线程bgwriteaof执行</li><li>AOF缓存、AOF重写缓冲</li></ul><h3 id="RDB-1"><a href="#RDB-1" class="headerlink" title="RDB"></a>RDB</h3><p><img src="/images/redis/storage-rdb-01.png" alt="COW"></p><h4 id="增量快照"><a href="#增量快照" class="headerlink" title="增量快照"></a>增量快照</h4><h4 id="RDB、AOF混合快照"><a href="#RDB、AOF混合快照" class="headerlink" title="RDB、AOF混合快照"></a>RDB、AOF混合快照</h4><h2 id="主从-1"><a href="#主从-1" class="headerlink" title="主从"></a>主从</h2><p><img src="/images/redis/master-slave-01.png" alt="主从"></p><p><img src="/images/redis/master-slave-02.png" alt="同步过程"></p><p><img src="/images/redis/master-slave-03.png" alt="主从从"></p><p><img src="/images/redis/master-slave-04.png" alt="repl_backlog_buffer"></p><p><img src="/images/redis/master-slave-05.png" alt="增量复制"></p><h2 id="哨兵-1"><a href="#哨兵-1" class="headerlink" title="哨兵"></a>哨兵</h2><h3 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h3><p>哨兵使用PING命令检测他和主、从的网络连接情况，用来判断实例的状态，如果是从库，会直接标记下线，但是从库不会这么简单的判断。</p><h3 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h3><p><img src="/images/redis/sentinel-01.png" alt="客观下线"></p><h3 id="新主库选择"><a href="#新主库选择" class="headerlink" title="新主库选择"></a>新主库选择</h3><h2 id="mmap、零拷贝"><a href="#mmap、零拷贝" class="headerlink" title="mmap、零拷贝"></a>mmap、零拷贝</h2><h2 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h2><p>redis续租</p><h2 id="clion-远程调试"><a href="#clion-远程调试" class="headerlink" title="clion 远程调试"></a>clion 远程调试</h2><p>linux 安装 redis，只是make就可以，不用make all</p><p>clion 配置 sftp、gdb remote debug</p><p>linux 执行 gdbserver :1234 ./src/redis-server</p><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>主要就是如何用clion远程调试c（gdb debug），然后是clion如何调试redis</p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文章索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis源码剖析与实战</title>
    <link href="/redis/source-code/"/>
    <url>/redis/source-code/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="动态字符串、SDS"><a href="#动态字符串、SDS" class="headerlink" title="动态字符串、SDS"></a>动态字符串、SDS</h2><p>char* 的不足：</p><ul><li>操作效率低：获取长度需遍历，O(N)复杂度</li><li>二进制不安全：无法存储包含 \0 的数据</li></ul><p>SDS 的优势：</p><ul><li>操作效率高：获取长度无需遍历，O(1)复杂度</li><li>二进制安全：因单独记录长度字段，所以可存储包含 \0 的数据</li><li>兼容 C 字符串函数，可直接使用字符串 API</li></ul><p>另外 Redis 在操作 SDS 时，为了避免频繁操作字符串时，每次「申请、释放」内存的开销，还做了这些优化：</p><ul><li>内存预分配：SDS 扩容，会多申请一些内存（小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容）</li><li>多余内存不释放：SDS 缩容，不释放多余的内存，下次使用可直接复用这些内存</li></ul><p>这种策略，是以多占一些内存的方式，换取「追加」操作的速度。</p><p>这个内存预分配策略，详细逻辑可以看 sds.c 的 sdsMakeRoomFor 函数。</p><p>课后题：SDS 字符串在 Redis 内部模块实现中也被广泛使用，你能在 Redis server 和客户端的实现中，找到使用 SDS 字符串的地方么？</p><ol><li>Redis 中所有 key 的类型就是 SDS（详见 db.c 的 dbAdd 函数）</li><li>Redis Server 在读取 Client 发来的请求时，会先读到一个缓冲区中，这个缓冲区也是 SDS（详见 server.h 中 struct client 的 querybuf 字段）</li><li>写操作追加到 AOF 时，也会先写到 AOF 缓冲区，这个缓冲区也是 SDS （详见 server.h 中 struct client 的 aof_buf 字段）</li></ol><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><ol><li><p>Redis 中的 dict 数据结构，采用「链式哈希」的方式存储，当哈希冲突严重时，会开辟一个新的哈希表，翻倍扩容，并采用「渐进式 rehash」的方式迁移数据</p></li><li><p>所谓「渐进式 rehash」是指，把很大块迁移数据的开销，平摊到多次小的操作中，目的是降低主线程的性能影响</p></li><li><p>Redis 中凡是需要 O(1) 时间获取 k-v 数据的场景，都使用了 dict 这个数据结构，也就是说 dict 是 Redis 中重中之重的「底层数据结构」</p></li><li><p>dict 封装好了友好的「增删改查」API，并在适当时机「自动扩容、缩容」，这给上层数据类型（Hash/Set/Sorted Set）、全局哈希表的实现提供了非常大的便利</p></li><li><p>例如，Redis 中每个 DB 存放数据的「全局哈希表、过期key」都用到了 dict：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// server.h</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisDb</span> &#123;</span>   dict *dict; <span class="hljs-comment">// 全局哈希表，数据键值对存在这</span>   dict *expires; <span class="hljs-comment">// 过期 key + 过期时间 存在这</span>   ...&#125;</code></pre></div></li><li><p>「全局哈希表」在触发渐进式 rehash 的情况有 2 个：</p></li></ol><ul><li>增删改查哈希表时：每次迁移 1 个哈希桶（文章提到的 dict.c 中的 _dictRehashStep 函数）</li><li>定时 rehash：如果 dict 一直没有操作，无法渐进式迁移数据，那主线程会默认每间隔 100ms 执行一次迁移操作。这里一次会以 100 个桶为基本单位迁移数据，并限制如果一次操作耗时超时 1ms 就结束本次任务，待下次再次触发迁移（文章没提到这个，详见 dict.c 的 dictRehashMilliseconds 函数）</li></ul><p>（注意：定时 rehash 只会迁移全局哈希表中的数据，不会定时迁移 Hash/Set/Sorted Set 下的哈希表的数据，这些哈希表只会在操作数据时做实时的渐进式 rehash）</p><ol start="7"><li>dict 在负载因子超过 1 时（used: bucket size &gt;= 1），会触发 rehash。但如果 Redis 正在 RDB 或 AOF rewrite，为避免父进程大量写时复制，会暂时关闭触发 rehash。但这里有个例外，如果负载因子超过了 5（哈希冲突已非常严重），依旧会强制做 rehash（重点）</li><li>dict 在 rehash 期间，查询旧哈希表找不到结果，还需要在新哈希表查询一次</li></ol><p>课后题：Hash 函数会影响 Hash 表的查询效率及哈希冲突情况，那么，你能从 Redis 的源码中，找到 Hash 表使用的是哪一种 Hash 函数吗？</p><p>找到 dict.c 的 dictFind 函数，可以看到查询一个 key 在哈希表的位置时，调用了 dictHashKey 计算 key 的哈希值：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-function">dictEntry *<span class="hljs-title">dictFind</span><span class="hljs-params">(dict *d, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *key)</span> </span>&#123;   <span class="hljs-comment">// 计算 key 的哈希值</span>   h = dictHashKey(d, key);   ...&#125;</code></pre></div><p>继续跟代码可以看到 dictHashKey 调用了 struct dict 下 dictType 的 hashFunction 函数：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// dict.h</span>dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)</code></pre></div><p>而这个 hashFunction 是在初始化一个 dict 时，才会指定使用哪个哈希函数的。</p><p>当 Redis Server 在启动时会创建「全局哈希表」：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 初始化 db 下的全局哈希表</span><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; server.dbnum; j++) &#123;   <span class="hljs-comment">// dbDictType 中指定了哈希函数</span>   server.db[j].dict = dictCreate(&amp;dbDictType,<span class="hljs-literal">NULL</span>);...&#125;</code></pre></div><p>这个 dbDictType struct 指定了具体的哈希函数，跟代码进去能看到，使用了 SipHash 算法，具体实现逻辑在 siphash.c。</p><p>（SipHash 哈希算法是在 Redis 4.0 才开始使用的，3.0-4.0 使用的是 MurmurHash2 哈希算法，3.0 之前是 DJBX33A 哈希算法）</p><h2 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h2><ol><li>要想理解 Redis 数据类型的设计，必须要先了解 redisObject。</li></ol><p>Redis 的 key 是 String 类型，但 value 可以是很多类型（String/List/Hash/Set/ZSet等），所以 Redis 要想存储多种数据类型，就要设计一个通用的对象进行封装，这个对象就是 redisObject。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// server.h</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span>   <span class="hljs-keyword">unsigned</span> type:<span class="hljs-number">4</span>;   <span class="hljs-keyword">unsigned</span> encoding:<span class="hljs-number">4</span>;   <span class="hljs-keyword">unsigned</span> lru:LRU_BITS;   <span class="hljs-keyword">int</span> refcount;   <span class="hljs-keyword">void</span> *ptr;&#125; robj;</code></pre></div><p>其中，最重要的 2 个字段：</p><ul><li>type：面向用户的数据类型（String/List/Hash/Set/ZSet等）</li><li>encoding：每一种数据类型，可以对应不同的底层数据结构来实现（SDS/ziplist/intset/hashtable/skiplist等）</li></ul><p>例如 String，可以用 embstr（嵌入式字符串，redisObject 和 SDS 一起分配内存），也可以用 rawstr（redisObject 和 SDS 分开存储）实现。</p><p>又或者，当用户写入的是一个「数字」时，底层会转成 long 来存储，节省内存。</p><p>同理，Hash/Set/ZSet 在数据量少时，采用 ziplist 存储，否则就转为 hashtable 来存。</p><p>所以，redisObject 的作用在于：</p><ul><li>为多种数据类型提供统一的表示方式</li><li>同一种数据类型，底层可以对应不同实现，节省内存</li><li>支持对象共享和引用计数，共享对象存储一份，可多次使用，节省内存</li></ul><p>redisObject 更像是连接「上层数据类型」和「底层数据结构」之间的桥梁。</p><ol start="2"><li>关于 String 类型的实现，底层对应 3 种数据结构：</li></ol><ul><li>embstr：小于 44 字节，嵌入式存储，redisObject 和 SDS 一起分配内存，只分配 1 次内存</li><li>rawstr：大于 44 字节，redisObject 和 SDS 分开存储，需分配 2 次内存</li><li>long：整数存储（小于 10000，使用共享对象池存储，但有个前提：Redis 没有设置淘汰策略，详见 object.c 的 tryObjectEncoding 函数）</li></ul><ol start="3"><li>ziplist 的特点：</li></ol><ul><li>连续内存存储：每个元素紧凑排列，内存利用率高</li><li>变长编码：存储数据时，采用变长编码（满足数据长度的前提下，尽可能少分配内存）</li><li>寻找元素需遍历：存放太多元素，性能会下降（适合少量数据存储）</li><li>级联更新：更新、删除元素，会引发级联更新（因为内存连续，前面数据膨胀/删除了，后面要跟着一起动）</li></ul><p>List、Hash、Set、ZSet 底层都用到了 ziplist。</p><ol start="4"><li>intset 的特点：</li></ol><ul><li>Set 存储如果都是数字，采用 intset 存储</li><li>变长编码：数字范围不同，intset 会选择 int16/int32/int64 编码（intset.c 的 _intsetValueEncoding 函数）</li><li>有序：intset 在存储时是有序的，这意味着查找一个元素，可使用「二分查找」（intset.c 的 intsetSearch 函数）</li><li>编码升级/降级：添加、更新、删除元素，数据范围发生变化，会引发编码长度升级或降级</li></ul><p>课后题：SDS 判断是否使用嵌入式字符串的条件是 44 字节，你知道为什么是 44 字节吗？</p><p>嵌入式字符串会把 redisObject 和 SDS 一起分配内存，那在存储时结构是这样的：</p><ul><li>redisObject：16 个字节</li><li>SDS：sdshdr8（3 个字节）+ SDS 字符数组（N 字节 + \0 结束符 1 个字节）</li></ul><p>Redis 规定嵌入式字符串最大以 64 字节存储，所以 N = 64 - 16(redisObject) - 3(sdshr8) - 1(\0)， N = 44 字节。</p><h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><ol><li>ZSet 当数据比较少时，采用 ziplist 存储，每个 member/score 元素紧凑排列，节省内存</li><li>当数据超过阈值（zset-max-ziplist-entries、zset-max-ziplist-value）后，转为 hashtable + skiplist 存储，降低查询的时间复杂度</li><li>hashtable 存储 member-&gt;score 的关系，所以 ZSCORE 的时间复杂度为 O(1)</li><li>skiplist 是一个「有序链表 + 多层索引」的结构，把查询元素的复杂度降到了 O(logN)，服务于 ZRANGE/ZREVRANGE 这类命令</li><li>skiplist 的多层索引，采用「随机」的方式来构建，也就是说每次添加一个元素进来，要不要对这个元素建立「多层索引」？建立「几层索引」？都要通过「随机数」的方式来决定</li><li>每次随机一个 0-1 之间的数，如果这个数小于 0.25（25% 概率），那就给这个元素加一层指针，持续随机直到大于 0.25 结束，最终确定这个元素的层数（层数越高，概率越低，且限制最多 64 层，详见 t_zset.c 的 zslRandomLevel 函数）</li><li>这个预设「概率」决定了一个跳表的内存占用和查询复杂度：概率设置越低，层数越少，元素指针越少，内存占用也就越少，但查询复杂会变高，反之亦然。这也是 skiplist 的一大特点，可通过控制概率，进而控制内存和查询效率</li><li>skiplist 新插入一个节点，只需修改这一层前后节点的指针，不影响其它节点的层数，降低了操作复杂度（相比平衡二叉树的再平衡，skiplist 插入性能更优）</li></ol><p>关于 Redis 的 ZSet 为什么用 skiplist 而不用平衡二叉树实现的问题，原因是：</p><ul><li>skiplist 更省内存：25% 概率的随机层数，可通过公式计算出 skiplist 平均每个节点的指针数是 1.33 个，平衡二叉树每个节点指针是 2 个（左右子树）</li><li>skiplist 遍历更友好：skiplist 找到大于目标元素后，向后遍历链表即可，平衡树需要通过中序遍历方式来完成，实现也略复杂</li><li>skiplist 更易实现和维护：扩展 skiplist 只需要改少量代码即可完成，平衡树维护起来较复杂</li></ul><p>课后题：在使用跳表和哈希表相结合的双索引机制时，在获得高效范围查询和单点查询的同时，你能想到有哪些不足之处么？</p><p>这种发挥「多个数据结构」的优势，来完成某个功能的场景，最大的特点就是「空间换时间」，所以内存占用多是它的不足。</p><p>不过也没办法，想要高效率查询，就得牺牲内存，鱼和熊掌不可兼得。</p><p>不过 skiplist 在实现时，Redis 作者应该也考虑到这个问题了，就是上面提到的这个「随机概率」，Redis 后期维护可以通过调整这个概率，进而达到「控制」查询效率和内存平衡的结果。当然，这个预设值是固定写死的，不可配置，应该是 Redis 作者经过测试和权衡后的设定，我们这里只需要知晓原理就好。</p><h2 id="ZipList、QuickList、ListPack"><a href="#ZipList、QuickList、ListPack" class="headerlink" title="ZipList、QuickList、ListPack"></a>ZipList、QuickList、ListPack</h2><ol><li>ziplist 设计的初衷就是「节省内存」，在存储数据时，把内存利用率发挥到了极致：</li></ol><ul><li>数字按「整型」编码存储，比直接当字符串存内存占用少</li><li>数据「长度」字段，会根据内容的大小选择最小的长度编码</li><li>甚至对于极小的数据，干脆把内容直接放到了「长度」字段中（前几个位表示长度，后几个位存数据）</li></ul><ol start="2"><li>但 ziplist 的劣势也很明显：</li></ol><ul><li>寻找元素只能挨个遍历，存储过长数据，查询性能很低</li><li>每个元素中保存了「上一个」元素的长度（为了方便反向遍历），这会导致上一个元素内容发生修改，长度超过了原来的编码长度，下一个元素的内容也要跟着变，重新分配内存，进而就有可能再次引起下一级的变化，一级级更新下去，频繁申请内存</li></ul><ol start="3"><li>想要缓解 ziplist 的问题，比较简单直接的方案就是，多个数据项，不再用一个 ziplist 来存，而是分拆到多个 ziplist 中，每个 ziplist 用指针串起来，这样修改其中一个数据项，即便发生级联更新，也只会影响这一个 ziplist，其它 ziplist 不受影响，这种方案就是 quicklist：</li></ol><p>qucklist: ziplist1(也叫quicklistNode) &lt;-&gt; ziplist2 &lt;-&gt; ziplist3 &lt;-&gt; …</p><ol start="4"><li>List 数据类型底层实现，就是用的 quicklist，因为它是一个链表，所以 LPUSH/LPOP/RPUSH/RPOP 的复杂度是 O(1)</li><li>List 中每个 ziplist 节点可以存的元素个数/总大小，可以通过 list-max-ziplist-size 配置：</li></ol><ul><li>正数：ziplist 最多包含几个数据项</li><li>负数：取值 -1 ~ -5，表示每个 ziplist 存储最大的字节数，默认 -2，每个ziplist 8KB</li></ul><p>ziplist 超过上述任一配置，添加新元素就会新建 ziplist 插入到链表中。</p><ol start="6"><li>List 因为更多是两头操作，为了节省内存，还可以把中间的 ziplist「压缩」，具体可看 list-compress-depth 配置项，默认配置不压缩</li><li>要想彻底解决 ziplist 级联更新问题，本质上要修改 ziplist 的存储结构，也就是不要让每个元素保存「上一个」元素的长度即可，所以才有了 listpack</li><li>listpack 每个元素项不再保存上一个元素的长度，而是优化元素内字段的顺序，来保证既可以从前也可以向后遍历</li><li>listpack 是为了替代 ziplist 为设计的，但因为 List/Hash/Set/ZSet 都严重依赖 ziplist，所以这个替换之路很漫长，目前只有 Stream 数据类型用到了 listpack</li></ol><h2 id="Radix-Tree"><a href="#Radix-Tree" class="headerlink" title="Radix Tree"></a>Radix Tree</h2><p>作为有序索引，Radix Tree 也能提供范围查询，和我们日常使用的 B+ 树，以及第5讲中介绍的跳表相比，你觉得 Radix Tree 有什么优势和不足么？</p><ol><li>Radix Tree 优势</li></ol><ul><li>本质上是前缀树，所以存储有「公共前缀」的数据时，比 B+ 树、跳表节省内存</li><li>没有公共前缀的数据项，压缩存储，value 用 listpack 存储，也可以节省内存</li><li>查询复杂度是 O(K)，只与「目标长度」有关，与总数据量无关</li><li>这种数据结构也经常用在搜索引擎提示、文字自动补全等场景</li></ul><p>Stream 在存消息时，推荐使用默认自动生成的「时间戳+序号」作为消息 ID，不建议自己指定消息 ID，这样才能发挥 Radix Tree 公共前缀的优势。</p><ol start="2"><li>Radix Tree 不足</li></ol><ul><li>如果数据集公共前缀较少，会导致内存占用多</li><li>增删节点需要处理其它节点的「分裂、合并」，跳表只需调整前后指针即可</li><li>B+ 树、跳表范围查询友好，直接遍历链表即可，Radix Tree 需遍历树结构</li><li>实现难度高比 B+ 树、跳表复杂</li></ul><p>每种数据结构都是在面对不同问题场景下，才被设计出来的，结合各自场景中的数据特点，使用优势最大的数据结构才是正解。</p><h1 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h1><h2 id="Redis-Server"><a href="#Redis-Server" class="headerlink" title="Redis Server"></a>Redis Server</h2><p>Redis 启动流程，主要的工作有：</p><ol><li>初始化前置操作（设置时区、随机种子）</li><li>初始化 Server 的各种默认配置（server.c 的 initServerConfig 函数），默认配置见 server.h 中的 CONFIG_DEFAULT_XXX，比较典型的配置有：</li></ol><ul><li>默认端口</li><li>定时任务频率</li><li>数据库数量</li><li>AOF 刷盘策略</li><li>淘汰策略</li><li>数据结构转换阈值</li><li>主从复制参数</li></ul><ol start="3"><li>加载配置启动参数，覆盖默认配置（config.c 的 loadServerConfig 函数）：</li></ol><ul><li>解析命令行参数</li><li>解析配置文件</li></ul><ol start="3"><li>初始化 Server（server.c 的 initServer 函数），例如会初始化：</li></ol><ul><li>共享对象池</li><li>客户端链表</li><li>从库链表</li><li>监听端口</li><li>全局哈希表</li><li>LRU 池</li><li>注册定时任务函数</li><li>注册监听请求函数</li></ul><ol start="4"><li>启动事件循环（ae.c 的 aeMain 函数）</li></ol><ul><li>处理请求</li><li>处理定时任务</li></ul><p>这里补充一下，初始化 Server 完成后，Redis 还会启动 3 类后台线程（server.c 的 InitServerLast 函数），协助主线程工作（异步释放 fd、AOF 每秒刷盘、lazyfree）。</p><p>课后题：Redis 源码的 main 函数在调用 initServer 函数之前，会执行如下的代码片段，你知道这个代码片段的作用是什么吗？</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;   ...   server.supervised = redisIsSupervised(server.supervised_mode);   <span class="hljs-keyword">int</span> background = server.daemonize &amp;&amp; !server.supervised;   <span class="hljs-keyword">if</span> (background) daemonize();   ...&#125;</code></pre></div><p>Redis 可以配置以守护进程的方式启动（配置文件 daemonize = yes），也可以把 Redis 托管给 upstart 或 systemd 来启动 / 停止（supervised = upstart|systemd|auto）。</p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><ol><li>单线程服务器模型，面临的最大的问题就是，一个线程如何处理多个客户端请求？解决这种问题的办法就是「IO 多路复用」。它本质上是应用层不用维护多个客户端的连接状态，而是把它们「托管」给了操作系统，操作系统维护这些连接的状态变化，之后应用层只管问操作系统，哪些 socket 有数据可读/可写就好了，大大简化了应用层的复杂度</li><li>IO 多路复用机制要想高效使用，一般还需要把 socket 设置成「非阻塞」模式，即 socket 没有数据可读/可写时，应用层去 read/write socket 也不会阻塞住（内核会返回指定错误，应用层可继续重试），这样应用层就可以去处理其它业务逻辑，不会阻塞影响性能</li><li>为什么 Redis 要使用「单线程」处理客户端请求？本质上是因为，Redis 操作的是内存，操作内存数据是极快的，所以 Redis 的瓶颈不在 CPU，优化的重点就在网络 IO 上，高效的 IO 多路复用机制，正好可以满足这种需求，模型简单，性能也极高</li><li>但成也萧何败也萧何，因为 Redis 处理请求是「单线程」，所以如果有任意请求在 Server 端发生耗时（例如操作 bigkey，或一次请求数据过多），就会导致后面的请求发生「排队」，业务端就会感知到延迟增大，性能下降</li><li>基于此，Redis 又做了很多优化：一些耗时的操作，不再放在主线程处理，而是丢到后台线程慢慢执行。例如，异步关闭 fd，异步释放内存、后台 AOF 刷盘这些操作。所以 Redis Server 其实是「多线程」的，只不过最核心的处理请求逻辑是单线程的，这点一定要区分开</li></ol><p>课后题：在 Redis 事件驱动框架代码中，分别使用了 Linux 系统上的 select 和 epoll 两种机制，你知道为什么 Redis 没有使用 poll 这一机制吗？</p><p>首先要明确一点，select 并不是只有 Linux 才支持的，Windows 平台也支持。</p><p>而 Redis 针对不同操作系统，会选择不同的 IO 多路复用机制来封装事件驱动框架，具体代码见 ae.c。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// ae.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HAVE_EVPORT</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ae_evport.c&quot;</span> <span class="hljs-comment">// Solaris</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HAVE_EPOLL</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ae_epoll.c&quot;</span> <span class="hljs-comment">// Linux</span></span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HAVE_KQUEUE</span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ae_kqueue.c&quot;</span> <span class="hljs-comment">// MacOS</span></span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ae_select.c&quot;</span> <span class="hljs-comment">// Windows</span></span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre></div><p>仔细看上面的代码逻辑，先判断了 Solaris/Linux/MacOS 系统，选择对应的多路复用模型，最后剩下的系统都用 select 模型。</p><p>所以我理解，select 并不是为 Linux 服务的，而是在 Windows 下使用的。</p><p>因为 epoll 性能优于 select 和 poll，所以 Linux 平台下，Redis 直接会选择 epoll。而 Windows 不支持 epoll 和 poll，所以会用 select 模型。</p><h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><ol><li><p>为了高效处理网络 IO 的「连接事件」、「读事件」、「写事件」，演化出了 Reactor 模型</p></li><li><p>Reactor 模型主要有 reactor、acceptor、handler 三类角色：</p></li></ol><ul><li>reactor：分配事件</li><li>acceptor：接收连接请求</li><li>handler：处理业务逻辑</li></ul><ol start="3"><li>Reactor 模型又分为 3 类：</li></ol><ul><li>单 Reactor 单线程：accept -&gt; read -&gt; 处理业务逻辑 -&gt; write 都在一个线程</li><li>单 Reactor 多线程：accept/read/write 在一个线程，处理业务逻辑在另一个线程</li><li>多 Reactor 多线程 / 进程：accept 在一个线程/进程，read/处理业务逻辑/write 在另一个线程/进程</li></ul><ol start="4"><li>Redis 6.0 以下版本，属于单 Reactor 单线程模型，监听请求、读取数据、处理请求、写回数据都在一个线程中执行，这样会有 3 个问题：</li></ol><ul><li>单线程无法利用多核</li><li>处理请求发生耗时，会阻塞整个线程，影响整体性能</li><li>并发请求过高，读取/写回数据存在瓶颈</li></ul><ol start="5"><li>针对问题 3，Redis 6.0 进行了优化，引入了 IO 多线程，把读写请求数据的逻辑，用多线程处理，提升并发性能，但处理请求的逻辑依旧是单线程处理</li></ol><p>课后题：除了 Redis，你还了解什么软件系统使用了 Reactor 模型吗？</p><p>Netty、Memcached 采用多 Reactor 多线程模型。</p><p>Nginx 采用多 Reactor 多进程模型，不过与标准的多 Reactor 多进程模型有些许差异。Nginx 的主进程只用来初始化 socket，不会 accept 连接，而是由子进程 accept 连接，之后这个连接的所有处理都在子进程中完成。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ol><li>Redis 事件循环主要处理两类事件：文件事件、时间事件</li></ol><ul><li>文件事件包括：client 发起新连接、client 向 server 写数据、server 向 client 响应数据</li><li>时间事件：Redis 的各种定时任务（主线程中执行）</li></ul><ol start="2"><li>Redis 在启动时，会创建 aeEventLoop，初始化 epoll 对象，监听端口，之后会注册文件事件、时间事件：</li></ol><ul><li>文件事件：把 listen socket fd 注册到 epoll 中，回调函数是 acceptTcpHandler（新连接事件）</li><li>时间事件：把 serverCron 函数注册到 aeEventLoop 中，并指定执行频率</li></ul><ol start="3"><li>Redis Server 启动后，会启动一个死循环，持续处理事件（ae.c 的 aeProcessEvents 函数）</li><li>有文件事件（网络 IO)，则优先处理。例如，client 到 server 的新连接，会调用 acceptTcpHandler 函数，之后会注册读事件 readQueryFromClient 函数，client 发给 server 的数据，都会在这个函数处理，这个函数会解析 client 的数据，找到对应的 cmd 函数执行</li><li>cmd 逻辑执行完成后，server 需要写回数据给 client，会先把响应数据写到对应 client 的 内存 buffer 中，在下一次处理 IO 事件之前，Redis 会把每个 client 的 buffer 数据写到 client 的 socket 中，给 client 响应</li><li>如果响应给 client 的数据过多，则会分多次发送，待发送的数据会暂存到 buffer，然后会向 epoll 注册回调函数 sendReplyToClient，待 socket 可写时，继续调用回调函数向 client 写回剩余数据</li><li>在这个死循环中处理每次事件时，都会先检查一下，时间事件是否需要执行，因为之前已经注册好了时间事件的回调函数 + 执行频率，所以在执行 aeApiPoll 时，timeout 就是定时任务的周期，这样即使没有 IO 事件，epoll_wait 也可以正常返回，此时就可以执行一次定时任务 serverCron 函数，这样就可以在一个线程中就完成 IO 事件 + 定时任务的处理</li></ol><p>课后题：Redis 在调用 aeApiCreate、aeApiAddEvent 这些函数时，是根据什么条件来决定，具体调用哪个文件中的 IO 多路复用函数的？</p><p>在 ae.c 中，根据不同平台，首先定义好了要导入的封装好的 IO 多路复用函数，每个平台对应的文件中都定义了 aeApiCreate、aeApiAddEvent 这类函数，在执行时就会执行对应平台的函数逻辑。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// ae.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HAVE_EVPORT</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ae_evport.c&quot;</span> <span class="hljs-comment">// Solaris</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HAVE_EPOLL</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ae_epoll.c&quot;</span> <span class="hljs-comment">// Linux</span></span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HAVE_KQUEUE</span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ae_kqueue.c&quot;</span> <span class="hljs-comment">// MacOS</span></span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;ae_select.c&quot;</span> <span class="hljs-comment">// Windows</span></span>        <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre></div><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><ol><li>很多人认为 Redis 是单线程，这个描述是不准确的。准确来说 Redis 只有在处理「客户端请求」时，是单线程的。但整个 Redis Server 并不是单线程的，还有后台线程在辅助处理一些工作</li><li>Redis 选择单线程处理请求，是因为 Redis 操作的是「内存」，加上设计了「高效」的数据结构，所以操作速度极快，利用 IO 多路复用机制，单线程依旧可以有非常高的性能</li><li>但如果一个请求发生耗时，单线程的缺点就暴露出来了，后面的请求都要「排队」等待，所以 Redis 在启动时会启动一些「后台线程」来辅助工作，目的是把耗时的操作，放到后台处理，避免主线程操作耗时影响整体性能</li><li>例如关闭 fd、AOF 刷盘、释放 key 的内存，这些耗时操作，都可以放到后台线程中处理，对主逻辑没有任何影响</li><li>后台线程处理这些任务，就相当于一个消费者，生产者（主线程）把耗时任务丢到队列中（链表），消费者不停轮询这个队列，拿出任务就去执行对应的方法即可：</li></ol><ul><li>BIO_CLOSE_FILE：close(fd)</li><li>BIO_AOF_FSYNC：fsync(fd)</li><li>BIO_LAZY_FREE：free(obj) / free(dict) / free(skiplist)</li></ul><p>课后题：Redis 后台任务使用 bio_job 结构体来描述，该结构体用了三个指针变量来表示任务参数，如果我们创建的任务，所需要的参数大于 3 个，你有什么应对方法来传参么？</p><p>最直接的方法就是，把参数换成数组类型，这样就可以传递任意数量参数了。因为这里 Redis 的后台任务都比较简单，最多 3 个参数就足够满足需求，所以 job 直接写死了 3 个参数变量，这样做的好处是维护起来简单直接。</p><h2 id="多IO线程"><a href="#多IO线程" class="headerlink" title="多IO线程"></a>多IO线程</h2><ol><li>Redis 6.0 之前，处理客户端请求是单线程，这种模型的缺点是，只能用到「单核」CPU。如果并发量很高，那么在读写客户端数据时，容易引发性能瓶颈，所以 Redis 6.0 引入了多 IO 线程解决这个问题</li><li>配置文件开启 io-threads N 后，Redis Server 启动时，会启动 N - 1 个 IO 线程（主线程也算一个 IO 线程），这些 IO 线程执行的逻辑是 networking.c 的 IOThreadMain 函数。但默认只开启多线程「写」client socket，如果要开启多线程「读」，还需配置 io-threads-do-reads = yes</li><li>Redis 在读取客户端请求时，判断如果开启了 IO 多线程，则把这个 client 放到 clients_pending_read 链表中（postponeClientRead 函数），之后主线程在处理每次事件循环之前，把链表数据轮询放到 IO 线程的链表（io_threads_list）中</li><li>同样地，在写回响应时，是把 client 放到 clients_pending_write 中（prepareClientToWrite 函数），执行事件循环之前把数据轮询放到 IO 线程的链表（io_threads_list）中</li><li>主线程把 client 分发到 IO 线程时，自己也会读写客户端 socket（主线程也要分担一部分读写操作），之后「等待」所有 IO 线程完成读写，再由主线程「串行」执行后续逻辑</li><li>每个 IO 线程，不停地从 io_threads_list 链表中取出 client，并根据指定类型读、写 client socket</li><li>IO 线程在处理读、写 client 时有些许差异，如果 write_client_pedding &lt; io_threads * 2，则直接由「主线程」负责写，不再交给 IO 线程处理，从而节省 CPU 消耗</li><li>Redis 官方建议，服务器最少 4 核 CPU 才建议开启 IO 多线程，4 核 CPU 建议开 2-3 个 IO 线程，8 核 CPU 开 6 个 IO 线程，超过 8 个线程性能提升不大</li><li>Redis 官方表示，开启多 IO 线程后，性能可提升 1 倍。当然，如果 Redis 性能足够用，没必要开 IO 线程</li></ol><p>课后题：为什么 startThreadedIO / stopThreadedIO 要执行加解锁？</p><p>既然涉及到加锁操作，必然是为了「互斥」从而控制某些逻辑。可以在代码中检索这个锁变量，看存在哪些逻辑对 io_threads_mutex 操作了加解锁。</p><p>跟踪代码可以看到，在 networking.c 的 IOThreadMain 函数，也对这个变量进行了加解锁操作，那就说明 startThreadedIO / stopThreadedIO 函数，可以控制 IOThreadMain 里逻辑的执行，IOThreadMain 代码如下。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">IOThreadMain</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *myid)</span> </span>&#123;    ...    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;    ...    <span class="hljs-comment">/* Give the main thread a chance to stop this thread. */</span>    <span class="hljs-keyword">if</span> (io_threads_pending[id] == <span class="hljs-number">0</span>) &#123;    pthread_mutex_lock(&amp;io_threads_mutex[id]);    pthread_mutex_unlock(&amp;io_threads_mutex[id]);    <span class="hljs-keyword">continue</span>;    &#125;    <span class="hljs-comment">// 读写 client socket</span>    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>这个函数正是 IO 多线程的主逻辑。</p><p>从注释可以看到，这是为了给主线程停止 IO 线程的的机会。也就是说，这里的目的是为了让主线程可以控制 IO 线程的开启 / 暂停。</p><p>因为每次 IO 线程在执行时必须先拿到锁，才能执行后面的逻辑，如果主线程执行了 stopThreadedIO，就会先拿到锁，那么 IOThreadMain 函数在执行时就会因为拿不到锁阻塞「等待」，这就达到了 stop IO 线程的目的。</p><p>同样地，调用 startThreadedIO 函数后，会释放锁，IO 线程就可以拿到锁，继续「恢复」执行。</p><h2 id="分布式的原子性"><a href="#分布式的原子性" class="headerlink" title="分布式的原子性"></a>分布式的原子性</h2><ol><li>无论是 IO 多路复用，还是 Redis 6.0 的多 IO 线程，Redis 执行具体命令的主逻辑依旧是「单线程」的</li><li>执行命令是单线程，本质上就保证了每个命令必定是「串行」执行的，前面请求处理完成，后面请求才能开始处理</li><li>所以 Redis 在实现分布式锁时，内部不需要考虑加锁问题，直接在主线程中判断 key 是否存在即可，实现起来非常简单</li></ol><p>课后题：如果将命令处理过程中的命令执行也交给多 IO 线程执行，除了对原子性会有影响，还会有什么好处和坏处？</p><p>好处：</p><ul><li>每个请求分配给不同的线程处理，一个请求处理慢，并不影响其它请求</li><li>请求操作的 key 越分散，性能会变高（并行处理比串行处理性能高）</li><li>可充分利用多核 CPU 资源</li></ul><p>坏处：</p><ul><li>操作同一个 key 需加锁，加锁会影响性能，如果是热点 key，性能下降明显</li><li>多线程上下文切换存在性能损耗</li><li>多线程开发和调试不友好</li></ul><h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><ol><li>实现一个严格的 LRU 算法，需要额外的内存构建 LRU 链表，同时维护链表也存在性能开销，Redis 对于内存资源和性能要求极高，所以没有采用严格 LRU 算法，而是采用「近似」LRU 算法实现数据淘汰策略</li><li>触发数据淘汰的时机，是每次处理「请求」时判断的。也就是说，执行一个命令之前，首先要判断实例内存是否达到 maxmemory，是的话则先执行数据淘汰，再执行具体的命令</li><li>淘汰数据时，会「持续」判断 Redis 内存是否下降到了 maxmemory 以下，不满足的话会继续淘汰数据，直到内存下降到 maxmemory 之下才会停止</li><li>可见，如果发生大量淘汰的情况，那么处理客户端请求就会发生「延迟」，影响性能</li><li>Redis 计算实例内存时，不会把「主从复制」的缓冲区计算在内，也就是说不管一个实例后面挂了多少个从库，主库不会把主从复制所需的「缓冲区」内存，计算到实例内存中，即这部分内存增加，不会对数据淘汰产生影响</li><li>但如果 Redis 内存已达到 maxmemory，要谨慎执行 MONITOR 命令，因为 Redis Server 会向执行 MONITOR 的 client 缓冲区填充数据，这会导致缓冲区内存增长，进而引发数据淘汰</li></ol><p>课后题：为什么键值对的 LRU 时钟值，不是直接通过调用 getLRUClock 函数来获取？</p><p>本质上是为了性能。</p><p>Redis 这种对性能要求极高的数据库，在系统调用上的优化也做到了极致。</p><p>获取机器时钟本质上也是一个「系统调用」，对于 Redis 这种动不动每秒上万的 QPS，如果每次都触发一次系统调用，这么频繁的操作也是一笔不小的开销。</p><p>所以，Redis 用一个定时任务（serverCron 函数），以固定频率触发系统调用获取机器时钟，然后把机器时钟挂到 server 的全局变量下，这相当于维护了一个「本地缓存」，当需要获取时钟时，直接从全局变量获取即可，节省了大量的系统调用开销。</p><h2 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h2><ol><li>LFU 是在 Redis 4.0 新增的淘汰策略，它涉及的巧妙之处在于，其复用了 redisObject 结构的 lru 字段，把这个字段「一分为二」，保存最后访问时间和访问次数</li><li>key 的访问次数不能只增不减，它需要根据时间间隔来做衰减，才能达到 LFU 的目的</li><li>每次在访问一个 key 时，会「懒惰」更新这个 key 的访问次数：先衰减访问次数，再更新访问次数</li><li>衰减访问次数，会根据时间间隔计算，间隔时间越久，衰减越厉害</li><li>因为 redisObject lru 字段宽度限制，这个访问次数是有上限的（8 bit 最大值 255），所以递增访问次数时，会根据「当前」访问次数和「概率」的方式做递增，访问次数越大，递增因子越大，递增概率越低</li><li>Redis 实现的 LFU 算法也是「近似」LFU，是在性能和内存方面平衡的结果</li></ol><p>课后题：LFU 算法在初始化键值对的访问次数时，会将访问次数设置为 LFU_INIT_VAL，默认值是 5 次。如果 LFU_INIT_VAL 设置为 1，会发生什么情况？</p><p>如果开启了 LFU，那在写入一个新 key 时，需要初始化访问时间、访问次数（createObject 函数），如果访问次数初始值太小，那这些新 key 的访问次数，很有可能在短时间内就被「衰减」为 0，那就会面临马上被淘汰的风险。</p><p>新 key 初始访问次数 LFU_INIT_VAL = 5，就是为了避免一个 key 在创建后，不会面临被立即淘汰的情况发生。</p><h2 id="Lazy-Free"><a href="#Lazy-Free" class="headerlink" title="Lazy Free"></a>Lazy Free</h2><ol><li>lazy-free 是 4.0 新增的功能，默认是关闭的，需要手动开启</li><li>开启 lazy-free 时，有多个「子选项」可以控制，分别对应不同场景下，是否开启异步释放内存：</li></ol><ul><li>lazyfree-lazy-expire：key 在过期删除时尝试异步释放内存</li><li>lazyfree-lazy-eviction：内存达到 maxmemory 并设置了淘汰策略时尝试异步释放内存</li><li>lazyfree-lazy-server-del：执行 RENAME/MOVE 等命令或需要覆盖一个 key 时，Redis 内部删除旧 key 尝试异步释放内存</li><li>replica-lazy-flush：主从全量同步，从库清空数据库时异步释放内存</li></ul><ol start="3"><li>即使开启了 lazy-free，但如果执行的是 DEL 命令，则还是会同步释放 key 内存，只有使用 UNLINK 命令才「可能」异步释放内存</li><li>Redis 6.0 版本新增了一个新的选项 lazyfree-lazy-user-del，打开后执行 DEL 就与 UNLINK 效果一样了</li><li>最关键的一点，开启 lazy-free 后，除 replica-lazy-flush 之外，其它选项都只是「可能」异步释放 key 的内存，并不是说每次释放 key 内存都是丢到后台线程的</li><li>开启 lazy-free 后，Redis 在释放一个 key 内存时，首先会评估「代价」，如果代价很小，那么就直接在「主线程」操作了，「没必要」放到后台线程中执行（不同线程传递数据也会有性能消耗）</li><li>什么情况才会真正异步释放内存？这和 key 的类型、编码方式、元素数量都有关系（详见 lazyfreeGetFreeEffort 函数）：</li></ol><ul><li>当 Hash/Set 底层采用哈希表存储（非 ziplist/int 编码存储）时，并且元素数量超过 64 个</li><li>当 ZSet 底层采用跳表存储（非 ziplist 编码存储）时，并且元素数量超过 64 个</li><li>当 List 链表节点数量超过 64 个（注意，不是元素数量，而是链表节点的数量，List 底层实现是一个链表，链表每个节点是一个 ziplist，一个 ziplist 可能有多个元素数据）</li></ul><p>只有满足以上条件，在释放 key 内存时，才会真正放到「后台线程」中执行，其它情况一律还是在主线程操作。</p><p>也就是说 String（不管内存占用多大）、List（少量元素）、Set（int 编码存储）、Hash/ZSet（ziplist 编码存储）这些情况下的 key，在释放内存时，依旧在「主线程」中操作。</p><ol start="8"><li>可见，即使打开了 lazy-free，String 类型的 bigkey，在删除时依旧有「阻塞」主线程的风险。所以，即便 Redis 提供了 lazy-free，还是不建议在 Redis 存储 bigkey</li></ol><p>9、Redis 在释放内存「评估」代价时，不是看 key 的内存大小，而是关注释放内存时的「工作量」有多大。从上面分析可以看出，如果 key 内存是连续的，释放内存的代价就比较低，则依旧放在「主线程」处理。如果 key 内存不连续（包含大量指针），这个代价就比较高，这才会放在「后台线程」中执行</p><p>课后题：freeMemoryIfNeeded 函数在使用后台线程，删除被淘汰数据的过程中，主线程是否仍然可以处理外部请求？</p><p>肯定是可以继续处理请求的。</p><p>主线程决定淘汰这个 key 之后，会先把这个 key 从「全局哈希表」中剔除，然后评估释放内存的代价，如果符合条件，则丢到「后台线程」中执行「释放内存」操作。</p><p>之后就可以继续处理客户端请求，尽管后台线程还未完成释放内存，但因为 key 已被全局哈希表剔除，所以主线程已查询不到这个 key 了，对客户端来说无影响。</p><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><ol><li>RDB 文件是 Redis 的数据快照，以「二进制」格式存储，相比 AOF 文件更小，写盘和加载时间更短</li><li>RDB 在执行 SAVE / BGSAVE 命令、定时 BGSAVE、主从复制时产生</li><li>RDB 文件包含文件头、数据部分、文件尾</li><li>文件头主要包括 Redis 的魔数、RDB 版本、Redis 版本、RDB 创建时间、键值对占用的内存大小等信息</li><li>文件数据部分包括整个 Redis 数据库中存储的所有键值对信息</li></ol><ul><li>数据库信息：db 编号、db 中 key 的数量、过期 key 的数量、键值数据</li><li>键值数据：过期标识、时间戳（绝对时间）、键值对类型、key 长度、key、value 长度、value</li></ul><ol start="6"><li>文件尾保存了 RDB 的结束标记、文件校验值</li><li>RDB 存储的数据，为了压缩体积，还做了很多优化:</li></ol><ul><li>变长编码存储键值对数据</li><li>用操作码标识不同的内容</li><li>可整数编码的内容使用整数类型紧凑编码</li></ul><p>课后题：在 serverCron 函数中，rdbSaveBackground 函数一共会被调用执行几次？这又分别对应了什么场景？</p><p>在 serverCron 函数中 rdbSaveBackground 会被调用 2 次。</p><p>一次是满足配置的定时 RDB 条件后（save <seconds> &lt;changes），触发子进程生成 RDB。</p><p>另一次是客户端执行了 BGSAVE 命令，Redis 会先设置 server.rdb_bgsave_scheduled = 1，之后 serverCron 函数判断这个变量为 1，也会触发子进程生成 RDB。</p><h2 id="AOF-上"><a href="#AOF-上" class="headerlink" title="AOF 上"></a>AOF 上</h2><ol><li>AOF 记录的是每个命令的「操作历史」，随着时间增长，AOF 文件会越来越大，所以需要 AOF 重写来「瘦身」，减小文件体积</li><li>AOF 重写时，会扫描整个实例中的数据，把数据以「命令 + 键值对」的格式，写到 AOF 文件中</li><li>触发 AOF 重写的时机有 4 个：</li></ol><ul><li>执行 bgrewriteaof 命令</li><li>手动打开 AOF 开关（config set appendonly yes）</li><li>从库加载完主库 RDB 后（AOF 被启动的前提下）</li><li>定时触发：AOF 文件大小比例超出阈值、AOF 文件大小绝对值超出阈值（AOF 被启动的前提下）</li></ul><p>这 4 个时机，都不能有 RDB 子进程，否则 AOF 重写会延迟执行。</p><ol start="4"><li>AOF 重写期间会禁用 rehash，不让父进程调整哈希表大小，目的是父进程「写时复制」拷贝大量内存页面</li></ol><p>课后题：为什么 Redis 源码中在有 RDB 子进程运行时，不会启动 AOF 重写子进程？</p><p>无论是生成 RDB 还是 AOF 重写，都需要创建子进程，然后把实例中的所有数据写到磁盘上，这个过程中涉及到两块：</p><ul><li>CPU：写盘之前需要先迭代实例中的所有数据，在这期间会耗费比较多的 CPU 资源，两者同时进行，CPU 资源消耗大</li><li>磁盘：同样地，RDB 和 AOF 重写，都是把内存数据落盘，在这期间 Redis 会持续写磁盘，如果同时进行，磁盘 IO 压力也会较大</li></ul><p>整体来说都是为了资源考虑，所以不会让它们同时进行。</p><h2 id="AOF-下"><a href="#AOF-下" class="headerlink" title="AOF 下"></a>AOF 下</h2><ol><li>AOF 重写是在子进程中执行，但在此期间父进程还会接收写操作，为了保证新的 AOF 文件数据更完整，所以父进程需要把在这期间的写操作缓存下来，然后发给子进程，让子进程追加到 AOF 文件中</li><li>因为需要父子进程传输数据，所以需要用到操作系统提供的进程间通信机制，这里 Redis 用的是「管道」，管道只能是一个进程写，另一个进程读，特点是单向传输</li><li>AOF 重写时，父子进程用了 3 个管道，分别传输不同类别的数据：</li></ol><ul><li>父进程传输数据给子进程的管道：发送 AOF 重写期间新的写操作</li><li>子进程完成重写后通知父进程的管道：让父进程停止发送新的写操作</li><li>父进程确认收到子进程通知的管道：父进程通知子进程已收到通知</li></ul><ol start="4"><li>AOF 重写的完整流程是：父进程 fork 出子进程，子进程迭代实例所有数据，写到一个临时 AOF 文件，在写文件期间，父进程收到新的写操作，会先缓存到 buf 中，之后父进程把 buf 中的数据，通过管道发给子进程，子进程写完 AOF 文件后，会从管道中读取这些命令，再追加到 AOF 文件中，最后 rename 这个临时 AOF 文件为新文件，替换旧的 AOF 文件，重写结束</li></ol><p>课后题：Redis 中其它使用管道的地方还有哪些？</p><p>在源码中搜索 pipe 函数，能看到 server.child_info_pipe 和 server.module_blocked_pipe 也使用了管道。</p><p>其中 child_info_pipe 管道如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Pipe and data structures for child -&gt; parent info sharing. */</span><span class="hljs-keyword">int</span> child_info_pipe[<span class="hljs-number">2</span>]; <span class="hljs-comment">/* Pipe used to write the child_info_data. */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-keyword">int</span> process_type; <span class="hljs-comment">/* AOF or RDB child? */</span>    <span class="hljs-keyword">size_t</span> cow_size; <span class="hljs-comment">/* Copy on write size. */</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> magic; <span class="hljs-comment">/* Magic value to make sure data is valid. */</span>&#125; child_info_data;</code></pre></div><p>从注释能看出，子进程在生成 RDB 或 AOF 重写完成后，子进程通知父进程在这期间，父进程「写时复制」了多少内存，父进程把这个数据记录到 server 的 stat_rdb_cow_bytes / stat_aof_cow_bytes 下（childinfo.c 的 receiveChildInfo 函数），以便客户端可以查询到最后一次 RDB 和 AOF 重写期间写时复制时，新申请的内存大小。</p><p>而 module_blocked_pipe 管道主要服务于 Redis module。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Pipe used to awake the event loop if a client blocked on a module command needs to be processed. */</span><span class="hljs-keyword">int</span> module_blocked_pipe[<span class="hljs-number">2</span>];</code></pre></div><p>看注释是指，如果被 module 命令阻塞的客户端需要处理，则会唤醒事件循环开始处理。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><ol><li>Redis 主从复制分为 4 个阶段：</li></ol><ul><li>初始化</li><li>建立连接</li><li>主从握手</li><li>数据传输（全量/增量复制）</li></ul><ol start="2"><li>主从复制流程由于是是「从库」发起的，所以重点要看从库的执行流程</li><li>从库发起复制的方式有 3 个：</li></ol><ul><li>执行 slaveof / replicaof 命令</li><li>配置文件配置了主库的 ip port</li><li>启动实例时指定了主库的 ip port</li></ul><ol start="4"><li>建议从 slaveof / replicaof 命令跟源码进去，来看整个主从复制的流程（入口在 replication.c 的 replicaofCommand 函数）</li><li>从库执行这个命令后，会先在 server 结构体上，记录主库的 ip port，然后把 server.repl_state 从 REPL_STATE_NONE 改为 REPL_STATE_CONNECT，「复制状态机」启动</li><li>随后从库会在定时任务（server.c 的 serverCron 函数）中会检测 server.repl_state 的状态，然后向主库发起复制请求（replication.c 的 replicationCron 函数），进入复制流程（replication.c 的 connectWithMaster 函数）</li><li>从库会与主库建立连接（REPL_STATE_CONNECTING），注册读事件（syncWithMaster 函数），之后主从进入握手认证阶段，从库会告知主库自己的 ip port 等信息，在这期间会流转多个状态（server.h 中定义的复制状态）：</li></ol><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REPL_STATE_RECEIVE_PONG 3 <span class="hljs-comment">/* Wait for PING reply */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REPL_STATE_SEND_AUTH 4 <span class="hljs-comment">/* Send AUTH to master */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REPL_STATE_RECEIVE_AUTH 5 <span class="hljs-comment">/* Wait for AUTH reply */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REPL_STATE_SEND_PORT 6 <span class="hljs-comment">/* Send REPLCONF listening-port */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REPL_STATE_RECEIVE_PORT 7 <span class="hljs-comment">/* Wait for REPLCONF reply */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REPL_STATE_SEND_IP 8 <span class="hljs-comment">/* Send REPLCONF ip-address */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REPL_STATE_RECEIVE_IP 9 <span class="hljs-comment">/* Wait for REPLCONF reply */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REPL_STATE_SEND_CAPA 10 <span class="hljs-comment">/* Send REPLCONF capa */</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> REPL_STATE_RECEIVE_CAPA 11 <span class="hljs-comment">/* Wait for REPLCONF reply */</span></span></code></pre></div><ol start="8"><li>完成握手后，从库向主库发送 PSYNC 命令和自己的 offset，首先尝试「增量同步」，如果 offset = -1，主库返回 FULLRESYNC 表示「全量同步」数据，否则返回 CONTINUE 增量同步</li><li>如果是全量同步，主库会先生成 RDB，从库等待，主库完成 RDB 后发给从库，从库接收 RDB，然后清空实例数据，加载 RDB，之后读取主库发来的「增量」数据</li><li>如果是增量同步，从库只需接收主库传来的增量数据即可</li></ol><p>课后题：当一个实例是主库时，为什么不需要使用状态机来实现主库在主从复制时的流程流转？</p><p>因为复制数据的发起方是从库，从库要求复制数据会经历多个阶段（发起连接、握手认证、请求数据），而主库只需要「被动」接收从库的请求，根据需要「响应数据」即可完成整个流程，所以主库不需要状态机流转。</p><h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><ol><li>哨兵和 Redis 实例是一套代码，只不过哨兵会根据启动参数（redis-sentinel 或 redis-server –sentinel），设置当前实例为哨兵模式（server.sentinel_mode = 1），然后初始化哨兵相关数据</li><li>哨兵模式的实例，只能执行一部分命令（ping、sentinel、subscribe、unsubscribe、psubscribe、punsubscribe、publish、info、role、client、shutdown、auth），其中 sentinel、publish、info、role 都是针对哨兵专门实现的</li><li>之后哨兵会初始化各种属性，例如哨兵实例 ID、用于故障切换的当前纪元、监听的主节点、正在执行的脚本数量、与其他哨兵实例发送的 IP 和端口号等信息</li><li>启动哨兵后，会检查配置文件是否可写（不可写直接退出，哨兵需把监控的实例信息写入配置文件）、是否配置了哨兵 ID（没配置随机生成一个）</li><li>最后哨兵会在监控的 master 实例的 PubSub（+monitor 频道）发布一条消息，表示哨兵开始监控 Redis 实例</li><li>哨兵后续会通过 PubSub 的方式，与主从库、其它哨兵实例进行通信</li></ol><p>课后题：哨兵实例本身是有配置文件 sentinel.conf 的，那么在哨兵实例的初始化过程中，解析这个配置文件的函数在哪？</p><p>Redis 启动时，会在 main 函数中调用 loadServerConfig 加载配置文件，loadServerConfig 函数会读取配置文件中的内容，然后调用 loadServerConfigFromString 函数解析具体的配置项。</p><p>loadServerConfigFromString 函数中，其中有一个分支，对哨兵模式进行了判断，如果是哨兵模式，则调用 sentinelHandleConfiguration 函数解析哨兵配置项。</p><p>所以，函数调用链为 main -&gt; loadServerConfig（读出配置文件内容） -&gt; loadServerConfigFromString（解析配置项） -&gt; sentinelHandleConfiguration（解析哨兵配置项）。</p><h2 id="哨兵选举-上"><a href="#哨兵选举-上" class="headerlink" title="哨兵选举 上"></a>哨兵选举 上</h2><ol><li>Redis 为了实现故障自动切换，引入了一个外部「观察者」检测实例的状态，这个观察者就是「哨兵」</li><li>但一个哨兵检测实例，有可能因为网络原因导致「误判」，所以需要「多个」哨兵共同判定</li><li>多个哨兵共同判定出实例故障后（主观下线、客观下线），会进入故障切换流程，切换时需要「选举」出一个哨兵「领导者」进行操作</li><li>这个选举的过程，就是「分布式共识」，即多个哨兵通过「投票」选举出一个都认可的实例当领导者，由这个领导者发起切换，这个选举使用的算法是 Raft 算法</li><li>严格来说，Raft 算法的核心流程是这样的：</li></ol><ul><li>集群正常情况下，Leader 会持续给 Follower 发心跳消息，维护 Leader 地位</li><li>如果 Follower 一段时间内收不到 Leader 心跳消息，则变为 Candidate 发起选举</li><li>Candidate 先给自己投一票，然后向其它节点发送投票请求</li><li>Candidate 收到超过半数确认票，则提升为新的 Leader，新 Leader 给其它 Follower 发心跳消息，维护新的 Leader 地位</li><li>Candidate 投票期间，收到了 Leader 心跳消息，则自动变为 Follower</li><li>投票结束后，没有超过半数确认票的实例，选举失败，会再次发起选举</li></ul><ol start="6"><li>但哨兵的选举没有按照严格按照 Raft 实现，因为多个哨兵之间是「对等」关系，没有 Leader 和 Follower 角色，只有当 Redis 实例发生故障时，哨兵才选举领导者进行切换，选举 Leader 的过程是按照 Raft 算法步骤 3-6 实现的</li></ol><p>课后题：哨兵实例执行的周期性函数 sentinelTimer 的最后，修改 server.hz 的目的是什么？</p><p>server.hz 表示执行定时任务函数 serverCron 的频率，哨兵在最后修改 server.hz 增加一个随机值，是为了避免多个哨兵以「相同频率」执行，引发每个哨兵同时发起选举，进而导致没有一个哨兵能拿到多数投票，领导者选举失败的问题。适当打散执行频率，可以有效降低选举失败的概率。</p><h2 id="哨兵选举-下"><a href="#哨兵选举-下" class="headerlink" title="哨兵选举 下"></a>哨兵选举 下</h2><ol><li>一个哨兵检测判定主库故障，这个过程是「主观下线」，另外这个哨兵还会向其它哨兵询问（发送 sentinel is-master-down-by-addr 命令），多个哨兵都检测主库故障，数量达到配置的 quorum 值，则判定为「客观下线」</li><li>首先判定为客观下线的哨兵，会发起选举，让其它哨兵给自己投票成为「领导者」，成为领导者的条件是，拿到超过「半数」的确认票 + 超过预设的 quorum 阈值的赞成票</li><li>投票过程中会比较哨兵和主库的「纪元」（主库纪元 &lt; 发起投票哨兵的纪元 + 发起投票哨兵的纪元 &gt; 其它哨兵的纪元），保证一轮投票中一个哨兵只能投一次票</li></ol><p>课后题：哨兵在 sentinelTimer 函数中调用 sentinelHandleDictOfRedisInstances 函数，对每个主节点都执行 sentinelHandleRedisInstance 函数，并且还会对主节点的所有从节点也执行 sentinelHandleRedisInstance 函数，那么，哨兵会不会判断从节点的主观下线和客观下线？</p><p>sentinelHandleRedisInstance 函数逻辑如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sentinelHandleRedisInstance</span><span class="hljs-params">(sentinelRedisInstance *ri)</span> </span>&#123;    ...    <span class="hljs-comment">/* Every kind of instance */</span>    <span class="hljs-comment">// 判断主观下线</span>    sentinelCheckSubjectivelyDown(ri);    ...    <span class="hljs-comment">/* Only masters */</span>    <span class="hljs-keyword">if</span> (ri-&gt;flags &amp; SRI_MASTER) &#123;        <span class="hljs-comment">// 判断客观下线</span>        sentinelCheckObjectivelyDown(ri);        <span class="hljs-keyword">if</span> (sentinelStartFailoverIfNeeded(ri))            sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_ASK_FORCED);        sentinelFailoverStateMachine(ri);        sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_NO_FLAGS);    &#125;&#125;</code></pre></div><p>可以看到，无论主库还是从库，哨兵都判断了「主观下线」，但只有主库才判断「客观下线」和「故障切换」。</p><h2 id="pub-sub"><a href="#pub-sub" class="headerlink" title="pub/sub"></a>pub/sub</h2><ol><li>哨兵是通过 master 的 PubSub 发现其它哨兵的：每个哨兵向 master 的 PubSub（<strong>sentinel</strong>:hello 频道）发布消息，同时也会订阅这个频道，这样每个哨兵就能拿到其它哨兵的 IP、端口等信息</li><li>每个哨兵有了其它哨兵的信息后，在判定 Redis 实例状态时，就可以互相通信、交换信息，共同判定实例是否真的故障</li><li>哨兵判定 Redis 实例故障、发起切换时，都会向 master 的 PubSub 的频道发布消息</li><li>客户端可以订阅 master 的 PubSub，感知到哨兵工作到了哪个状态节点，从而作出自己的反应</li><li>PubSub 的实现，其实就是 Redis 在内存中维护了一个「发布-订阅」映射表，订阅者执行 SUBSCRIBE 命令，Redis 会把订阅者加入到指定频道的「链表」下。发布者执行 PUBLISH，Redis 就找到这个映射表中这个频道的所有「订阅者」，把消息「实时转发」给这些订阅者</li></ol><p>课后题：在哨兵实例上执行 publish 命令，这条命令是不是就是由 pubsub.c 文件中的 publishCommand 函数来处理的?</p><p>以哨兵模式启动的 Redis 实例，会使用新「命令表」。</p><p>在 server.c 的 main 函数中可以看到，哨兵模式启动后，会调用 initSentinel 函数。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initSentinel</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;    ...    <span class="hljs-comment">// 只添加 sentinelcmds 下的命令</span>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">sizeof</span>(sentinelcmds)/<span class="hljs-keyword">sizeof</span>(sentinelcmds[<span class="hljs-number">0</span>]); j++) &#123;        <span class="hljs-keyword">int</span> retval;        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisCommand</span> *<span class="hljs-title">cmd</span> =</span> sentinelcmds+j;        retval = dictAdd(server.commands, sdsnew(cmd-&gt;name), cmd);        serverAssert(retval == DICT_OK);    &#125;    ...&#125;</code></pre></div><p>可以看到只把 sentinelcmds 命令表添加到了 server.commands 中。sentinelcmds 如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisCommand</span> <span class="hljs-title">sentinelcmds</span>[] =</span> &#123;    ...    &#123;<span class="hljs-string">&quot;subscribe&quot;</span>,subscribeCommand,<span class="hljs-number">-2</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,    &#123;<span class="hljs-string">&quot;publish&quot;</span>,sentinelPublishCommand,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,    &#123;<span class="hljs-string">&quot;info&quot;</span>,sentinelInfoCommand,<span class="hljs-number">-1</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,    ...&#125;;</code></pre></div><p>可以看到哨兵的 PUBLISH 命令是由 sentinelPublishCommand 单独实现的，并非普通实例的 publishCommand。</p><h2 id="redis-性能测试"><a href="#redis-性能测试" class="headerlink" title="redis 性能测试"></a>redis 性能测试</h2><ol><li>redis-benchmark 是 Redis 官方提供的性能测试工具，一般都用这个工具测试其性能</li><li>测试性能结果，与客户端并发数、value 大小、是否用 pipeline 都有关系</li><li>除此之外，性能结果还受系统环境的影响，例如 CPU 负载、网络带宽、客户端和服务端是否在同一机器、实例是否部署在虚拟机、Redis 绑核情况都会影响性能结果</li><li>提升 Redis 性能的几点优化：</li></ol><ul><li>控制客户端并发数</li><li>value 小于 10KB</li><li>推荐使用 pipeline</li><li>隔离部署</li><li>保证 CPU、网络带宽负载正常</li><li>不部署在虚拟机</li><li>进程绑核</li><li>CPU 绑定网卡队列</li><li>Redis 内存碎片</li><li>不使用 Swap</li></ul><h2 id="RDB、AOF文件损坏"><a href="#RDB、AOF文件损坏" class="headerlink" title="RDB、AOF文件损坏"></a>RDB、AOF文件损坏</h2><ol><li>RDB 和 AOF 文件在写盘故障时，可能发生损坏不完整的情况，那使用其恢复数据就会出现问题，所以 Redis 提供了 2 个命令来检测文件是否有错误</li><li>要想检测出文件错误，那说明 RDB 和 AOF 必定是按照某种固定格式写入的，检测是否完整只需要按照其格式规则，发现不符即认为文件不完整</li><li>redis-check-rdb 命令检测 RDB，因为 RDB 有明确的文件头、数据部分、文件尾，读取文件发现不完整即报错</li><li>redis-check-aof 命令检测 AOF，AOF 按照 RESP 协议写入，按照这个协议可以读取每个命令参数个数、参数字符串长度，如果不符合协议格式，则说明不完整。但这个命令提供了 –fix 命令，可以修复 AOF 文件，实现原理是：把不完整的命令和后续部分，直接从 AOF 中删除</li></ol><p>课后题：redis_check_aof_main 函数是检测 AOF 文件的入口函数，但是它还会调用检测 RDB 文件的入口函数 redis_check_rdb_main，它的作用是什么？</p><p>Redis 在 4.0 版本支持了「混合持久化」，即在 AOF rewrite 期间，先以 RDB 格式写入到 AOF 文件中，再把后续命令追加到 AOF 中，这样 AOF rewrite 后的文件既包括了 RDB 格式，又包含 AOF 格式（目的是为了让 AOF 体积更小），所以 redis_check_rdb_main 在检测 AOF 文件时，RDB 和 AOF 文件格式都需要检测。</p><h2 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a>Gossip</h2><ol><li>多个节点组成一个分布式系统，它们之间需要交换数据，可以采用中心化的方式（依赖第三方系统，例如ZK），也可以采用非中心化（分布式协议，例如 Gossip）的方式</li><li>Redis Cluster 采用非中心化的方式 Gossip 协议，实现多个节点之间信息交换</li><li>集群中的每个实例，会按照固定频率，从集群中「随机」挑选部分实例，发送 PING 消息（自身实例状态、已知部分实例信息、slots 分布），用来交换彼此状态信息</li><li>收到 PING 的实例，会响应 PONG 消息，PONG 消息和 PING 消息格式一样，包含了自身实例状态、已知部分实例信息、slots 分布</li><li>这样经过几次交换后，集群中每个实例都能拿到其它实例的状态信息</li><li>即使有节点状态发生变化（新实例加入、节点故障、数据迁移），也可以通过 Gossip 协议的 PING-PONG 消息完成整个集群状态在每个实例上的同步</li></ol><p>课后题：为什么 clusterSendPing 函数计算 wanted 值时，是用的集群节点个数的十分之一？</p><p>这个和 Redis Cluster 判定实例「故障」逻辑有关了。</p><p>Redis Cluster 实例在周期性向其它实例交换信息时，会先随机选出 5 个实例，然后从中找出最久没通信过的实例，发送 PING 消息。</p><p>但这里有个问题，随机选出的这 5 个实例，有可能并不是整个「集群」中最久没通信过的，为了避免拿不到这些实例的状态，导致集群误以为这些实例已过期，所以制定了一个策略：如果和实例最近通信时间超过了 cluster-node-timeout / 2，那会立即向这个实例发送 PING 消息。</p><p>每次 PING 都会收到 PONG 响应，一来一回 2 次心跳包，来回都带有部分实例的状态信息，那在 cluster-node-timeout 时间内会收到 4 次心跳包。</p><p>又因为 Redis Cluster 计算故障转移超时时间是 cluster-node-timeout * 2，那这段时间内就能收到 8 个 PING + PONG 心跳包，每个心跳包中实例个数设置为集群的 1/10，那在故障转移期间就能收到集群 80%（8 * 1/10）节点发来的故障状态信息了，满足集群大部分节点发来的节点故障情况。</p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis核心技术与实战</title>
    <link href="/redis/use/"/>
    <url>/redis/use/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程之终极武器—channel</title>
    <link href="/golang/ipc-channel/"/>
    <url>/golang/ipc-channel/</url>
    
    <content type="html"><![CDATA[<p>三种状态<br>nil，未初始化的状态，只进行了声明，或者手动赋值为nil<br>active，正常的channel，可读或者可写<br>closed，已关闭，千万不要误认为关闭channel后，channel的值是nil</p><p>三种操作<br>读<br>写<br>关闭</p><p>panic的三种操作<br>close()已关闭的channel<br>close()nil的channel<br>写已关闭的channel</p><p>关闭一定要在发送方</p><p>_,ok=ch<br>和 range ch 来判断 通道是否关闭。<br>*注意，看到好多人说关闭之后就会从中返回，其实不太准确，应该说是，把所有数据都读取完之后，才会退出</p><p>使用无缓冲的时候要特别注意，在运行时的逻辑上，向channel发送消息后，后面的逻辑没有接收操作了，那就会报死锁错误。<br>解决办法：</p><ol><li>有缓冲的：加个缓冲就可以了</li><li>无缓冲的：消费最后那次发送</li></ol>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程之数据共享—(2)Pool</title>
    <link href="/golang/ipc-pool/"/>
    <url>/golang/ipc-pool/</url>
    
    <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p><code>func (*Pool) Get</code><br><code>func (*Pool) Put</code></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程之数据共享—(1)Map</title>
    <link href="/golang/ipc-map/"/>
    <url>/golang/ipc-map/</url>
    
    <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p><code>func (*Map) Delete</code><br><code>func (*Map) Load</code><br><code>func (*Map) LoadAndDelete</code><br><code>func (*Map) LoadOrStore</code><br><code>func (*Map) Range</code><br><code>func (*Map) Store</code></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程之任务协作—(2)Context</title>
    <link href="/golang/ipc-context/"/>
    <url>/golang/ipc-context/</url>
    
    <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ul><li>根 Context：通过 context.Background() 创建</li><li>子 Context: 通过 context.WithCancel(parentContext) 创建<ul><li>ctx, cancel := context.WithCancel(context.Background())</li></ul></li><li>当前 Context 被取消时，其它的子 context 都会被取消</li><li>接收取消通知 &lt;-ctx.Done()</li></ul><p>只执行一次</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;timer := time.NewTimer(time.Second * <span class="hljs-number">5</span>)data := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">999</span>, <span class="hljs-number">8</span>, <span class="hljs-number">345</span>, <span class="hljs-number">7</span>, <span class="hljs-number">98</span>, <span class="hljs-number">33</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>, <span class="hljs-number">88</span>, <span class="hljs-number">68</span>, <span class="hljs-number">96</span>&#125;dataLen := <span class="hljs-built_in">len</span>(data)size := <span class="hljs-number">3</span>target := <span class="hljs-number">345</span>ctx, cancel := context.WithCancel(context.Background())resultChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; dataLen; i += size &#123;end := i + size<span class="hljs-keyword">if</span> end &gt;= dataLen &#123;end = dataLen - <span class="hljs-number">1</span>&#125;<span class="hljs-keyword">go</span> SearchTarget(ctx, data[i:end], target, resultChan)&#125;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-timer.C:fmt.Fprintln(os.Stderr, <span class="hljs-string">&quot;Timeout! Not Found&quot;</span>)cancel()<span class="hljs-keyword">case</span> &lt;- resultChan:fmt.Fprintf(os.Stdout, <span class="hljs-string">&quot;Found it!\n&quot;</span>)cancel()&#125;time.Sleep(time.Second * <span class="hljs-number">2</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SearchTarget</span><span class="hljs-params">(ctx context.Context, data []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>, resultChan <span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)</span></span> &#123;<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> data &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;- ctx.Done():fmt.Fprintf(os.Stdout, <span class="hljs-string">&quot;Task cancelded! \n&quot;</span>)<span class="hljs-keyword">return</span><span class="hljs-keyword">default</span>:&#125;<span class="hljs-comment">// 模拟一个耗时查找，这里只是比对值，真实开发中可以是其他操作</span>fmt.Fprintf(os.Stdout, <span class="hljs-string">&quot;v: %d \n&quot;</span>, v)time.Sleep(time.Millisecond * <span class="hljs-number">1500</span>)<span class="hljs-keyword">if</span> target == v &#123;resultChan &lt;- <span class="hljs-literal">true</span><span class="hljs-keyword">return</span>&#125;&#125;&#125;</code></pre></div><p>gin</p><div class="code-wrapper"><pre><code class="hljs go"></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程之任务协作—(1)ErrGroup</title>
    <link href="/golang/ipc-errgroup/"/>
    <url>/golang/ipc-errgroup/</url>
    
    <content type="html"><![CDATA[<p><code>func WithContext(ctx context.Context) (*Group, context.Context)</code></p><p><code>func (g *Group) Go(f func() error)</code></p><p><code>func (g *Group) Wait() error</code></p><p><code>&lt;-errContext.Done()</code></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;g, ctx := errgroup.WithContext(context.Background())mux := http.NewServeMux()mux.HandleFunc(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;pong&quot;</span>))&#125;)<span class="hljs-comment">// 模拟单个服务错误退出</span>serverOut := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)mux.HandleFunc(<span class="hljs-string">&quot;/shutdown&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;serverOut &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;&#125;)server := http.Server&#123;Handler: mux,Addr:    <span class="hljs-string">&quot;:8080&quot;</span>,&#125;<span class="hljs-comment">// g1</span><span class="hljs-comment">// g1 退出了所有的协程都能退出么？</span><span class="hljs-comment">// g1 退出后, context 将不再阻塞，g2, g3 都会随之退出</span><span class="hljs-comment">// 然后 main 函数中的 g.Wait() 退出，所有协程都会退出</span>g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> server.ListenAndServe()&#125;)<span class="hljs-comment">// g2</span><span class="hljs-comment">// g2 退出了所有的协程都能退出么？</span><span class="hljs-comment">// g2 退出时，调用了 shutdown，g1 会退出</span><span class="hljs-comment">// g2 退出后, context 将不再阻塞，g3 会随之退出</span><span class="hljs-comment">// 然后 main 函数中的 g.Wait() 退出，所有协程都会退出</span>g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-ctx.Done():log.Println(<span class="hljs-string">&quot;errgroup exit...&quot;</span>)<span class="hljs-keyword">case</span> &lt;-serverOut:log.Println(<span class="hljs-string">&quot;server will out...&quot;</span>)&#125;timeoutCtx, cancel := context.WithTimeout(context.Background(), <span class="hljs-number">3</span>*time.Second)<span class="hljs-comment">// 这里不是必须的，但是如果使用 _ 的话静态扫描工具会报错，加上也无伤大雅</span><span class="hljs-keyword">defer</span> cancel()log.Println(<span class="hljs-string">&quot;shutting down server...&quot;</span>)<span class="hljs-keyword">return</span> server.Shutdown(timeoutCtx)&#125;)<span class="hljs-comment">// g3</span><span class="hljs-comment">// g3 捕获到 os 退出信号将会退出</span><span class="hljs-comment">// g3 退出了所有的协程都能退出么？</span><span class="hljs-comment">// g3 退出后, context 将不再阻塞，g2 会随之退出</span><span class="hljs-comment">// g2 退出时，调用了 shutdown，g1 会退出</span><span class="hljs-comment">// 然后 main 函数中的 g.Wait() 退出，所有协程都会退出</span>g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">0</span>)signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-ctx.Done():<span class="hljs-keyword">return</span> ctx.Err()<span class="hljs-keyword">case</span> sig := &lt;-quit:<span class="hljs-keyword">return</span> errors.Errorf(<span class="hljs-string">&quot;get os signal: %v&quot;</span>, sig)&#125;&#125;)fmt.Printf(<span class="hljs-string">&quot;errgroup exiting: %+v\n&quot;</span>, g.Wait())&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程之任务协作—(1)WaitGroup、Once</title>
    <link href="/golang/ipc-waitgrouponce/"/>
    <url>/golang/ipc-waitgrouponce/</url>
    
    <content type="html"><![CDATA[<h1 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><code>func (*WaitGroup) Add</code><br><code>func (*WaitGroup) Done</code><br><code>func (*WaitGroup) Wait</code></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> wg sync.WaitGroup<span class="hljs-comment">//...</span>wg.Add(<span class="hljs-number">1</span>)<span class="hljs-comment">//...</span>wg.Done()<span class="hljs-comment">//...</span>wg.Wait()</code></pre></div><p>好先统一 Add，再并发 Done，最后 Wait。</p><h1 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h1><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p><code>func (*Once) Do</code></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> once sync.Onceonce.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//...</span>&#125;)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式文章索引</title>
    <link href="/design-pattern/a/"/>
    <url>/design-pattern/a/</url>
    
    <content type="html"><![CDATA[<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="http://gk.link/a/10txN">极客时间专栏《设计模式之美》</a></p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><ul><li>面向对象的四大特性：封装、抽象、继承、多态</li><li>面向对象编程与面向过程编程的区别和联系</li><li>面向对象分析、面向对象设计、面向对象编程</li><li>接口和抽象类的区别以及各自的应用场景</li><li>基于接口而非实现编程的设计思想</li><li>多用组合少用继承的设计思想</li><li>面向过程的贫血模型和面向对象的充血模型、失血模型</li></ul><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><ul><li>SOLID 原则 -SRP 单一职责原则</li><li>SOLID 原则 -OCP 开闭原则</li><li>SOLID 原则 -LSP 里式替换原则</li><li>SOLID 原则 -ISP 接口隔离原则</li><li>SOLID 原则 -DIP 依赖倒置原则<ul><li>控制反转、依赖反转、依赖注入</li></ul></li><li>DRY 原则</li><li>KISS 原则</li><li>YAGNI 原则</li><li>LOD 法则</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h1 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h1><h1 id="重构技巧"><a href="#重构技巧" class="headerlink" title="重构技巧"></a>重构技巧</h1><h1 id="COW"><a href="#COW" class="headerlink" title="COW"></a>COW</h1><p><strong>参考</strong><br><a href="https://chunlife.top/2019/09/03/copy-on-write%E6%8A%80%E6%9C%AF/">copy-on-write技术</a><br><a href="https://juejin.cn/post/6844903702373859335">COW奶牛！Copy On Write机制了解一下</a><br><a href="https://chunlife.top/2019/09/03/copy-on-write%E6%8A%80%E6%9C%AF/">copy-on-write技术</a></p><p>写入时复制（英语：Copy-on-write，简称COW）是一种计算机程序设计领域的优化策略。</p><p>其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>fork()之后，kernel把父进程中所有的内存页的权限都设为read-only，然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写内存时，CPU硬件检测到内存页是read-only的，于是触发页异常中断（page-fault），陷入kernel的一个中断例程。中断例程中，kernel就会把触发的异常的页复制一份，于是父子进程各自持有独立的一份。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>redis 有两种方式持久化，一种是 RDB，一种是AOF。<br>在 RDB 中，想要触发持久化操作，可以执行 save、bgsave 命令，或者通过配置文件自动触发，其中 bgsave 的方式，就是 fork 一个子进程来做持久化工作。<br>最初，父进程和子进程拥有相同的内存空间地址，而如果父进程这个时候有写操作，因为内存页设置为 read-only 了，所以会触发 page-fault，父进程中修改数据所在的那个内存页会被指向到新的内存空间地址，而子进程读的还是修改之前的数据。</p><p>有坑吗？有的<br>如果全量更新数据恰好处于 rdb 持久化任务过程中，内存可能就会翻倍。</p><p><a href="https://www.cnblogs.com/javazhiyin/p/11425060.html">10分钟彻底理解Redis的持久化机制：RDB和AOF</a><br><a href="https://www.cnblogs.com/javazhiyin/p/12985656.html">看完这篇还不懂Redis的RDB持久化，你们来打我！</a></p><h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>所有驱动都用到的技术——写时复制（CoW）。CoW就是copy-on-write，表示只在需要写时才去复制，这个是针对已有文件的修改场景。比如基于一个image启动多个Container，如果为每个Container都去分配一个image一样的文件系统，那么将会占用大量的磁盘空间。而CoW技术可以让所有的容器共享image的文件系统，所有数据都从image中读取，只有当要对文件进行写操作时，才从image里把要写的文件复制到自己的文件系统进行修改。所以无论有多少个容器共享同一个image，所做的写操作都是对从image中复制到自己的文件系统中的复本上进行，并不会修改image的源文件，且多个容器操作同一个文件，会在每个容器的文件系统里生成一个复本，每个容器修改的都是自己的复本，相互隔离，相互不影响。使用CoW可以有效的提高磁盘的利用率。</p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><h3 id="更新配置文件"><a href="#更新配置文件" class="headerlink" title="更新配置文件"></a>更新配置文件</h3><p>比较适用于读多写少的场景，且允许更新有稍许的延迟，复制旧数据到新数据后，修改配置，在利用原子操作进行替换，无锁访问共享数据。<br>既然互斥锁会造成阻塞，那么读写锁呢？<br>下面这段话适合 go 并发编程<br>我们知道读写锁中不互斥的只有”读读”，如果一个资源被上了写锁，其它线程过来读，还是会阻塞的，但是COW方案不会这样。<br>使用COW，就是为了避免使用锁<br>空间换时间</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>Copy-on-write在对数据进行修改的时候，不会直接在原来的数据位置上进行操作，而是重新找个位置修改，这样的好处是一旦系统突然断电，重启之后不需要做Fsck。好处就是能保证数据的完整性，掉电的话容易恢复。<br>比如说：要修改数据块A的内容，先把A读出来，写到B块里面去。如果这时候断电了，原来A的内容还在！</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文章索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql文章索引</title>
    <link href="/mysql/a/"/>
    <url>/mysql/a/</url>
    
    <content type="html"><![CDATA[<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="http://gk.link/a/10sVJ">极客时间《MySQL实战45讲》</a><br><a href="https://u.jd.com/6w6S0IY">书籍《高性能MySQL（第三版）》</a></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>长连接 ➕ <span class="label label-info">mysql_reset_connection</span><br>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。<br>这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>建议不要使用缓存，因为失效频繁</p><span class="label label-info">query_cache_type=DEMAND</span><p>这样对于默认的 SQL 语句都不使用查询缓存。</p><span class="label label-info">SQL_CACHE</span><p>对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定<br><code>select SQL_CACHE * from T where ID=10；</code></p><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>词法分析、语法分析，包括表字段是否存在</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>选择索引</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>执行查询的权限</p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p><img src="/images/mysql/logical-architecture.png" alt="MySQL逻辑架构图"></p><h2 id="事务特征"><a href="#事务特征" class="headerlink" title="事务特征"></a>事务特征</h2><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><span class="label label-info">transaction-isolation</span><p>用来设置隔离级别</p><h3 id="读未提交（read-uncommitted）"><a href="#读未提交（read-uncommitted）" class="headerlink" title="读未提交（read uncommitted）"></a>读未提交（read uncommitted）</h3><p>一个事务还没提交时，它做的变更就能被别的事务看到。</p><h3 id="读提交（read-committed）"><a href="#读提交（read-committed）" class="headerlink" title="读提交（read committed）"></a>读提交（read committed）</h3><p>一个事务提交之后，它做的变更才会被其他事务看到。</p><h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</p><p>如果是可重复读隔离级别，事务 T 启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数据，事务 T 看到的仍然跟在启动时看到的一样。也就是说，一个在可重复读隔离级别下执行的事务，好像与世无争，不受外界影响。</p><h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p>“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p><h2 id="隔离问题"><a href="#隔离问题" class="headerlink" title="隔离问题"></a>隔离问题</h2><h3 id="脏读（dirty-read）"><a href="#脏读（dirty-read）" class="headerlink" title="脏读（dirty read）"></a>脏读（dirty read）</h3><h3 id="不可重复读（non-repeatable-read）"><a href="#不可重复读（non-repeatable-read）" class="headerlink" title="不可重复读（non-repeatable read）"></a>不可重复读（non-repeatable read）</h3><h3 id="幻读（phantom-read）"><a href="#幻读（phantom-read）" class="headerlink" title="幻读（phantom read）"></a>幻读（phantom read）</h3><h2 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h2><p>MVCC</p><h2 id="事务起点"><a href="#事务起点" class="headerlink" title="事务起点"></a>事务起点</h2><p>begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。<br>如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。<br>第一种启动方式，一致性视图是在执行第一个快照读语句时创建的；<br>第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的。</p><h2 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h2><h3 id="1-显式启动事务语句"><a href="#1-显式启动事务语句" class="headerlink" title="1. 显式启动事务语句"></a>1. 显式启动事务语句</h3><span class="label label-info">set autocommit=1</span><p>通过显式语句的方式来启动事务<br>begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。</p><span class="label label-info">commit work and chain</span><p>如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p><h3 id="2-隐式启动事务语句"><a href="#2-隐式启动事务语句" class="headerlink" title="2. 隐式启动事务语句"></a>2. 隐式启动事务语句</h3><span class="label label-info">set autocommit=0</span><p>这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。</p><div class="note note-success">            <p>推荐autocommit=1</p>          </div><div class="note note-warning">            <p>select是只读的，这也需要事务？</p><p>select是只读的没问题。<br>但是如果你的select是在autocommit=0的情况下去执行的，也就是这样：<br>set autocommit=0;<br>select * from t;<br>这个时候这个select语句也会开启一个事务，如果你不执行commit;那么这个事务就一直开启着。虽然这一个只读的事务。<br>上面两个命令等价于你显示的开启事务没有提交，像下面这样：<br>begin;<br>select * from t;</p>          </div><div class="note note-danger">            <p>长事务<br>set autocommit=0 ➕  长连接 容易导致长事务</p><p>在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。<br>select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60</p>          </div><h2 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h2><div class="note note-info">            <p>Write-Ahead Logging，先写日志，再写磁盘。</p>          </div><h2 id="crash-safe"><a href="#crash-safe" class="headerlink" title="crash-safe"></a>crash-safe</h2><div class="note note-info">            <p>数据库发生异常重启，之前提交的记录都不会丢失</p>          </div><h2 id="两阶段提交（prepare、commit）"><a href="#两阶段提交（prepare、commit）" class="headerlink" title="两阶段提交（prepare、commit）"></a>两阶段提交（prepare、commit）</h2><p>简单的 update 语句时的内部流程</p><ol><li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li></ol><p><img src="/images/mysql/2pc-update.png" alt="两阶段提交-update语句执行"></p><h2 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo log（重做日志）"></a>redo log（重做日志）</h2><div class="note note-info">            <p>InnoDB 引擎特有的日志，WAL 机制、拥有 crash-safe。</p>          </div><span class="label label-info">innodb_flush_log_at_trx_commit</span><p>参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数我建议你设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。</p><p><img src="/images/mysql/redo-log-struct.png" alt="redo log 结构图"></p><h2 id="刷脏页（flush）"><a href="#刷脏页（flush）" class="headerlink" title="刷脏页（flush）"></a>刷脏页（flush）</h2><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><ol><li>redo log 写满了</li><li>空闲</li><li>正常关闭</li></ol><h2 id="页（page）"><a href="#页（page）" class="headerlink" title="页（page）"></a>页（page）</h2><p>你知道的，InnoDB 的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。</p><h2 id="脏页"><a href="#脏页" class="headerlink" title="脏页"></a>脏页</h2><p>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。</p><h2 id="干净页"><a href="#干净页" class="headerlink" title="干净页"></a>干净页</h2><p>内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。</p><h2 id="binlog（归档日志）"><a href="#binlog（归档日志）" class="headerlink" title="binlog（归档日志）"></a>binlog（归档日志）</h2><div class="note note-info">            <p>Server 层自己的日志。</p>          </div><h3 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h3><p>有些 statement 格式的 binlog 可能会导致主备不一致。<br>比如你用一个 delete 语句删掉 10 万行数据，用 statement 的话就是一个 SQL 语句被记录到 binlog 中，占用几十个字节的空间。</p><h3 id="row"><a href="#row" class="headerlink" title="row"></a>row</h3><p>row 格式的缺点是，很占空间。<br>但如果用 row 格式的 binlog，就要把这 10 万条记录都写到 binlog 中。这样做，不仅会占用更大的空间，同时写 binlog 也要耗费 IO 资源，影响执行速度。</p><h3 id="mixed"><a href="#mixed" class="headerlink" title="mixed"></a>mixed</h3><p>所以，MySQL 就取了个折中方案，也就是有了 mixed 格式的 binlog。mixed 格式的意思是，MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式，否则就用 statement 格式。<br>也就是说，mixed 格式可以利用 statment 格式的优点，同时又避免了数据不一致的风险。</p><span class="label label-info">sync_binlog</span><p>这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数我也建议你设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。</p><h2 id="删表找回"><a href="#删表找回" class="headerlink" title="删表找回"></a>删表找回</h2><ol><li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</li><li>然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。</li></ol><h2 id="一致性读视图（consistent-read-view）"><a href="#一致性读视图（consistent-read-view）" class="headerlink" title="一致性读视图（consistent read view）"></a>一致性读视图（consistent read view）</h2><p>InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。</p><p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）</p><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。</p><ul><li>在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</li><li>在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。</li><li>这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；</li><li>而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</li></ul><h2 id="多版本控制（MVCC）"><a href="#多版本控制（MVCC）" class="headerlink" title="多版本控制（MVCC）"></a>多版本控制（MVCC）</h2><p>read-view<br>undo log<br>当前读 current read<br>两阶段锁协议</p><h3 id="row-trx-id"><a href="#row-trx-id" class="headerlink" title="row trx_id"></a>row trx_id</h3><p>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。<br>而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。</p><ol><li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li><li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li><li>如果落在黄色部分，那就包括两种情况<br>a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；<br>b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li></ol><h2 id="undo-log（回滚日志）"><a href="#undo-log（回滚日志）" class="headerlink" title="undo log（回滚日志）"></a>undo log（回滚日志）</h2><p>语句更新会生成 undo log（回滚日志）<br>实际上，图 2 中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。</p><h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h2><p>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）</p><h2 id="重要的一讲"><a href="#重要的一讲" class="headerlink" title="重要的一讲"></a>重要的一讲</h2><p>(事务隔离)[<a href="https://time.geekbang.org/column/article/70562]">https://time.geekbang.org/column/article/70562]</a></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><p>增删改数据</p><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><p>加字段等修改表结构</p><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><span class="label label-info">Flush tables with read lock</span><p>FTWRL 全局锁的典型使用场景是，做全库逻辑备份</p><h3 id="FTWRL"><a href="#FTWRL" class="headerlink" title="FTWRL"></a>FTWRL</h3><p>对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用 FTWRL 命令了。</p><h3 id="一致性视图"><a href="#一致性视图" class="headerlink" title="一致性视图"></a>一致性视图</h3><p>对于 InnoDB 引擎，mysqldump 使用参数–single-transaction，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p><h3 id="元数据锁（MDL）"><a href="#元数据锁（MDL）" class="headerlink" title="元数据锁（MDL）"></a>元数据锁（MDL）</h3><span class="label label-info">meta data lock</span><p>一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p><h2 id="如何安全地给小表加字段？"><a href="#如何安全地给小表加字段？" class="headerlink" title="如何安全地给小表加字段？"></a>如何安全地给小表加字段？</h2><p>首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。<br>比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tbl_name NOWAIT <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> ...<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tbl_name WAIT N <span class="hljs-keyword">add</span> <span class="hljs-keyword">column</span> ...</code></pre></div><h2 id="查看事务"><a href="#查看事务" class="headerlink" title="查看事务"></a>查看事务</h2><p>information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务</p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><h2 id="两阶段锁协议"><a href="#两阶段锁协议" class="headerlink" title="两阶段锁协议"></a>两阶段锁协议</h2><p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。</p><h2 id="行锁建议"><a href="#行锁建议" class="headerlink" title="行锁建议"></a>行锁建议</h2><p>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><span class="label label-info">innodb_lock_wait_timeout</span><p>一种策略是，直接进入等待，直到超时。</p><span class="label label-info">innodb_deadlock_detect</span><p>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</p><h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><p>对于 count(主键 id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。单看这两个用法的差别的话，你能对比出来，count(1) 执行得要比 count(主键 id) 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。对于 count(字段) 来说：如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。也就是前面的第一条原则，server 层要什么字段，InnoDB 就返回什么字段。但是 count(<em>) 是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(</em>) 肯定不是 null，按行累加。</p><h2 id="间隙锁-Gap-Lock"><a href="#间隙锁-Gap-Lock" class="headerlink" title="间隙锁 (Gap Lock)"></a>间隙锁 (Gap Lock)</h2><p>InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。</p><h2 id="next-key-lock"><a href="#next-key-lock" class="headerlink" title="next-key lock"></a>next-key lock</h2><p>间隙锁和行锁合称 next-key lock</p>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文章索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法系列文章索引</title>
    <link href="/datastruct-algorithm/a/"/>
    <url>/datastruct-algorithm/a/</url>
    
    <content type="html"><![CDATA[<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="http://gk.link/a/10txE">极客时间专栏《数据结构与算法之美》</a><br><a href="http://gk.link/a/10txH">极客时间专栏《算法面试通关40讲》</a><br><a href="https://u.jd.com/6MG4eU3">书籍《算法》第四版</a><br><a href="https://u.jd.com/6D6C87m">书籍《数据结构与算法之美》</a></p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>大部分的数据结构基本上都是由数组或者链表演变而来</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p><strong>MySQL</strong> B+</p><p><strong>MongoDB</strong> B</p><p><strong>Redis</strong> Skip List</p><p><strong>Memcache</strong> Hash</p><p><strong>TiDB</strong> LSM Tree</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p><strong>基数树</strong> golang的web框架echo和gin都使用了radix tree作为路由查找的算法</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>TCP流量控制</p><h3 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程/线程"></a>进程/线程</h3><p><a href="https://zhuanlan.zhihu.com/p/97071815">详解操作系统内核对线程的调度算法</a></p><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p><a href="https://segmentfault.com/a/1190000021199728">图解一致性哈希算法</a><br><a href="http://blog.codinglabs.org/articles/consistent-hashing.html">一致性哈希算法及其在分布式系统中的应用</a><br><a href="https://github.com/RJ/ketama">https://github.com/RJ/ketama</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文章索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络编程文章索引</title>
    <link href="/netprogram/a/"/>
    <url>/netprogram/a/</url>
    
    <content type="html"><![CDATA[<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="http://gk.link/a/10txL">极客时间《网络编程实战》</a><br><a href="">微信公众号《开发内功修炼》</a><br><a href="">PDF《理解了实现再谈网络性能》</a><br><a href="">书籍《TCP/IP网络编程》</a><br><a href="https://u.jd.com/6D6qdVu">书籍《UNIX环境高级编程（第三版）》</a></p><h1 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h1><h3 id="PPC"><a href="#PPC" class="headerlink" title="PPC"></a>PPC</h3><h3 id="Prefork"><a href="#Prefork" class="headerlink" title="Prefork"></a>Prefork</h3><h3 id="TPC"><a href="#TPC" class="headerlink" title="TPC"></a>TPC</h3><h3 id="Prethread"><a href="#Prethread" class="headerlink" title="Prethread"></a>Prethread</h3><h3 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h3><p>IO多路复用+进程/线程 池</p><h4 id="单-Reactor-单进程-线程"><a href="#单-Reactor-单进程-线程" class="headerlink" title="单 Reactor 单进程/线程"></a>单 Reactor 单进程/线程</h4><h4 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor 多线程**"></a>单 Reactor 多线程**</h4><h4 id="多-Reactor-多进程-线程"><a href="#多-Reactor-多进程-线程" class="headerlink" title="多 Reactor 多进程/线程**"></a>多 Reactor 多进程/线程**</h4><h3 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h3><h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><h4 id="Blocking-IO-阻塞I-O"><a href="#Blocking-IO-阻塞I-O" class="headerlink" title="Blocking IO - 阻塞I O"></a>Blocking IO - 阻塞I O</h4><h4 id="Nonblocking-IO-非阻塞IO"><a href="#Nonblocking-IO-非阻塞IO" class="headerlink" title="Nonblocking IO - 非阻塞IO"></a>Nonblocking IO - 非阻塞IO</h4><h4 id="IO-multiplexing-IO-多路复用"><a href="#IO-multiplexing-IO-多路复用" class="headerlink" title="IO multiplexing - IO 多路复用"></a>IO multiplexing - IO 多路复用</h4><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><h4 id="Signal-driven-IO-信号驱动式IO（异步阻塞）"><a href="#Signal-driven-IO-信号驱动式IO（异步阻塞）" class="headerlink" title="Signal-driven IO - 信号驱动式IO（异步阻塞）"></a>Signal-driven IO - 信号驱动式IO（异步阻塞）</h4><h4 id="Asynchronous-IO-异步IO"><a href="#Asynchronous-IO-异步IO" class="headerlink" title="Asynchronous IO - 异步IO"></a>Asynchronous IO - 异步IO</h4><h1 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h1><h3 id="线程与锁"><a href="#线程与锁" class="headerlink" title="线程与锁"></a>线程与锁</h3><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><h3 id="Clojure之道——分离标识与状态"><a href="#Clojure之道——分离标识与状态" class="headerlink" title="Clojure之道——分离标识与状态"></a>Clojure之道——分离标识与状态</h3><h3 id="actor"><a href="#actor" class="headerlink" title="actor"></a>actor</h3><h3 id="通信顺序进程-CSP"><a href="#通信顺序进程-CSP" class="headerlink" title="通信顺序进程 CSP"></a>通信顺序进程 CSP</h3><p>CSP vs Actor<br>CSP 通过 channel 进行通信，更松耦合。<br>GO 中的 channel 有容量限制并且独立于处理 goroutine，如 Erlang、Actor 模式中的 mailbox 容量是无限的，接收进程也总是被动的处理消息。</p><h3 id="数据级并行"><a href="#数据级并行" class="headerlink" title="数据级并行"></a>数据级并行</h3><h3 id="Lambda架构"><a href="#Lambda架构" class="headerlink" title="Lambda架构"></a>Lambda架构</h3><h1 id="C语言同步函数"><a href="#C语言同步函数" class="headerlink" title="C语言同步函数"></a>C语言同步函数</h1><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>int pthread_mutex_init(pthread_mutex_t * __restrict, const pthread_mutexattr_t * _Nullable __restrict);：初始化<br>int pthread_mutex_destroy(pthread_mutex_t *)：销毁<br>int pthread_mutex_lock(pthread_mutex_t *)：加锁<br>int pthread_mutex_unlock(pthread_mutex_t *)：解锁</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>int pthread_cond_init(pthread_cond_t * __restrict, const pthread_condattr_t * _Nullable __restrict)：初始化<br>int pthread_cond_destroy(pthread_cond_t *)：销毁<br>int pthread_cond_wait(pthread_cond_t * __restrict, pthread_mutex_t * __restrict)：等待<br>int pthread_cond_signal(pthread_cond_t *)：发送单发通知<br>int pthread_cond_broadcast(pthread_cond_t *)：发送广播通知</p><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>int pthread_create(pthread_t _Nullable * _Nonnull __restrict, const pthread_attr_t * _Nullable __restrict, void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable __restrict)：创建</p><h1 id="http2"><a href="#http2" class="headerlink" title="http2"></a>http2</h1><p>http2最大的不同就是 服务端可以给客户端发请求，最大的好处就是 少了 很多 客户端对服务端的试探、询问，客户端直接就告诉服务端，应该在什么时间的时候通知我就OK了，仔细想想，这像不像epoll的事件注册中的 边缘触发。</p>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文章索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>方案文章索引</title>
    <link href="/program/a/"/>
    <url>/program/a/</url>
    
    <content type="html"><![CDATA[<ol><li>秒杀</li><li>朋友圈</li><li>聊天系统</li><li>游戏体力与消耗</li><li>定时任务限制</li><li>海量日志</li><li>动态短信发送</li></ol><p>QPS<br><a href="https://segmentfault.com/a/1190000010844969">https://segmentfault.com/a/1190000010844969</a></p>]]></content>
    
    
    <categories>
      
      <category>方案</category>
      
    </categories>
    
    
    <tags>
      
      <tag>方案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发编程</title>
    <link href="/golang/concurrent-programme/"/>
    <url>/golang/concurrent-programme/</url>
    
    <content type="html"><![CDATA[<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开始学习 Go 特性的并发编程之前，先来简单了解一些基础概念，这对理解学习 Go 并发模型会有一些帮助。</p><span id="more"></span><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="内核态"><a href="#内核态" class="headerlink" title="内核态"></a>内核态</h3><p>也被称为内核空间，是系统内核的运行空间，与用户空间隔离。控制计算机的硬件资源。</p><h3 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h3><p>也被称为用户空间，代码运行在较低的特权级别上，不能直接访问内核空间和硬件设备。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>用户空间不能直接调用系统资源，必须通过调用系统接口，由内核完成相关指令。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是操作系统分配资源的最小单元。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>有时也被称为轻量级进程（LWP），是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。</p><h3 id="KSE"><a href="#KSE" class="headerlink" title="KSE"></a>KSE</h3><p>理论上说 Linux 内核是没有线程这个概念的，只有内核调度实体（Kernal Scheduling Entry）这个概念。</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>有时也被称为微线程（Coroutine），只不过这个线程是用户态的，不需要操作系统参与。</p><p>调度过程示例：</p><ol><li>coroutine A 进行 网络I/O，使用 write() 发送数据后调用 read() 等待数据的返回，但是不一定什么时候能够读到数据，所以将 Socket Fd 放入 EventLoop 中。</li><li>coroutine A 让出 CPU 给 其它 coroutine 使用 —— <strong>挂起（yield）</strong></li><li>待 read() 有返回数据后，继续执行 coroutine A  —— <strong>恢复（resume）</strong></li></ol><p><em>EventLoop：无限循环着的事件分发器，一旦有事件发生，它就会回调预先定义好的回调函数，完成事件的处理。</em></p><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p><strong>M:1</strong> 多个用户空间的线程，对应一个内核空间的 KSE。</p><h4 id="系统级线程"><a href="#系统级线程" class="headerlink" title="系统级线程"></a>系统级线程</h4><p><strong>1:1</strong> 1个用户空间的线程，对应1个内核空间的 KSE。</p><h4 id="两级线程模型（混合式线程模型）"><a href="#两级线程模型（混合式线程模型）" class="headerlink" title="两级线程模型（混合式线程模型）"></a>两级线程模型（混合式线程模型）</h4><p><strong>M:N</strong> 多个用户空间的线程，对应多个内核空间的 KSE。</p><h3 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h3><p>并发模型指定了系统中的线程如何通过协作来完成分配给它们的作业。不同的并发模型采用不同的方式拆分作业，同时线程间的协作和交互方式也不相同。</p><p>常见的有：</p><ul><li>线程&amp;锁</li><li>Actor</li><li>CSP</li><li>Lambda 架构</li></ul><h3 id="并发模型—CSP"><a href="#并发模型—CSP" class="headerlink" title="并发模型—CSP"></a>并发模型—CSP</h3><p>Communicating Sequential Processes 通信顺序进程。</p><p>看这个名字就能知道，在CSP模型中主角是<strong>通信</strong>。</p><blockquote><p>channel：进行通信的并发模型。<br>worker：channel 两端的发送者/接收者。</p></blockquote><p>worker 之间不直接彼此联系，而是通过 channel 进行消息发送和接收。</p><p>在并发模型中，经常和 CSP 一起讨论的是 Actor 模型。</p><h3 id="GO-线程模型"><a href="#GO-线程模型" class="headerlink" title="GO 线程模型"></a>GO 线程模型</h3><p>Go 参考了<strong>两级线程模型</strong>，设计出了 MPG 线程模型。</p><h4 id="M"><a href="#M" class="headerlink" title="M"></a>M</h4><p>machine</p><p>用户空间内的线程，与 KSE 一一对应，可以理解为 M 代表了 内核线程。</p><h4 id="P"><a href="#P" class="headerlink" title="P"></a>P</h4><p>processor</p><p>可以理解为用户代码逻辑的处理器，Go 代码片段所必需的上下文环境。</p><h4 id="G"><a href="#G" class="headerlink" title="G"></a>G</h4><p>goroutine</p><p>Go 代码片段的封装。</p><div class="code-wrapper"><pre><code class="hljs actionscript">go <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//  ...</span>&#125;()</code></pre></div><h3 id="GO并发模型"><a href="#GO并发模型" class="headerlink" title="GO并发模型"></a>GO并发模型</h3><h4 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h4><p>参考了 <strong>CSP并发模型</strong>。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="goroutine-与-coroutine-的区别"><a href="#goroutine-与-coroutine-的区别" class="headerlink" title="goroutine 与 coroutine 的区别"></a>goroutine 与 coroutine 的区别</h3><h4 id="coroutine"><a href="#coroutine" class="headerlink" title="coroutine"></a>coroutine</h4><p>运行机制属于协作式任务处理，始终顺序执行。</p><h4 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h4><p>运行机制属于抢占式任务处理，可能发生并行执行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Go 的并发模型参考了 CSP并发模型，采用 channel 进行通信。</li><li>Go 的线程模型参考了两级线程模型，设计出了 MPG 模型。</li><li>goroutine 与 coroutine 的区别就是前者可能发生并行执行，后者始终顺序执行。</li></ol><div class="note note-success">            <p>并发编程三大特性（并发安全的三个重要指标）——原子性、可见性、有序性</p>          </div><div class="note note-success">            <p>并发、并行不是一回事儿</p>          </div><h1 id="CPU、内存"><a href="#CPU、内存" class="headerlink" title="CPU、内存"></a>CPU、内存</h1><h2 id="CPU-Cache"><a href="#CPU-Cache" class="headerlink" title="CPU Cache"></a>CPU Cache</h2><p>CPU Cache，是位于 CPU 与 内存 之间的临时存储，要比直接读取内存快；除了速度快，CPU 还会根据一些规则 预热数据，以 Cache line 为单位存储在 CPU Cache 中。<br>CPU Cache 可以分为一级缓存（L1），二级缓存（L2），三级缓存（L3）。</p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p><a href="https://www.cnblogs.com/cyfonly/p/5800758.html">https://www.cnblogs.com/cyfonly/p/5800758.html</a></p><h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><p>下面的代码有什么问题？<br>没有用到 cpu cache 加速</p><h2 id="可见性：由-CPU-Cache-所带来的问题"><a href="#可见性：由-CPU-Cache-所带来的问题" class="headerlink" title="可见性：由 CPU Cache 所带来的问题"></a>可见性：由 CPU Cache 所带来的问题</h2><p>为了解决 CPU 读取内存速度慢的问题，所以增加了CPU缓存，但这也导致了可见性问题。<br>可见性的意思就是线程A修改了一个东西，要对线程B可见。</p><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>由于 CPU Cache 导致内存不一致的问题，叫做 False sharing，为了解决了这个问题，CPU Cache 引入了缓存一致性协议 MESI。</p><h3 id="相关文章-1"><a href="#相关文章-1" class="headerlink" title="相关文章"></a>相关文章</h3><p><a href="https://www.cnblogs.com/cyfonly/p/5800758.html">https://www.cnblogs.com/cyfonly/p/5800758.html</a></p><h2 id="有序性：重排所引发的问题"><a href="#有序性：重排所引发的问题" class="headerlink" title="有序性：重排所引发的问题"></a>有序性：重排所引发的问题</h2><p>重排存在于两种情况，如下：<br>CPU重排：会对读写指令进行重排，也可以说是内存重排。<br>编译器重排：编译器在生成指令序列时和CPU执行指令序列时，有可能重排序。</p><h3 id="相关文章-2"><a href="#相关文章-2" class="headerlink" title="相关文章"></a>相关文章</h3><p><a href="https://segmentfault.com/a/1190000011458941">https://segmentfault.com/a/1190000011458941</a></p><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>为了解决可见性，提出了 happens-before 原则，来指导多线程内存共享层面的设计。</p><p>下面是原则描述，但具体的规则指定，各个语言不同。</p><ul><li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在 happens-before 关系，并不意味着一定要按照 happens-before 原则制定的顺序来执行。如果重排序之后的执行结果与按照 happens-before 关系来执行的结果一致，那么这种重排序并不非法。</li></ul><h3 id="相关文章-3"><a href="#相关文章-3" class="headerlink" title="相关文章"></a>相关文章</h3><p><a href="https://golang.org/ref/mem">https://golang.org/ref/mem</a><br><a href="https://www.jianshu.com/p/5e44168f47a3">https://www.jianshu.com/p/5e44168f47a3</a><br><a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/10.1.html">https://tiancaiamao.gitbooks.io/go-internals/content/zh/10.1.html</a><br><a href="https://segmentfault.com/a/1190000021829769">https://segmentfault.com/a/1190000021829769</a><br><a href="https://segmentfault.com/a/1190000011458941">https://segmentfault.com/a/1190000011458941</a><br><a href="https://blog.csdn.net/q5706503/article/details/84994964">https://blog.csdn.net/q5706503/article/details/84994964</a><br><a href="https://www.jianshu.com/p/ba9114542bb7">https://www.jianshu.com/p/ba9114542bb7</a></p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>内存屏障（Memory Barriers、fence）是一种底层原语。</p><p>上面说过，CPU Cache 提高了内存读写性能，但是导致了可见性的相关问题，所以 happens-before 提供了一种原则，提供给编程语言底层在内存管理、并发安全方面的设计。<br>上面还说过，编译器重排、CPU重排，所以，内存屏障也分为编译器屏障和CPU内存屏障。</p><p>CPU 级别的指令支持，它要求：barrier 指令要求所有对内存的操作都必须要“扩散”到 memory 之后才能继续执行其他对 memory 的操作。<br>比如在 Go 语言中，atomic 标准库的 CAS（比较并交换），两个操作合二为一，保证原子且有序。</p><h4 id="相关文章-4"><a href="#相关文章-4" class="headerlink" title="相关文章"></a>相关文章</h4><p><a href="https://www.jianshu.com/p/89b3e128ebd0?utm_campaign=studygolang.com&utm_medium=studygolang.com&utm_source=studygolang.com">https://www.jianshu.com/p/89b3e128ebd0?utm_campaign=studygolang.com&amp;utm_medium=studygolang.com&amp;utm_source=studygolang.com</a><br><a href="https://lday.me/2017/11/04/0016_what_is_memory_barriers/">https://lday.me/2017/11/04/0016_what_is_memory_barriers/</a></p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>可以理解为，计算机中最小粒度的操作。</p><p>a = b 是原子操作吗？答案是：非原子操作<br>因为 a = b 实际为两步：先取出 b 的值，再赋值给 a。</p><p>继续讨论<br>在第一步，取出 b 的值，是原子操作吗？<br>如果涉及内存访问，就算只有一条汇编指令的在多核系统上也不一定是原子操作。为啥这么说呢，因为：</p><p>32位系统CPU一次可处理32位数据，即一次处理4个字节(4 * 8 bit)。<br>64位系统CPU一次可处理64位数据，即一次处理8个字节(8 * 8 bit)。</p><p>go的内存模型就是为了解决 single（64位系统处理8字节，确实是原子的，但是不是可见的，因为有cacheline,cpu的应对方法就是mesi，go的方法就是内存屏障）</p><p><a href="https://www.cnblogs.com/yeyang/p/13576636.html">https://www.cnblogs.com/yeyang/p/13576636.html</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>限流</title>
    <link href="/microservices/ha-limit/"/>
    <url>/microservices/ha-limit/</url>
    
    <content type="html"><![CDATA[<p>令牌桶<br>正常我的系统处理一个请求需要100ms，那么就每100ms往桶里面放令牌，也就是每秒10个，速率为10，设置桶大小为20。<br>每隔100ms往桶里面放token，一直放到满。<br>如果满着的，则丢弃这个token，不满继续定时放。<br>允许突发，也就是满桶10个令牌同时被拿走。<br><code>NewLimiter(10, 20);</code></p><p>漏桶<br>uber 的 <a href="https://pkg.go.dev/go.uber.org/ratelimit">ratelimit</a></p><p>过载保护、单机限流、分布式限流、熔断</p><p><a href="https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html">Go可用性(四) 限流3: 漏桶算法</a></p><p>max-min fairness 最大最小分配算法。DRF</p><p>健康指标计算</p><p>流量整形</p><p>熔断<br>服务端(被调用方)一直拒绝也是消耗资源的，所以有时候需要客户端（调用方）采取熔断来给服务端减轻压力，避免雪上加霜。<br>hystrix、<br>google sre max(0, (requests - K * accepts) / (requests + 1))</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>可用性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务系列文章索引</title>
    <link href="/microservices/a/"/>
    <url>/microservices/a/</url>
    
    <content type="html"><![CDATA[<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="http://gk.link/a/10sIo">极客时间《go进阶训练营》</a><br><a href="http://gk.link/a/10tCs">极客时间《从0开始学架构》</a><br><a href="http://gk.link/a/10tCC">极客时间《Service Mesh实战》</a><br>DDD</p><h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><ol><li>gRPC</li></ol><h1 id="基础设施建设"><a href="#基础设施建设" class="headerlink" title="基础设施建设"></a>基础设施建设</h1><ol><li>部署与测试多集群，多租户</li><li>服务注册、发现、负载均衡</li><li>API网关</li></ol><h1 id="高可用设计"><a href="#高可用设计" class="headerlink" title="高可用设计"></a>高可用设计</h1><ol><li>隔离</li></ol><p><strong>参考</strong><br><a href="https://lailin.xyz/post/go-training-week6-usability-1-bulkhe.html">Go可用性(一) 隔离设计</a></p><ol start="2"><li><a href="/microservices/ha-limit/" title="限流">限流</a><input type="checkbox" disabled ></li><li>降级</li><li>熔断</li><li>超时</li><li>重试</li></ol><h1 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h1><p>CQRS<br>海量评论</p><h1 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h1><p>CQRS<br>Pipeline</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文章索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS</title>
    <link href="/ios/a/"/>
    <url>/ios/a/</url>
    
    <content type="html"><![CDATA[<p><a href="http://gk.link/a/10tyZ">极客时间《从0开发一款iOS App》</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文章索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go面向对象</title>
    <link href="/golang/oop/"/>
    <url>/golang/oop/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于 Go 是不是面向对象语言的讨论一直喋喋不休，但讨论的结果并不重要，重要的是验证它的过程。</p><p>每门语言都有它独特的设计思想或者语言哲学，我们不能被过往的经验、传统概念所困住，能够使用它更优雅的解决问题，才是一门优秀编程语言价值的体现，至于它到底是白猫还是黑猫，也就没那么重要了。</p><span id="more"></span><h1 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h1><p>先从大家都熟知的四大特性入手。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。</p><h3 id="Go的封装"><a href="#Go的封装" class="headerlink" title="Go的封装"></a>Go的封装</h3><p>Go语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而如果我们想要封装一个对象，我们必须将其定义为一个struct。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">// 重点在大小写，结构体名称、属性</span><span class="hljs-keyword">type</span> Html <span class="hljs-keyword">struct</span> &#123;Data <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Html)</span> <span class="hljs-title">read</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span></span> &#123;h.Data = <span class="hljs-string">&quot;sown&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Html)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;html&gt;&quot;</span> + h.Data + <span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>&#125;<span class="hljs-keyword">type</span> xml <span class="hljs-keyword">struct</span> &#123;data <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">read</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span></span> &#123;x.data = <span class="hljs-string">&quot;sown&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;xml&gt;&quot;</span> + x.data + <span class="hljs-string">&quot;&lt;/xml&gt;&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;h := Html&#123;&#125;h.read(<span class="hljs-string">&quot;./xml&quot;</span>)fmt.Println(h.format())x := xml&#123;&#125;x.read(<span class="hljs-string">&quot;./xml&quot;</span>)fmt.Println(x.format())&#125;</code></pre></div><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持。抽象存在的意义，一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。</p><p>我看网上有人用空结构体实现抽象类，我并不提倡这样做，遵循go的”面向接口编程”</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">// 定义接口</span><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;read(<span class="hljs-keyword">string</span>)format() <span class="hljs-keyword">string</span>&#125;<span class="hljs-keyword">type</span> Html <span class="hljs-keyword">struct</span> &#123;Data <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Html)</span> <span class="hljs-title">read</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span></span> &#123;h.Data = <span class="hljs-string">&quot;sown&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Html)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;html&gt;&quot;</span> + h.Data + <span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>&#125;<span class="hljs-keyword">type</span> xml <span class="hljs-keyword">struct</span> &#123;data <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">read</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span></span> &#123;x.data = <span class="hljs-string">&quot;sown&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;xml&gt;&quot;</span> + x.data + <span class="hljs-string">&quot;&lt;/xml&gt;&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;h := Html&#123;&#125;h.read(<span class="hljs-string">&quot;./xml&quot;</span>)fmt.Println(h.format())x := xml&#123;&#125;x.read(<span class="hljs-string">&quot;./xml&quot;</span>)fmt.Println(x.format())&#125;</code></pre></div><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。</p><p>继承是用来表示类之间的 is-a 关系，比如猫是一种哺乳动物。从继承关系上来讲，继承可以分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。</p><p>继承最大的一个好处就是代码复用。<br>如果我们再上升一个思维层面，去思考继承这一特性，非常符合人类的认知，而且，从设计的角度来说，也有一种结构美感。比如，子承父业，父债子偿。</p><p>如果继承层次过深过复杂，就会导致代码可读性、可维护性变差。举个🌰，如果让你穿越过去，寻找你爷爷的爷爷的爷爷的爷爷，然后一定要劝他搬到京城附近安家，这样你现在就不用每天996了。很显然，找人就已经很难了，再把居住的属性给改了，未知的事情就更多了，后来有没有你都是回事儿了（不过~，这样好像也确实摆脱996了）…</p><p>所以，有人提出来一种设计思想，就是”多用组合少用继承”。</p><p>那么 GO 可以实现继承吗？</p><h3 id="Go的单继承（组合）"><a href="#Go的单继承（组合）" class="headerlink" title="Go的单继承（组合）"></a>Go的单继承（组合）</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> file <span class="hljs-keyword">struct</span> &#123;data <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *file)</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;f.data = <span class="hljs-string">&quot;sown&quot;</span>&#125;<span class="hljs-keyword">type</span> Html <span class="hljs-keyword">struct</span> &#123;file <span class="hljs-comment">//重点在这</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Html)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> h.data&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;h := Html&#123;&#125;h.read() <span class="hljs-comment">//重点在这，等同于 h.file.read()</span>fmt.Println(h.format())&#125;</code></pre></div><h3 id="Go的多继承（组合）"><a href="#Go的多继承（组合）" class="headerlink" title="Go的多继承（组合）"></a>Go的多继承（组合）</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> file <span class="hljs-keyword">struct</span> &#123;data <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *file)</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;f.data = <span class="hljs-string">&quot;file&quot;</span>&#125;<span class="hljs-keyword">type</span> db <span class="hljs-keyword">struct</span> &#123;data <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *db)</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;d.data = <span class="hljs-string">&quot;db&quot;</span>&#125;<span class="hljs-keyword">type</span> Html <span class="hljs-keyword">struct</span> &#123;filedb&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Html)</span> <span class="hljs-title">format</span><span class="hljs-params">(data <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;html&gt;&quot;</span> + data + <span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;h := Html&#123;&#125;h.file.read() <span class="hljs-comment">//继承（组合）file</span>fmt.Println(h.format(h.file.data))h.db.read() <span class="hljs-comment">//继承（组合）db</span>fmt.Println(h.format(h.db.data))&#125;</code></pre></div><h3 id="继承（组合）的方法调用注意"><a href="#继承（组合）的方法调用注意" class="headerlink" title="继承（组合）的方法调用注意"></a>继承（组合）的方法调用注意</h3><p>其实这里的要注意的问题，不是语法问题，而是要注意在Go中继承并非其他语言中的继承，而是利用组合代替了继承。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;io/ioutil&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-keyword">type</span> file <span class="hljs-keyword">struct</span> &#123;data <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *file)</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> f.format() <span class="hljs-comment">//&lt;-----重点在这里</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *file)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;file.format&quot;</span>&#125;<span class="hljs-keyword">type</span> Html <span class="hljs-keyword">struct</span> &#123;file&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Html)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;html.format&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;h := Html&#123;&#125;content := h.read()fmt.Println(content) <span class="hljs-comment">//file.format</span>&#125;</code></pre></div><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> i <span class="hljs-keyword">interface</span> &#123;format(content <span class="hljs-keyword">string</span>) <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// 重点在这里</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">format</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>, i i)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> i.format(content)&#125;<span class="hljs-keyword">type</span> Html <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Html)</span> <span class="hljs-title">format</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;html&gt;&quot;</span> + content + <span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>&#125;<span class="hljs-keyword">type</span> Xml <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *Xml)</span> <span class="hljs-title">format</span><span class="hljs-params">(content <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;xml&gt;&quot;</span> + content + <span class="hljs-string">&quot;&lt;/xml&gt;&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;h := &amp;Html&#123;&#125;x := &amp;Xml&#123;&#125;fmt.Println(format(<span class="hljs-string">&quot;sown&quot;</span>, h)) <span class="hljs-comment">//&lt;html&gt;sown&lt;/html&gt;</span>fmt.Println(format(<span class="hljs-string">&quot;sown&quot;</span>, x)) <span class="hljs-comment">//&lt;xml&gt;sown&lt;/xml&gt;</span>&#125;</code></pre></div><h1 id="Go特性"><a href="#Go特性" class="headerlink" title="Go特性"></a>Go特性</h1><h2 id="方法的定义：关于指针、值复制"><a href="#方法的定义：关于指针、值复制" class="headerlink" title="方法的定义：关于指针、值复制"></a>方法的定义：关于指针、值复制</h2><p>第一种定义方式在实例对应方法被调用时，实例的成员会进行值复制。<br>第二种方法被调用时，避免了内存拷贝。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> Html <span class="hljs-keyword">struct</span> &#123;Data <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h Html)</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;h.Data = <span class="hljs-string">&quot;sown&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h Html)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;html&gt;&quot;</span> + h.Data + <span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>&#125;<span class="hljs-keyword">type</span> xml <span class="hljs-keyword">struct</span> &#123;data <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;x.data = <span class="hljs-string">&quot;sown&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;xml&gt;&quot;</span> + x.data + <span class="hljs-string">&quot;&lt;/xml&gt;&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;h := Html&#123;&#125;h.read()fmt.Println(h.format())<span class="hljs-comment">//结果是&lt;html&gt;&lt;/html&gt;，期望是&lt;html&gt;sown&lt;/html&gt;</span>x := xml&#123;&#125;x.read()fmt.Println(x.format())<span class="hljs-comment">//结果是&lt;xml&gt;sown&lt;/html&gt;</span>&#125;</code></pre></div><h2 id="声明为接口类型"><a href="#声明为接口类型" class="headerlink" title="声明为接口类型"></a>声明为接口类型</h2><p>接口中只能定义方法签名，不能包含成员变量。声明一个实例变量为接口类型，这个实例的方法外部将无法访问成员变量。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;read()format() <span class="hljs-keyword">string</span>&#125;<span class="hljs-keyword">type</span> xml <span class="hljs-keyword">struct</span> &#123;data <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;x.data = <span class="hljs-string">&quot;sown&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;xml&gt;&quot;</span> + x.data + <span class="hljs-string">&quot;&lt;/xml&gt;&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> x I <span class="hljs-comment">//这里声明接口类型</span>x = &amp;xml&#123;&#125;x.read()x.data = <span class="hljs-string">&quot;nwos&quot;</span> <span class="hljs-comment">//这里报错</span>fmt.Println(x.format())&#125;</code></pre></div><h2 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h2><p>先看如下代码：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> I <span class="hljs-keyword">interface</span> &#123;read()format() <span class="hljs-keyword">string</span>&#125;<span class="hljs-keyword">type</span> Html <span class="hljs-keyword">struct</span> &#123;Data <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h Html)</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;h.Data = <span class="hljs-string">&quot;sown&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h Html)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;html&gt;&quot;</span> + h.Data + <span class="hljs-string">&quot;&lt;/html&gt;&quot;</span>&#125;<span class="hljs-keyword">type</span> xml <span class="hljs-keyword">struct</span> &#123;data <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;x.data = <span class="hljs-string">&quot;sown&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x *xml)</span> <span class="hljs-title">format</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;xml&gt;&quot;</span> + x.data + <span class="hljs-string">&quot;&lt;/xml&gt;&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> h Ih = Html&#123;&#125;h.read()fmt.Println(h.format())<span class="hljs-keyword">var</span> x Ix = xml&#123;&#125; <span class="hljs-comment">// 这里报错</span>x.read()fmt.Println(x.format())&#125;</code></pre></div><p>输出如下：</p><div class="note note-danger">            <p>./main.go:41:4: cannot use xml literal (type xml) as type I in assignment:<br>xml does not implement I (format method has pointer receiver)</p>          </div><p>为什么会这样呢？ 首先说几个定义：</p><blockquote><p>Pointer Receiver：(t T)，例如 <code>func (x xml) read()</code><br>Value Receiver：(t *T)，例如 <code>func (x *xml) read()</code></p></blockquote><p>方法集 Method set：</p><table><thead><tr><th>Values</th><th>Methods Receivers</th></tr></thead><tbody><tr><td>T</td><td>(t T)</td></tr><tr><td>*T</td><td>(t T) and (t *T)</td></tr></tbody></table><table><thead><tr><th>Methods Receivers</th><th>Values</th></tr></thead><tbody><tr><td>(t T)</td><td>T and *T</td></tr><tr><td>(t *T)</td><td>*T</td></tr></tbody></table><p><strong>为什么T和*T具有不同的方法集？</strong></p><blockquote><p>如Go规范所述，类型的方法集T由具有接收器类型的所有方法组成T，而相应的指针类型*T的方法集由具有接收器*T或 的所有方法组成T。这意味着的方法集*T 包括的方法集T，但不包括相反的方法集。</p><p>之所以出现这种区别，是因为如果接口值包含指针*T，则方法调用可以通过取消引用指针来获取值，但是如果接口值包含value T，则方法调用就没有安全的方法来获取指针。（这样做将允许一种方法修改接口内部值的内容，这是语言规范所不允许的。）</p><p>即使在编译器可以将值的地址传递给方法的情况下，如果方法修改了该值，则更改也将在调用方中丢失。作为一个例子，如果该Write方法 bytes.Buffer 中使用的值接收器，而不是一个指针，这样的代码：</p><p>var buf bytes.Buffer<br>io.Copy(buf，os.Stdin)</p><p>会将标准输入复制到的副本中buf，而不是复制到buf自身中。这几乎从来不是期望的行为。</p></blockquote><p>来自<a href="https://golang.org/doc/faq#Functions_methods">https://golang.org/doc/faq#Functions_methods</a></p><blockquote><ol><li><p>如果您有a *T，则可以调用具有接收器类型的*T方法以及具有接收器类型的方法T（<a href="https://golang.org/ref/spec#Method_sets">Method Sets</a>）。</p></li><li><p>如果具有a T并且它是<a href="https://golang.org/ref/spec#Address_operators">可寻址</a>的，则可以调用具有接收器类型的*T方法以及具有接收器类型T的方法，因为该方法调用t.Meth()将等效于(&amp;t).Meth()（<a href="https://golang.org/ref/spec#Calls">Calls</a>）。</p></li><li><p>如果您有一个T且无法寻址，则只能调用接收者类型为T而不是的方法*T。</p></li><li><p>如果您有一个接口I，并且I方法集中的某些或全部方法由接收者为的方法提供*T（其余部分由接收者为的方法提供T），则*T满足该接口I，但T不满足。这是因为*T的方法集包括T，但不是（反过来说又回到了第一点）。</p></li></ol><p>简而言之，您可以将方法与值接收器混合使用，将方法与指针接收器混合使用，并将它们与包含值和指针的变量一起使用，而不必担心哪个是哪个。两者都可以使用，并且语法相同。但是，如果需要使用带有指针接收器的方法来满足一个接口，则只能将一个指针分配给该接口-值将无效。</p></blockquote><p>来自<a href="https://stackoverflow.com/questions/33587227/method-sets-pointer-vs-value-receiver">https://stackoverflow.com/questions/33587227/method-sets-pointer-vs-value-receiver</a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> People <span class="hljs-keyword">struct</span> &#123;    Name <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p People)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;print: %v&quot;</span>, p)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    p := &amp;People&#123;&#125;    p.String()&#125;</code></pre></div><h1 id="开源学习"><a href="#开源学习" class="headerlink" title="开源学习"></a>开源学习</h1><h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><h2 id="面向协议"><a href="#面向协议" class="headerlink" title="面向协议"></a>面向协议</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>组合代替继承<br>面向接口编程<br>倾向于使用小的接口定义，很多接口只包含一个方法<br>较大的接口定义，可以由多个小接口定义组合而成<br>只依赖于必要功能的最小接口</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>Tips</p><ol><li>为什么在 object_oriented_a_test.go 中， var c D = &amp;Demo{} 可以，而 var c D = Demo{} 不行？<br>value method 情况下没有任何的错误。<br>主要的情况是在 method 为 pointer 时：<br>如果 定义&amp;初始化 的时候，使用了 接口类型，那么等号右边必须是 &amp;<br>两种情况：<br>如果 接口定义 被 接口实现，实现的方法中是有 * 的，那么实例化时，必须使用 &amp; 或 new，否则将会报错。 如果 接口定义 未 接口实现，实现的方法中是无 * 的，那么实例化时，就无所谓，并不会报错。<br>解析：<br>value method 可以被 pointer和 value 对象调用，而 pointer method 只能被 pointer 对象调用。 原因是：pointer method 会修改对象的值，而 value method 不会，所以如果在一个 value 对象上调用 pointer method，编译器会对原来的值做一份拷贝(参考函数传参规范)，并在拷贝后的值上执行函数，那么如果函数有修改原 receiver 的值，则修改的行为都发生在拷贝的值上，而不会影响原值，这个错误很隐蔽不容易被调试发现，因此 Go 决定放弃这个错误发生的可能性，直接不支持 pointer method 被 value 对象调用。<br>示例代码</li><li>结构体嵌套（组合），为什么不能识别被嵌入结构体的属性？<br>如果定义为 *，那么初始化的时候必须为 &amp;<br>示例代码</li><li>NewDemoC 和 &amp;DemoC{} 区别？<br>如果结构体是空的，那么哪种实例化的指针值都是一样的，因为返回的都是零值。<br>如果不是空结构体，那么哪种实例化的指针都是不一样的。<br>示例代码</li><li>为什么结构体可以写 * ，而接口不能写 * ？<br>执行代码会出现”type *PaymentStrategy is pointer to interface, not interface)“错误，原因是因为”PaymentStrategy”是interface而不是struct，不能用指针方式传递。<br>示例代码</li></ol><p>MySQL连接池</p><p>databas/sql和go-sql-driver的源码，出现这个错误之后官方提供的方法是会进行两次的重连操作，如果两次重连都没有成功，就创建一个新的SQL链接，所以出现这个错误日志没什么影响，当然最好的做法是设置一下链接的空闲超时时间，设置的比Mysql服务器超时时间 SetConnMaxLifetime() 短就可以了，设置了这个之后就不会报这个错误了。当然不设也可以，设置了的话程序处理会更优雅一点！</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go内存泄漏、逃逸</title>
    <link href="/golang/memory-leak-escape/"/>
    <url>/golang/memory-leak-escape/</url>
    
    <content type="html"><![CDATA[<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p><a href="https://segmentfault.com/a/1190000019222661">实战Go内存泄露</a></p><h1 id="内存逃逸"><a href="#内存逃逸" class="headerlink" title="内存逃逸"></a>内存逃逸</h1><h2 id="关于-堆和栈"><a href="#关于-堆和栈" class="headerlink" title="关于 堆和栈"></a>关于 堆和栈</h2><p>栈 可以简单得理解成一次函数调用内部申请到的内存，它们会随着函数的返回把内存还给系统。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F</span><span class="hljs-params">()</span></span> &#123;temp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>)...&#125;</code></pre></div><p>类似于上面代码里面的temp变量，只是内函数内部申请的临时变量，并不会作为返回值返回，它就是被编译器申请到栈里面。</p><p>申请到 栈内存 好处：函数返回直接释放，不会引起垃圾回收，对性能没有影响。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F</span><span class="hljs-params">()</span> []<span class="hljs-title">int</span></span>&#123;a := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>)<span class="hljs-keyword">return</span> a&#125;</code></pre></div><p>而上面这段代码，申请的代码一模一样，但是申请后作为返回值返回了，编译器会认为变量之后还会被使用，当函数返回之后并不会将其内存归还，那么它就会被申请到 堆 上面了。</p><p>申请到堆上面的内存才会引起垃圾回收，如果这个过程（特指垃圾回收不断被触发）过于高频就会导致 gc 压力过大，程序性能出问题。</p><p>我们再看看如下几个例子：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>)     <span class="hljs-comment">// 栈 空间小</span>b := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20000</span>) <span class="hljs-comment">// 堆 空间过大</span> l := <span class="hljs-number">20</span>c := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, l) <span class="hljs-comment">// 堆 动态分配不定空间</span>&#125;</code></pre></div><p>像是 b 这种 即使是临时变量，申请过大也会在堆上面申请。<br>对于 c 编译器对于这种不定长度的申请方式，也会在堆上面申请，即使申请的长度很短。</p><h2 id="逃逸分析（Escape-analysis）"><a href="#逃逸分析（Escape-analysis）" class="headerlink" title="逃逸分析（Escape analysis）"></a>逃逸分析（Escape analysis）</h2><p>所谓逃逸分析（Escape analysis）是指由编译器决定内存分配的位置，不需要程序员指定。</p><p>在函数中申请一个新的对象：</p><ul><li>如果分配 在栈中，则函数执行结束可自动将内存回收；</li><li>如果分配在堆中，则函数执行结束可交给GC（垃圾回收）处理;<br>注意，对于函数外部没有引用的对象，也有可能放到堆中，比如内存过大超过栈的存储能力。</li></ul><h2 id="逃逸场景（什么情况才分配到堆中）"><a href="#逃逸场景（什么情况才分配到堆中）" class="headerlink" title="逃逸场景（什么情况才分配到堆中）"></a>逃逸场景（什么情况才分配到堆中）</h2><h3 id="指针逃逸"><a href="#指针逃逸" class="headerlink" title="指针逃逸"></a>指针逃逸</h3><p>Go可以返回局部变量指针，这其实是一个典型的变量逃逸案例，示例代码如下：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;    Name <span class="hljs-keyword">string</span>    Age  <span class="hljs-keyword">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StudentRegister</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, age <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">Student</span></span> &#123;    s := <span class="hljs-built_in">new</span>(Student) <span class="hljs-comment">//局部变量s逃逸到堆</span>    s.Name = name    s.Age = age    <span class="hljs-keyword">return</span> s&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    StudentRegister(<span class="hljs-string">&quot;Jim&quot;</span>, <span class="hljs-number">18</span>)&#125;</code></pre></div><p>虽然 在函数 StudentRegister() 内部 s 为局部变量，其值通过函数返回值返回，s 本身为一指针，其指向的内存地址不会是栈而是堆，这就是典型的逃逸案例。</p><p>终端运行命令查看逃逸分析日志：<br><code>go build -gcflags=-m</code><br>可见在StudentRegister()函数中，也即代码第9行显示”escapes to heap”，代表该行内存分配发生了逃逸现象。</p><h3 id="栈空间不足逃逸（空间开辟过大）"><a href="#栈空间不足逃逸（空间开辟过大）" class="headerlink" title="栈空间不足逃逸（空间开辟过大）"></a>栈空间不足逃逸（空间开辟过大）</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Slice</span><span class="hljs-params">()</span></span> &#123;    s := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>)    <span class="hljs-keyword">for</span> index, _ := <span class="hljs-keyword">range</span> s &#123;        s[index] = index    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    Slice()&#125;</code></pre></div><p>上面代码Slice()函数中分配了一个1000个长度的切片，是否逃逸取决于栈空间是否足够大。 直接查看编译提示，如下：</p><p>所以只是1000的长度还不足以发生逃逸现象。然后就x10倍吧</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Slice</span><span class="hljs-params">()</span></span> &#123;    s := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>)    <span class="hljs-keyword">for</span> index, _ := <span class="hljs-keyword">range</span> s &#123;        s[index] = index    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    Slice()&#125;</code></pre></div><p>分析如下：<br>当切片长度扩大到10000时就会逃逸。<br>实际上当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中。</p><h3 id="动态类型逃逸（不确定长度大小）"><a href="#动态类型逃逸（不确定长度大小）" class="headerlink" title="动态类型逃逸（不确定长度大小）"></a>动态类型逃逸（不确定长度大小）</h3><p>很多函数参数为interface类型，比如fmt.Println(a …interface{})，编译期间很难确定其参数的具体类型，也能产生逃逸。</p><p>如下代码所示：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    s := <span class="hljs-string">&quot;Escape&quot;</span>    fmt.Println(s)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs shell">D:\SourceCode\GoExpert\src&gt;go build -gcflags=-m<span class="hljs-meta">#</span><span class="bash"> _/D_/SourceCode/GoExpert/src</span>.\main.go:7: s escapes to heap.\main.go:7: main ... argument does not escape</code></pre></div><p>又或者像前面提到的例子：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>)     <span class="hljs-comment">// 栈 空间小</span>b := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20000</span>) <span class="hljs-comment">// 堆 空间过大 逃逸</span> l := <span class="hljs-number">20</span>c := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, l) <span class="hljs-comment">// 堆 动态分配不定空间 逃逸</span>&#125;</code></pre></div><h3 id="闭包引用对象逃逸"><a href="#闭包引用对象逃逸" class="headerlink" title="闭包引用对象逃逸"></a>闭包引用对象逃逸</h3><p>Fibonacci数列的函数：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;    a, b := <span class="hljs-number">0</span>, <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;        a, b = b, a+b        <span class="hljs-keyword">return</span> a    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    f := Fibonacci()    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;        fmt.Printf(<span class="hljs-string">&quot;Fibonacci: %d\n&quot;</span>, f())    &#125;&#125;</code></pre></div><p>输出如下：</p><div class="code-wrapper"><pre><code class="hljs shell">~/go/src/gitHub/test/pool  go run main.goFibonacci: 1Fibonacci: 1Fibonacci: 2Fibonacci: 3Fibonacci: 5Fibonacci: 8Fibonacci: 13Fibonacci: 21Fibonacci: 34Fibonacci: 55</code></pre></div><p>逃逸如下：</p><div class="code-wrapper"><pre><code class="hljs shell"> ~/go/src/gitHub/test/pool  go build -gcflags=-m<span class="hljs-meta">#</span><span class="bash"> gitHub/<span class="hljs-built_in">test</span>/pool</span>./main.go:7:9: can inline Fibonacci.func1./main.go:7:9: func literal escapes to heap./main.go:7:9: func literal escapes to heap./main.go:8:10: &amp;b escapes to heap./main.go:6:5: moved to heap: b./main.go:8:13: &amp;a escapes to heap./main.go:6:2: moved to heap: a./main.go:17:34: f() escapes to heap./main.go:17:13: main ... argument does not escape</code></pre></div><p>Fibonacci()函数中原本属于局部变量的a和b由于闭包的引用，不得不将二者放到堆上，以致产生逃逸。</p><h2 id="逃逸分析的作用是什么呢？"><a href="#逃逸分析的作用是什么呢？" class="headerlink" title="逃逸分析的作用是什么呢？"></a>逃逸分析的作用是什么呢？</h2><ul><li>逃逸分析的好处是为了减少gc的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要gc标记清除。</li><li>逃逸分析完后可以确定哪些变量可以分配在栈上，栈的分配比堆快，性能好(逃逸的局部变量会在堆上分配 ,而没有发生逃逸的则有编译器在栈上分配)。</li><li>同步消除，如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。</li></ul><h2 id="逃逸总结："><a href="#逃逸总结：" class="headerlink" title="逃逸总结："></a>逃逸总结：</h2><ul><li>栈上分配内存比在堆中分配内存有更高的效率</li><li>栈上分配的内存不需要GC处理</li><li>堆上分配的内存使用完毕会交给GC处理</li><li>逃逸分析目的是决定内分配地址是栈还是堆</li><li>逃逸分析在编译阶段完成</li></ul><h2 id="提问：函数传递指针真的比传值效率高吗？"><a href="#提问：函数传递指针真的比传值效率高吗？" class="headerlink" title="提问：函数传递指针真的比传值效率高吗？"></a>提问：函数传递指针真的比传值效率高吗？</h2><p>我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的。<br>在官网 (golang.org) FAQ 上有一个关于变量分配的问题如下：<br>From a correctness standpoint, you don’t need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.</p><p>The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function’s stack frame.</p><p>However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.</p><p>In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.</p><p>翻译如下：</p><p>如何得知变量是分配在栈（stack）上还是堆（heap）上？</p><p>准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。</p><p>知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。 然而，如果编译器不能确保变量在函数 return之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。</p><p>当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上。然而，还要对这些变量做逃逸分析，如果函数return之后，变量不再被引用，则将其分配到栈上。</p><h1 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h1><h1 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h1>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go内存泄漏、逃逸</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go内存GC</title>
    <link href="/golang/memory-gc/"/>
    <url>/golang/memory-gc/</url>
    
    <content type="html"><![CDATA[<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>Golang 一直都在高速发展，每次版本迭代，内存管理相关方面都会有所变化。</p><h2 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h2><h3 id="1-手动管理"><a href="#1-手动管理" class="headerlink" title="1. 手动管理"></a>1. 手动管理</h3><p>代表语言有 C、C++，需要调用 alloc, realloc, calloc, free 等函数</p><h3 id="2-垃圾回收（GC）"><a href="#2-垃圾回收（GC）" class="headerlink" title="2. 垃圾回收（GC）"></a>2. 垃圾回收（GC）</h3><p>在计算机科学中，垃圾回收（英语：Garbage Collection，缩写为GC）是指一种自动的存储器管理机制。当某个程序占用的一部分内存空间不再被这个程序访问时，这个程序会借助垃圾回收算法向操作系统归还这部分内存空间。垃圾回收器可以减轻程序员的负担，也减少程序中的错误。垃圾回收最早起源于LISP语言。</p><h4 id="2-1-标记和扫描GC-Mark-sweep"><a href="#2-1-标记和扫描GC-Mark-sweep" class="headerlink" title="2.1 标记和扫描GC(Mark-sweep)"></a>2.1 标记和扫描GC(Mark-sweep)</h4><p>代表语言有 Golang<br>标记和扫描GC，也称为跟踪GC。<br>它通常是一个两阶段的算法，首先将仍然被引用的对象标记为“活的”，然后在下一阶段释放不活的对象的内存。从根变量开始遍历所有引用的对象，标记引用的对象，没有被标记的进行回收</p><ul><li>优点：解决了引用计数的缺点。</li><li>缺点：需要 STW，暂时停掉程序运行。</li></ul><h4 id="2-2-引用计数GC"><a href="#2-2-引用计数GC" class="headerlink" title="2.2 引用计数GC"></a>2.2 引用计数GC</h4><p>代表语言有 PHP, Perl, and Python<br>在这种方法中，每个对象获得一个引用计数，该引用计数随着对它的引用的改变而增加或减少，当计数变为零时，垃圾收集就完成了，缺点是不能处理循环引用。</p><ul><li>优点：对象回收快，不会出现内存耗尽或达到某个阈值时才回收。</li><li>缺点：不能很好的处理循环引用，而实时维护引用计数也是有损耗的。</li></ul><h4 id="2-3-标记-压缩-Mark-compact"><a href="#2-3-标记-压缩-Mark-compact" class="headerlink" title="2.3 标记-压缩(Mark-compact)"></a>2.3 标记-压缩(Mark-compact)</h4><h4 id="2-4-半空间复制（Semispace-copy）"><a href="#2-4-半空间复制（Semispace-copy）" class="headerlink" title="2.4 半空间复制（Semispace copy）"></a>2.4 半空间复制（Semispace copy）</h4><h4 id="2-5-分代GC"><a href="#2-5-分代GC" class="headerlink" title="2.5 分代GC"></a>2.5 分代GC</h4><p>代表语言 Java，按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。</p><ul><li>优点：回收性能好</li><li>缺点：算法复杂</li></ul><h2 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h2><p>STW 阶段指的是程序暂停所有运行中的协程，否则不会开始垃圾回收阶段。<br>最开始的时候，在垃圾回收阶段只有一个协程执行垃圾回收。<br>目前 并发GC，垃圾回收阶段用户协程与垃圾回收协程并发执行。STW时间，小于100微妙。</p><p>尽管 STW 如今已经优化到了半毫秒级别以下，但这个程序被卡死原因是由于需要进入 STW 导致的。原因在于，GC 在需要进入 STW 时，需要通知并让所有的用户态代码停止，但是 for {} 所在的 goroutine 永远都不会被中断，从而始终无法进入 STW 阶段。实际实践中也是如此，当程序的某个 goroutine 长时间得不到停止，强行拖慢进入 STW 的时机，这种情况下造成的影响（卡死）是非常可怕的。好在自 Go 1.14 之后，这类 goroutine 能够被异步地抢占，从而使得进入 STW 的时间不会超过抢占信号触发的周期，程序也不会因为仅仅等待一个 goroutine 的停止而停顿在进入 STW 之前的操作上。</p><p>stop the world, GC 的一些阶段需要停止所有的 mutator 以确定当前的引用关系。这便是很多人对 GC 担心的来源，这也是 GC 算法优化的重点。</p><p>在垃圾回收机制 (GC) 中，”Stop the World” (STW) 是一个重要阶段。顾名思义， 在 “Stop the World” 阶段， 当前运行的所有程序将被暂停， 扫描内存的 root 节点和添加写屏障 (write barrier) 。</p><p>处理器 P (无论是正在运行代码的处理器还是已在 idle 列表中的处理器)， 都会被被标记成停止状态 (stopped)， 不再运行任何代码。 调度器把每个处理器的 M  从各自对应的处理器 P 分离出来， 放到 idle 列表中去。<br>对于 Goroutine 本身， 他们会被放到一个全局队列中等待</p><h2 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h2><ol><li>灰色：对象还在标记队列中等待</li><li>黑色：对象已被标记，gcmarkBits 对应位为 1 – 该对象不会在本次 GC 中被回收</li><li>白色：对象未被标记，gcmarkBits 对应位为 0 – 该对象将会在本次 GC 中被清理</li></ol><p><img src="/images/golang/memory-manage-gc-01.png" alt="三色标记法"></p><p>通过上图，应该对三色标记法有了一个比较直观的了解，那么我们现在来讲讲原理。简单的讲，就是标记内存中那些还在使用中（即被引用了）的部分，而内存中不再使用（即未被引用）的部分，就是要回收的垃圾，需要将其回收，以供后续内存分配使用。上图中的 A、B、D 就是被引用正在使用的内存，而C、F、E 曾经被使用过，但现在没有任何对象引用，就需要被回收掉。</p><p>而 Root 区域主要是程序运行到当前时刻的栈和全局数据区域，是实时正在使用到的内存，当然应该优先标记。而考虑到内存块中存放的可能是指针，所以还需要递归的进行标记，待全部标记完后，就会对未被标记的内存进行回收。</p><h2 id="内存标记"><a href="#内存标记" class="headerlink" title="内存标记"></a>内存标记</h2><p>golang 中采用 span 数据结构管理内存，span 中维护了一个个内存块，并由一个位图 allocBits 表示内存块的分配情况，而上文中提到的 gcmarkBits 是记录每块内存块被引用情况的。</p><p><img src="/images/golang/memory-manage-gc-02.png" alt="内存标记"></p><p>如上图，allocBits 记录了每块内存的分配情况，而 gcmarkBits 记录了每块内存的标记情况。在标记阶段会对每块内存进行标记，有对象引用的内存标记为 1，没有对象引用的为 0。而 allocBits 和 gcmarkBits 的数据结构是完全一样的，在结束标记后，将 allocBits 指向 gcmarkBits，则有标记的才是存活的，这样就完成了内存回收。而 gcmarkBits 则会在下次标记时重新分配内存。</p><h1 id="Mark-amp-Sweep"><a href="#Mark-amp-Sweep" class="headerlink" title="Mark &amp; Sweep"></a>Mark &amp; Sweep</h1><ol><li>Stop the World</li><li>Mark：通过 Root 和 Root 直接间接访问到的对象， 来寻找所有可达的对象，并进行标记。</li><li>Sweep：对堆对象迭代，已标记的对象置位标记。所有未标记的对象加入freelist， 可用于再分配。</li><li>Start the World</li></ol><p>这个算法最大的问题是 GC 执行期间需要把整个程序完全暂停，朴素的 Mark Sweep 是整体 STW，并且分配速度慢，内存碎片率高。</p><h2 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h2><p>并发回收的屏障技术归根结底就是在利用内存写屏障来保证强三色不变性和弱三色不变性。早期的 Go 团队实践中选择了从提出较早的 Dijkstra 插入屏障出发， 不可避免的在为了保证强三色不变性的情况下，需要对栈进行重扫。 而在后期的实践中，Go 团队提出了将 Dijkstra 和 Yuasa 屏障结合的混合屏障， 将强三色不变性进行了弱化，从而消除了对栈的重新扫描这一硬性要求，使得在未来实现全面并发 GC 成为可能。</p><h2 id="垃圾回收优化"><a href="#垃圾回收优化" class="headerlink" title="垃圾回收优化"></a>垃圾回收优化</h2><p>在前文中提到，golang 的垃圾回收算法属于 标记-清除，是需要 STW 的。STW 就是 Stop The World 的意思，在 golang 中就是要停掉所有的 goroutine，专心进行垃圾回收，待垃圾回收结束后再恢复 goroutine。而 STW 时间的长短直接影响了应用的执行，如果时间过长，那将是灾难性的。为了缩短 STW 时间，golang 不对优化垃圾回收算法，其中写屏障（Write Barrier）和辅助GC（Mutator Assist）就是两种优化垃圾回收的方法。</p><ul><li>写屏障（Write Barrier）：上面说到的 STW 的目的是防止 GC 扫描时内存变化引起的混乱，而写屏障就是让 goroutine 与 GC 同时运行的手段，虽然不能完全消除 STW，但是可以大大减少 STW 的时间。写屏障在 GC 的特定时间开启，开启后指针传递时会把指针标记，即本轮不回收，下次 GC 时再确定。</li><li>辅助 GC（Mutator Assist）：为了防止内存分配过快，在 GC 执行过程中，GC 过程中 mutator 线程会并发运行，而 mutator assist 机制会协助 GC 做一部分的工作。</li></ul><h2 id="垃圾回收触发机制"><a href="#垃圾回收触发机制" class="headerlink" title="垃圾回收触发机制"></a>垃圾回收触发机制</h2><ol><li>内存分配量达到阈值：每次内存分配都会检查当前内存分配量是否达到阈值，如果达到阈值则触发 GC。阈值 = 上次 GC 内存分配量 * 内存增长率，内存增长率由环境变量 GOGC 控制，默认为 100，即每当内存扩大一倍时启动 GC。</li><li>定时触发 GC：默认情况下，2分钟触发一次 GC，该间隔由 src/runtime/proc.go 中的 forcegcperiod 声明。</li><li>手动触发 GC：在代码中，可通过使用 runtime.GC() 手动触发 GC。</li></ol><h2 id="GC-优化建议"><a href="#GC-优化建议" class="headerlink" title="GC 优化建议"></a>GC 优化建议</h2><p>由上文可知，GC 性能是与对象数量有关的，对象越多 GC 性能越差，对程序的影响也越大。所以在开发中要尽量减少对象分配个数，采用对象复用、将小对象组合成大对象或采用小数据类型（如使用 int8 代替 int）等。</p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>一门编程语言的垃圾回收机制会直接影响使用其开发应用的性能。在日常开发工作中也因注意到其作用，有助于开发出高性能的应用，这也是 GC 常常在面试中被问到的原因。同时，了解 GC 对了解内存管理也很有帮助。</p><h1 id="参考借鉴"><a href="#参考借鉴" class="headerlink" title="参考借鉴"></a>参考借鉴</h1><p><a href="https://developer.aliyun.com/article/775798">浅析 Golang 垃圾回收机制</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>垃圾回收</tag>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GoMPG与调度</title>
    <link href="/golang/scheduling/"/>
    <url>/golang/scheduling/</url>
    
    <content type="html"><![CDATA[<h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><h2 id="宏观关系"><a href="#宏观关系" class="headerlink" title="宏观关系"></a>宏观关系</h2><p><img src="/images/golang/scheduling-mpg-01.png" alt="MPG关系图"><br><img src="/images/golang/scheduling-mpg-02.png" alt="MPG关系图"><br><img src="/images/golang/scheduling-mpg-03.png" alt="MPG关系图"></p><h2 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h2><table><thead><tr><th>名称</th><th>源码</th><th>说明</th><th>作用</th></tr></thead><tbody><tr><td>全局M列表</td><td>runtime.allm</td><td>所有M的单链表</td><td>创建之后先进全局，随即进行初始化</td></tr><tr><td>全局P列表</td><td>runtime.allp</td><td>所有P的数组</td><td>创建之后先进全局，随即进行初始化</td></tr><tr><td>全局G列表</td><td>runtime.allgs</td><td>所有P的切片</td><td>创建之后先进全局，随即进行初始化</td></tr><tr><td>调度器的空闲M列表</td><td>runtime.sched.midle</td><td>空闲M的单链表</td><td>暂时不用；用时再取</td></tr><tr><td>调度器的空闲P列表</td><td>runtime.sched.midle</td><td>空闲P的单链表</td><td>P不在关联M，P中可运行G为空，加入该列表；M需要P关联，从此列表取；</td></tr><tr><td>调度器的可运行G队列</td><td>runtime.sched.runq.head；runtime.sched.runq.tail</td><td>可运行的G队列</td><td>如果P的可运行G队列满，加入此队列</td></tr><tr><td>调度器的自由G列表</td><td>runtime.sched.gFree.stack(有栈)；runtime.sched.gFree.noStack (无栈)</td><td>自由的G的两个单链表</td><td>本地P自由G列表缺G，此列表给补；本地P自由G列表满G，此列表收取；</td></tr><tr><td>P的可运行G队列</td><td>runtime.p.runq；runtime.p.runqhead；runtime.p.runqtail</td><td>P中的可运行G的队列</td><td>调度器初始化过的G，加入该队列</td></tr><tr><td>P的自由G列表</td><td>runtime.p.gfree</td><td>P中的自由G的单链表</td><td>包含一些已经运行完成的G；go启用G，先从此处寻找现成的G；</td></tr></tbody></table><h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><h3 id="结构体成员"><a href="#结构体成员" class="headerlink" title="结构体成员"></a>结构体成员</h3><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>g0</td><td>*g</td><td>特殊的 goroutine，在 runtime 启动之初创建的，用于执行一些运行时任务</td></tr><tr><td>mstartfn</td><td>func()</td><td>在新的 M 上启动特殊任务（系统监控、GC辅助、M自旋）</td></tr><tr><td>curg</td><td>*g</td><td>当前 M 正在运行的 G 的指针</td></tr><tr><td>p</td><td>puintptr</td><td>当前 M 正在关联的那个 P</td></tr><tr><td>nextp</td><td>puintptr</td><td>暂存与当前 M 有潜在关联的 P（预连）</td></tr><tr><td>spinning</td><td>bool</td><td>是否在寻找可运行的 G，寻找过程中 M 自旋</td></tr><tr><td>lockedg</td><td>*g</td><td>当前 M 锁定的 G</td></tr></tbody></table><h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>Pidle</td><td>当前 P 未与任何 M 关联</td></tr><tr><td>Prunning</td><td>当前 P 正在于 M 关联</td></tr><tr><td>Psyscall</td><td>当前 P 中的运行的那个 G 正在进行系统调用</td></tr><tr><td>Pgcstop</td><td>运行时系统需要停止调度。例如，运行时系统正在垃圾回收的某些步骤前，就会试图把runtime.allp（全局 P 列表）都置于此状态</td></tr><tr><td>Pdead</td><td>当前 P 已经不会再被使用。例如，运行过程中，通过 runtime.GOMAXPROCS 函数减少了 p 的最大数量</td></tr></tbody></table><p><img src="/images/golang/scheduling-p-status-01.png" alt="P状态流转"></p><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><h3 id="状态-1"><a href="#状态-1" class="headerlink" title="状态"></a>状态</h3><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>Gidle</td><td>刚被新分配，但还未初始化</td></tr><tr><td>Grunnable</td><td>可运行队列中等待运行</td></tr><tr><td>Grunning</td><td>运行</td></tr><tr><td>Gsyscall</td><td>执行某个系统调用</td></tr><tr><td>Gwaiting</td><td>阻塞</td></tr><tr><td>Gdead</td><td>闲置</td></tr><tr><td>Gcopystack</td><td>栈被移动，移动的原因可能是栈的扩展或收缩</td></tr><tr><td>Gscan</td><td>组合状态，发生在 GC 扫描</td></tr></tbody></table><p><img src="/images/golang/scheduling-g-status-01.png" alt="G状态流转"></p><h2 id="MPG调度"><a href="#MPG调度" class="headerlink" title="MPG调度"></a>MPG调度</h2><p><img src="/images/golang/scheduling-mpg-04.png" alt="MPG调度"></p><ol><li>我们通过 go func () 来创建一个 goroutine</li><li>有两个存储 G 的队列，一个是局部调度器 P 的本地队列、一个是全局 G 队列。新创建的 G 会先保存在 P 的本地队列中，如果 P 的本地队列已经满了就会保存在全局的队列中</li><li>G 只能运行在 M 中，一个 M 必须持有一个 P，M 与 P 是 1：1 的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会想其他的 MP 组合偷取一个可执行的 G 来执行</li><li>一个 M 调度 G 执行的过程是一个循环机制</li><li>当 M 执行某一个 G 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除 (detach)，然后再创建一个新的操作系统的线程 (如果有空闲的线程可用就复用空闲线程) 来服务于这个 P</li><li>当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中</li></ol><h2 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h2><h3 id="work-stealing"><a href="#work-stealing" class="headerlink" title="work stealing"></a>work stealing</h3><p>当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。</p><h3 id="syscall"><a href="#syscall" class="headerlink" title="syscall"></a>syscall</h3><p>当G被阻塞在某个系统调用上时，此时G会阻塞在_Gsyscall状态，M也处于block on syscall状态，此时的M可被抢占调度：执行该G的M会与P解绑，而P则尝试与其它idle的M绑定，继续执行其它G。如果没有其它idle的M，但P的Local队列中仍然有G需要执行，则创建一个新的M；当系统调用完成后，G会重新尝试获取一个idle的P进入它的Local队列恢复执行，如果没有idle的P，G会被标记为runnable加入到Global队列。</p><h3 id="handoff"><a href="#handoff" class="headerlink" title="handoff"></a>handoff</h3><ol><li><p>利用并行<br>GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行</p></li><li><p>抢占<br>在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程，在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方<br>异步抢占，注册 sigurg 信号，通过sysmon 检测，对 M 对应的线程发送信号，触发注册的 handler，它往当前 G 的 PC 中插入一条指令(调用某个方法)，在处理完 handler，G 恢复后，自己把自己推到了 global queue 中。</p></li><li><p>全局 G 队列<br>在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G</p></li></ol><h3 id="gopark"><a href="#gopark" class="headerlink" title="gopark"></a>gopark</h3><p>系统调用；<br>channel读写条件不满足；<br>抢占式调度时间片结束；</p><p>解除当前goroutine的m的绑定关系，将当前goroutine状态机切换为等待状态；<br>调用一次schedule()函数，在局部调度器P发起一轮新的调度。</p><h3 id="sysmon"><a href="#sysmon" class="headerlink" title="sysmon"></a>sysmon</h3><p>P的数量影响了同时运行go代码的协程数. 如果P被占用很久, 就会影响调度. sysmon协程的一个功能就是进行抢占.<br>sysmon协程是在go runtime初始化之后, 执行用户编写的代码之前, 由runtime启动的不与任何P绑定, 直接由一个M执行的协程. 类似于 linux中的执行一些系统任务的内核线程.<br>可认为是10ms执行一次. (初始运行间隔为20us(微秒), sysmon运行1ms后逐渐翻倍, 最终每10ms运行一次. 如果有发生过抢占成功, 则又恢复成 初始20us的运行间隔, 如此循环)</p><p>sysmon 也叫监控线程，它无需 P 也可以运行，他是一个死循环，每20us~10ms循环一次，循环完一次就 sleep 一会，为什么会是一个变动的周期呢，主要是避免空转，如果每次循环都没什么需要做的事，那么 sleep 的时间就会加大。<br>释放闲置超过5分钟的 span 物理内存；<br>如果超过2分钟没有垃圾回收，强制执行；<br>将长时间未处理的 netpoll 添加到全局队列；<br>向长时间运行的 G 任务发出抢占调度；<br>收回因 syscall 长时间阻塞的 P；</p><h3 id="mcall"><a href="#mcall" class="headerlink" title="mcall"></a>mcall</h3><p>mcall在golang需要进行协程切换时被调用，用来保存被切换出去协程的信息，并在当前线程的g0协程堆栈上执行新的函数。一般情况下，会在新函数中执行一次schedule()来挑选新的协程来运行。接下来我们就看看mcall的实现。</p><h3 id="M-的状态"><a href="#M-的状态" class="headerlink" title="M 的状态"></a>M 的状态</h3><p>当M2线程在syscall返回后变得空闲时。如何处理这个空闲的M2线程。从理论上讲，如果线程完成了所需的操作，则应将其销毁，然后再安排进程中的其他线程到CPU上执行。这就是我们通常所说的操作系统中线程的“抢占式调度”。</p><p>考虑上述syscall中的情况。如果我们销毁了M2线程，而同时M3线程即将进入syscall。此时，在OS创建新的内核线程并将其调度执行之前，我们无法处理可运行的goroutine。频繁的线程前抢占操作不仅会增加OS的负载，而且对于性能要求更高的程序几乎是不可接受的。</p><p>因此，为了适当地利用操作系统的资源并防止频繁的线程抢占给操作系统带来的负担，我们不会销毁内核线程M2，而是使其执行自旋操作并以备将来使用。尽管这看起来是在浪费一些资源。但是，与线程之间的频繁抢占以及频繁的创建和销毁操作相比，“空闲线程”要付出的代价更少。</p><p>Spinning Thread(自旋线程) — 例如，在具有一个内核线程M（1）和一个逻辑处理器（P）的Go程序中，如果正在执行的M被syscall阻塞，则运行时会请求与P数量相同的“Spinning Threads”以允许等待的可运行goroutine继续执行。因此，在此期间，内核线程的数量M将大于P的数量（自旋线程+阻塞线程）。因此，即使将runtime.GOMAXPROCS的值设置为1，程序也将处于多线程状态。</p><p>m 取到 g 了，判断如果 m 是自旋状态，则从自旋到非自旋，在没有自旋状态的 m 的情况下，再多创建一个新的自旋状态的 m</p><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>在channel上发送和接收<br>每个channel都有一个recvq(waitq)，用于存储试图从该channel读取数据而阻塞的goroutine。Sendq(waitq)存储试图将数据发送到channel而被阻止的goroutine。</p><p>网络I/O操作<br>底层使用epoll，不会阻塞</p><p>阻塞的系统调用<br>当G被阻塞在某个系统调用上时，此时G会阻塞在_Gsyscall状态，M也处于block on syscall状态，此时的M可被抢占调度：执行该G的M会与P解绑，而P则尝试与其它idle的M绑定，继续执行其它G。如果没有其它idle的M，但P的Local队列中仍然有G需要执行，则创建一个新的M；当系统调用完成后，G会重新尝试获取一个idle的P进入它的Local队列恢复执行，如果没有idle的P，G会被标记为runnable加入到Global队列。</p><p>使用定时器<br>抢占式调度来解决这个问题。只要你这个任务执行超过一定的时间（10ms），那么这个任务就会被标识为可抢占的，那么别的goroutine就可以抢先进来执行。只要下次这个goroutine进行函数调用，那么就会被强占，同时也会保护现场，然后重新放入P的本地队列里面等待下次执行。（sysmon完成监控）<br>通过向线程发送系统信号的方式来中断 M 的执行，进而达到抢占的目的。</p><p>使用互斥锁<br>当互斥锁不断地试图获得一个永远无法获得的锁时，它可能会遇到饥饿问题。<br>在版本1.9中，Go通过添加一个新的饥饿模式来解决先前的问题，所有等待锁定超过一毫秒的 goroutine，也称为有界等待，将被标记为饥饿。当标记为饥饿时，解锁方法现在将把锁直接移交给第一位等待着。</p><h3 id="如何停止长时间占用资源的g，信号协作"><a href="#如何停止长时间占用资源的g，信号协作" class="headerlink" title="如何停止长时间占用资源的g，信号协作"></a>如何停止长时间占用资源的g，信号协作</h3><p>发送系统信号，中断<br>异步抢占，注册 sigurg 信号，通过sysmon 检测，对 M 对应的线程发送信号，触发注册的 handler，它往当前 G 的 PC 中插入一条指令(调用某个方法)，在处理完 handler，G 恢复后，自己把自己推到了 global queue 中。</p><h3 id="g0"><a href="#g0" class="headerlink" title="g0"></a>g0</h3><ul><li>Go 基于两种断点将 G 调度到线程上：<br>当 G 阻塞时：系统调用、互斥锁或 chan。阻塞的 G 进入睡眠模式/进入队列，并允许Go 安排和运行等待其他的 G。<br>在函数调用期间，如果 G 必须扩展其堆栈。这个断点允许 Go 调度另一个 G 并避免运行 G 占用CPU。<br>在这两种情况下，运行调度程序的 g0 将当前G 替换为另一个 G，即 ready to run。然后，选择的 G 替换 g0 并在线程上运行。与常规 G 相反，g0 有一个固定和更大的栈。</li><li>Defer 函数的分配</li><li>GC 收集，比如 STW、扫描 G 的堆栈和标记、清楚操作</li><li>栈扩容，当需要的时候，由 g0 进行扩栈操作</li></ul><p><a href="https://xie.infoq.cn/article/3e533bf31a08f8dd2f62f6011">https://xie.infoq.cn/article/3e533bf31a08f8dd2f62f6011</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSP</tag>
      
      <tag>MPG</tag>
      
      <tag>调度</tag>
      
      <tag>线程</tag>
      
      <tag>goroutine</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go内存管理、分配</title>
    <link href="/golang/memory-alloc/"/>
    <url>/golang/memory-alloc/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是以 go 1.15 为基础编写，而就在我写这篇文章的时候，go master 分支已经发生了与 1.15 不同的变化，可能在 1.16 及以后的源码会与文章内容有些出入，但总体差异应该不会太大，比如申请内存的流程、内存的模型设计，所以这篇文章应该不会很快过时。</p><h1 id="系统内存"><a href="#系统内存" class="headerlink" title="系统内存"></a>系统内存</h1><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p><img src="/images/golang/memory-manage-vm-01.png" alt="虚拟内存"><br>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。<br>目前，大多数操作系统都使用了虚拟内存，如Windows家族的“虚拟内存”；Linux的“交换空间”等。</p><ul><li>访问内存，实际访问的是虚拟内存</li><li>虚拟内存通过页表查看，当前要访问的虚拟内存地址，是否已经加载到了物理内存，如果已经在物理内存，则取物理内存数据，如果没有对应的物理内存，则从磁盘加载数据到物理内存，并把物理内存地址和虚拟内存地址更新到页表。</li><li>每个进程都要各自的虚拟内存，内存的并发访问问题的粒度从多进程级别，可以降低到多线程级别。</li></ul><h2 id="堆、栈"><a href="#堆、栈" class="headerlink" title="堆、栈"></a>堆、栈</h2><p><img src="/images/golang/memory-manage-vm-02.png" alt="堆、栈"></p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li>栈在高地址，从高地址向低地址增长；堆在低地址，从低地址向高地址增长。</li><li>栈的内存不需要回收；堆需要回收，无论是主动free、垃圾回收。</li><li>栈上的内存有更好的局部性；堆上内存访访问2块数据可能在不同的页上。</li><li>栈是操作系统管理的；堆是用户管理的</li><li>栈是静态内存分配；堆是动态内存分配</li></ul><h3 id="栈还有以下特点"><a href="#栈还有以下特点" class="headerlink" title="栈还有以下特点"></a>栈还有以下特点</h3><ul><li>LIFO，每当一个函数声明一个新变量时，它就被“推”到堆栈的最顶层块上。然后，每当一个函数退出时，最上面的块就会被清除</li><li>每个线程一个 stack</li></ul><h1 id="TCMalloc"><a href="#TCMalloc" class="headerlink" title="TCMalloc"></a>TCMalloc</h1><p><img src="/images/golang/memory-manage-tcmalloc-01.png" alt="TCMalloc"></p><p>内存分配策略的实现，我们也可以叫它内存分配器，相当于在用户编写的程序与虚拟内存中间建立了”内存池”，而避免手写内存池。</p><p>下面是比较成熟的内存池实现库</p><ul><li>glibc 的 ptmalloc2</li><li>google 的 tcmalloc</li><li>facebook 的 jemalloc</li></ul><p>Golang 正是使用了 <a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">TCMalloc</a> 的设计思想。</p><h2 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h2><p>操作系统对内存管理以页为单位，TCMalloc 也是这样，只不过 TCMalloc 里的 Page 大小与操作系统里的大小并不一定相等，而是倍数关系，x64 下 Page 大小是 8KB。</p><h2 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h2><p>一组连续的 Page 被称为 Span，比如可以有 2 个页大小的 Span，也可以有 16 页大小的 Span，Span 比 Page 高一个层级，是为了方便管理一定大小的内存区域，Span 是 TCMalloc 中内存管理的基本单位。</p><h2 id="ThreadCache"><a href="#ThreadCache" class="headerlink" title="ThreadCache"></a>ThreadCache</h2><p>每个线程各自的 Cache，一个Cache包含多个空闲内存块链表，每个链表连接的都是内存块，同一个链表上内存块的大小是相同的，也可以说按内存块大小，给内存块分了个类，这样可以根据申请的内存大小，快速从合适的链表选择空闲内存块。由于每个线程有自己的 ThreadCache，所以 ThreadCache 访问是无锁的。</p><h2 id="CentralCache"><a href="#CentralCache" class="headerlink" title="CentralCache"></a>CentralCache</h2><p>是所有线程共享的缓存，也是保存的空闲内存块链表，链表的数量与 ThreadCache 中链表数量相同，当 ThreadCache 内存块不足时，可以从 CentralCache 取，当 ThreadCache 内存块多时，可以放回 CentralCache。由于 CentralCache 是共享的，所以它的访问是要加锁的。</p><h2 id="PageHeap"><a href="#PageHeap" class="headerlink" title="PageHeap"></a>PageHeap</h2><p>PageHeap 是堆内存的抽象，PageHeap 存的也是若干链表，链表保存的是 Span，当 CentralCache 没有内存的时，会从 PageHeap 取，把1个 Span 拆成若干内存块，添加到对应大小的链表中，当 CentralCache 内存多的时候，会放回 PageHeap。毫无疑问，PageHeap 也是要加锁的。</p><h2 id="对象大小"><a href="#对象大小" class="headerlink" title="对象大小"></a>对象大小</h2><ul><li>小对象大小：0~256KB</li><li>中对象大小：257~1024kb</li><li>大对象大小：&gt; 1024kb</li></ul><h1 id="GoMalloc"><a href="#GoMalloc" class="headerlink" title="GoMalloc"></a>GoMalloc</h1><p><img src="/images/golang/memory-manage-gomalloc-01.png" alt="Golang内存管理"></p><h2 id="大小维度"><a href="#大小维度" class="headerlink" title="大小维度"></a>大小维度</h2><h2 id="object-size"><a href="#object-size" class="headerlink" title="object size"></a>object size</h2><p>是申请对象的大小，比如，申请一个 8byte object size。</p><h2 id="size-class"><a href="#size-class" class="headerlink" title="size class"></a>size class</h2><p>8byte-到32kb<br><code>object size</code> 的分类、级别，比如 8b ~ 16b，16 ~ 32b，32b ~ 48b …，共 67 个<br>在代码中是这样的：</p><div class="code-wrapper"><pre><code class="hljs go">_NumSizeClasses = <span class="hljs-number">67</span></code></pre></div><h2 id="span-class"><a href="#span-class" class="headerlink" title="span class"></a>span class</h2><p><code>span</code> 的分类、级别，共 134 个，是 size class 的一倍<br>在代码中是这样的：</p><div class="code-wrapper"><pre><code class="hljs go">numSpanClasses = _NumSizeClasses &lt;&lt; <span class="hljs-number">1</span></code></pre></div><p>其中 67 个是 scan (对象中含有指针的），另外 67 个是 noscan（对象中不含有指针的）</p><h1 id="分配器结构"><a href="#分配器结构" class="headerlink" title="分配器结构"></a>分配器结构</h1><h2 id="page"><a href="#page" class="headerlink" title="page"></a>page</h2><p>与 TCMalloc 中的 Page 定义相同。</p><h2 id="mspan"><a href="#mspan" class="headerlink" title="mspan"></a>mspan</h2><p>与 TCMalloc 中的 Span 定义相同。<br>在代码中是这样的：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mspan <span class="hljs-keyword">struct</span> &#123;    allocBits  *gcBitsgcmarkBits *gcBits&#125;</code></pre></div><h2 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h2><p>与 TCMalloc 中的 ThreadCache 定义相同，但在 Golang 中每个 P（MPG中的P）拥有独立的 mcache，可以做到无锁访问。<br>在 mcache 中缓存着 134 个 mspan， 在代码中是这样的：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mcache <span class="hljs-keyword">struct</span> &#123;    alloc [numSpanClasses]*mspan</code></pre></div><h2 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h2><p>所有 P 的共享缓存，访问是要加锁的。<br>在代码中是这样的：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mcentral <span class="hljs-keyword">struct</span> &#123;    nonempty mSpanList <span class="hljs-comment">// 有空闲对象的 mspan 链表</span>empty    mSpanList <span class="hljs-comment">// 没有空闲对象或 span 已经被 mcache 缓存的 span 链表</span></code></pre></div><p>那 mcentral 有多少个呢？往下看 mheap</p><h2 id="mheap"><a href="#mheap" class="headerlink" title="mheap"></a>mheap</h2><p>mcentral 被 mheap 所管理，也是 134 个</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mheap <span class="hljs-keyword">struct</span> &#123;    arenas [<span class="hljs-number">1</span> &lt;&lt; arenaL1Bits]*[<span class="hljs-number">1</span> &lt;&lt; arenaL2Bits]*heapArena        central [numSpanClasses]<span class="hljs-keyword">struct</span> &#123;    mcentral mcentral    pad      [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;)%cpu.CacheLinePadSize]<span class="hljs-keyword">byte</span>    &#125;</code></pre></div><h2 id="pageCache"><a href="#pageCache" class="headerlink" title="pageCache"></a>pageCache</h2><p>在向mheap申请small内存的时候，会先访问 P 中的 pcache，P 结构如下：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> p <span class="hljs-keyword">struct</span> &#123;    pcache      pageCache&#125;</code></pre></div><p>pageCache结构如下</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> pageCache <span class="hljs-keyword">struct</span> &#123;base  <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// base address of the chunk</span>cache <span class="hljs-keyword">uint64</span>  <span class="hljs-comment">// 64-bit bitmap representing free pages (1 means free)</span>scav  <span class="hljs-keyword">uint64</span>  <span class="hljs-comment">// 64-bit bitmap representing scavenged pages (1 means scavenged)</span>&#125;</code></pre></div><h2 id="fixalloc"><a href="#fixalloc" class="headerlink" title="fixalloc"></a>fixalloc</h2><p>基于自由列表的固定大小的分配器</p><h1 id="分配流程"><a href="#分配流程" class="headerlink" title="分配流程"></a>分配流程</h1><h2 id="小内存"><a href="#小内存" class="headerlink" title="小内存"></a>小内存</h2><p>mcache-&gt;mcentral-&gt;mheap位图查找-&gt;pageCache → mheap基数树查找→操作系统分配</p><h2 id="大内存"><a href="#大内存" class="headerlink" title="大内存"></a>大内存</h2><p>大对象是大小大于32KB的内存，不与 mcache 和 mcentral 沟通，并直接通过 mheap 进行分配。经历mheap基数树查找→操作系统分配 的过程。每一个大对象是一个特殊的span, 它的class是0。</p><h2 id="寻找-span"><a href="#寻找-span" class="headerlink" title="寻找 span"></a>寻找 span</h2><ol><li>计算对象所需内存大小size</li><li>根据size到size class映射，计算出所需的size class</li><li>根据size class和对象是否包含指针计算出span class</li><li>获取该span class指向的span。</li></ol><p>以分配一个不包含指针的，大小为24Byte的对象为例。</p><p>根据映射表：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// class  bytes/obj  bytes/span  objects  tail waste  max waste</span><span class="hljs-comment">//     1          8        8192     1024           0     87.50%</span><span class="hljs-comment">//     2         16        8192      512           0     43.75%</span><span class="hljs-comment">//     3         32        8192      256           0     46.88%</span><span class="hljs-comment">//     4         48        8192      170          32     31.52%</span><span class="hljs-comment">//     5         64        8192      128           0     23.44%</span><span class="hljs-comment">//     6         80        8192      102          32     19.07%</span><span class="hljs-comment">//     7         96        8192       85          32     15.95%</span><span class="hljs-comment">//     8        112        8192       73          16     13.56%</span><span class="hljs-comment">//     9        128        8192       64           0     11.72%</span><span class="hljs-comment">//    10        144        8192       56         128     11.82%</span><span class="hljs-comment">//    11        160        8192       51          32      9.73%</span></code></pre></div><p>size class 3，它的对象大小范围是(16,32]Byte，24Byte刚好在此区间，所以此对象的size class为3。<br>Size class到span class的计算如下：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// noscan为true代表对象不包含指针</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeSpanClass</span><span class="hljs-params">(sizeclass <span class="hljs-keyword">uint8</span>, noscan <span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">spanClass</span></span> &#123;<span class="hljs-keyword">return</span> spanClass(sizeclass&lt;&lt;<span class="hljs-number">1</span>) | spanClass(bool2int(noscan))&#125;</code></pre></div><p>所以，对应的span class为：</p><div class="code-wrapper"><pre><code class="hljs go">span class = <span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span> = <span class="hljs-number">7</span></code></pre></div><p>所以该对象需要的是span class 7指向的span。</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>在 GO 目前的版本中，内存管理使用了 位图（bitmap）、基数树（radix tree）。</p><h2 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h2><p>图（Bitmap），即位（Bit）的集合，是一种数据结构，可用于记录大量的0-1状态，在很多地方都会用到，比如Linux内核（如inode，磁盘块）、Bloom Filter算法等，其优势是可以在一个非常高的空间利用率下保存大量0-1状态。<br>BitMap算法的核心思想是用bit数组来记录0-1两种状态，然后再将具体数据映射到这个比特数组的具体位置，这个比特位设置成0表示数据不存在，设置成1表示数据存在。<br>BitMap算在在大量数据查询、去重等应用场景中使用的比较多，这个算法具有比较高的空间利用率。<br>在《编程珠玑》第一章中，就有利用bitmap进行大量文件的排序。<br>JDK<br>google</p><p>应该是GC的时候使用。</p><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><p><img src="/images/golang/memory-manage-trie-01.png" alt="前缀树"><br>在计算机科学中，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。<br>应用场景<br>trie树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p><h2 id="基数树"><a href="#基数树" class="headerlink" title="基数树"></a>基数树</h2><p><img src="/images/golang/memory-manage-radix-01.png" alt="基数树"><br>在计算机科学中，基数树，或称Patricia trie/tree，或crit bit tree，压缩前缀树，是一种更节省空间的Trie（前缀树）。对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。<br>应用场景<br>用于IP 路由。 信息检索中用于文本文档的倒排索引。</p><h2 id="go-内存管理中的位图、基数树"><a href="#go-内存管理中的位图、基数树" class="headerlink" title="go 内存管理中的位图、基数树"></a>go 内存管理中的位图、基数树</h2><p>在Go1.12的时候,Go语言采用了 Treap 进行内存的管理，Treap 是一种引入了随机数的二叉树搜索树，其实现简单，并且引入的随机数以及必要时的旋转保证了比较好的平衡特性。</p><h3 id="mspan-的实现-基数树（radix-tree）"><a href="#mspan-的实现-基数树（radix-tree）" class="headerlink" title="mspan 的实现 基数树（radix tree）"></a>mspan 的实现 基数树（radix tree）</h3><p>管理线性的地址空间的位图结构叫做基数树<br>mpagealloc.go</p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><ul><li>mpagealloc.go：Page allocator、radix tree</li><li>malloc.go：mallocgc() 申请内存的入口</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>bitmap 管理内存页<br>radix tree 内存管理的结构</p><h1 id="参考借鉴"><a href="#参考借鉴" class="headerlink" title="参考借鉴"></a>参考借鉴</h1><p><a href="https://lessisbetter.site/2019/07/06/go-memory-allocation/">Go内存分配那些事，就这么简单！</a><br><a href="https://www.bilibili.com/video/av288263284/">GopherCon 2020: Michael Knyszek - Evolving the Go Memory Manager’s RAM</a><br><a href="https://juejin.cn/post/6844903769201704973">漫画：什么是Bitmap算法？</a><br><a href="http://c.biancheng.net/view/1270.html">什么是虚拟内存，虚拟内存及其作用详解</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存管理</tag>
      
      <tag>内存分配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redash Gunicorn 超时</title>
    <link href="/python/gunicorn-timeout/"/>
    <url>/python/gunicorn-timeout/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近总有用户反馈说Redash下载比较大的Excel就会出现“失败 - 服务器出现问题”，而且每次从点了下载到出现错误提示时间都是差不多的。我先查看了Nginx的error日志，显示 <code>upstream prematurely closed connection while sending to client</code>，第一反应应该是超时导致的。</p><span id="more"></span><h2 id="1-修改Redash配置"><a href="#1-修改Redash配置" class="headerlink" title="1. 修改Redash配置"></a>1. 修改Redash配置</h2><ul><li>.env文件修改log级别为调试 <code>REDASH_LOG_LEVEL=&quot;DEBUG&quot;</code></li><li>.env文件加上超时配置 <code>REDASH_BIGQUERY_HTTP_TIMEOUT=600</code></li><li>Redash的启动命令后面增加 <code>-t 600</code> 参数。<br>10分钟应该够用了！重启redash进程后，进行尝试试，不好使！好吧，也许是配置参数写错了，那改成 <code>--timeout 600</code> 再试一下，发现还不好使！继续。。。</li></ul><h2 id="2-修改Nginx配置"><a href="#2-修改Nginx配置" class="headerlink" title="2. 修改Nginx配置"></a>2. 修改Nginx配置</h2><ul><li>请求超时：keepalive_timeout、client_header_timeout、client_body_timeout</li><li>后端服务器处理请求的时间设置：proxy_connect_timeout、proxy_read_timeout<br>重启Nginx，下载还是失败！！！看来不是超时导致的了？！</li></ul><h2 id="3-查看进程使用的资源"><a href="#3-查看进程使用的资源" class="headerlink" title="3. 查看进程使用的资源"></a>3. 查看进程使用的资源</h2><p>先执行：<br><code>top</code><br>再尝试下载操作，发现名叫<code>gunicorn</code>（Redash的server是用gunicorn启动的）的<code>COMMAND</code>CPU占用CPU到了100%，并且持续一定时间后，进程消失，新的进程启动后，CPU占用恢复正常值。那接下来就看看此进程都执行了哪些操作。</p><h2 id="4-进程跟踪"><a href="#4-进程跟踪" class="headerlink" title="4. 进程跟踪"></a>4. 进程跟踪</h2><p>跟踪CPU占用超高的 <code>gunicorn</code> 进程：</p><div class="code-wrapper"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> strace -T -tt -e trace=<span class="hljs-keyword">all</span> -p 进程ID</code></pre></div><p>显式进程一直在 <code>read</code>、<code>write</code> 的系统调用，最后一行输出<br><code>+++ killed by SIGKILL +++</code><br>后，跟踪就停止了。难道是触发了系统的<code>ulimit</code>限制，然后被系统杀掉了？</p><h2 id="5-设置ulimit参数"><a href="#5-设置ulimit参数" class="headerlink" title="5. 设置ulimit参数"></a>5. 设置ulimit参数</h2><p>设置 <code>gunicorn</code> 运行用户的 <code>ulimit</code>，重新尝试，没有解决。看来也不是这个问题。。。那是被谁 <code>kill</code> 掉的呢？</p><h2 id="6-捕捉kill信号"><a href="#6-捕捉kill信号" class="headerlink" title="6. 捕捉kill信号"></a>6. 捕捉kill信号</h2><p>使用 <code>auditctl</code>，添加捕捉规则：</p><div class="code-wrapper"><pre><code class="hljs awk">$ auditctl -a <span class="hljs-keyword">exit</span>,always -F arch=b64 -S kill -F a1=<span class="hljs-number">9</span></code></pre></div><p>进行下载文件操作，等待进程被杀死之后，显式捕捉到结果：</p><div class="code-wrapper"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> ausearch <span class="hljs-literal">-sc</span> <span class="hljs-built_in">kill</span></code></pre></div><p>输出：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">time</span>-&gt;Fri Dec  <span class="hljs-number">6</span> <span class="hljs-number">16</span>:<span class="hljs-number">13</span>:<span class="hljs-number">26</span> <span class="hljs-number">2019</span><span class="hljs-attribute">type</span>=PROCTITLE msg=audit(<span class="hljs-number">1575620006</span>.<span class="hljs-number">444</span>:<span class="hljs-number">103711</span>): proctitle=<span class="hljs-number">2</span>F<span class="hljs-number">6</span>F<span class="hljs-number">70742</span>F<span class="hljs-number">6</span>D<span class="hljs-number">6</span>F<span class="hljs-number">64756</span>C<span class="hljs-number">65732</span>F<span class="hljs-number">7265646173682</span>D<span class="hljs-number">372</span>E<span class="hljs-number">302</span>E<span class="hljs-number">302</span>F<span class="hljs-number">7265646173682</span>F<span class="hljs-number">62696</span>E<span class="hljs-number">2</span>F<span class="hljs-number">707974686</span>F<span class="hljs-number">6</span>E<span class="hljs-number">322</span>E<span class="hljs-number">37002</span>F<span class="hljs-number">6</span>F<span class="hljs-number">70742</span>F<span class="hljs-number">7265646173682</span>F<span class="hljs-number">7265646173682</span>F<span class="hljs-number">62696</span>E<span class="hljs-number">2</span>F<span class="hljs-number">67756</span>E<span class="hljs-number">69636</span>F<span class="hljs-number">726</span>E<span class="hljs-number">002</span>D<span class="hljs-number">62003132372</span>E<span class="hljs-number">302</span>E<span class="hljs-number">302</span>E<span class="hljs-number">313</span>A<span class="hljs-number">35303030002</span>D<span class="hljs-number">2</span>D<span class="hljs-number">6</span>E<span class="hljs-number">616</span>D<span class="hljs-number">6500726564617368002</span>D<span class="hljs-number">770034002</span>D<span class="hljs-number">2</span>D<span class="hljs-number">6</span>D<span class="hljs-number">61782</span>D<span class="hljs-number">726571756573</span><span class="hljs-attribute">type</span>=OBJ_PID msg=audit(<span class="hljs-number">1575620006</span>.<span class="hljs-number">444</span>:<span class="hljs-number">103711</span>): opid=<span class="hljs-number">11646</span> oauid=<span class="hljs-number">0</span> ouid=<span class="hljs-number">1001</span> oses=<span class="hljs-number">14406</span> ocomm=<span class="hljs-string">&quot;gunicorn&quot;</span><span class="hljs-attribute">type</span>=SYSCALL msg=audit(<span class="hljs-number">1575620006</span>.<span class="hljs-number">444</span>:<span class="hljs-number">103711</span>): arch=c<span class="hljs-number">000003</span>e syscall=<span class="hljs-number">62</span> success=yes exit=<span class="hljs-number">0</span> a<span class="hljs-number">0</span>=<span class="hljs-number">2</span>d<span class="hljs-number">7</span>e a<span class="hljs-number">1</span>=<span class="hljs-number">9</span> a<span class="hljs-number">2</span>=<span class="hljs-number">0</span> a<span class="hljs-number">3</span>=<span class="hljs-number">0</span> items=<span class="hljs-number">0</span> ppid=<span class="hljs-number">11490</span> pid=<span class="hljs-number">11494</span> auid=<span class="hljs-number">0</span> uid=<span class="hljs-number">1001</span> gid=<span class="hljs-number">1001</span> euid=<span class="hljs-number">1001</span> suid=<span class="hljs-number">1001</span> fsuid=<span class="hljs-number">1001</span> egid=<span class="hljs-number">1001</span> sgid=<span class="hljs-number">1001</span> fsgid=<span class="hljs-number">1001</span> tty=(none) ses=<span class="hljs-number">14406</span> comm=<span class="hljs-string">&quot;gunicorn&quot;</span> exe=<span class="hljs-string">&quot;/opt/modules/redash-7.0.0/redash/bin/python2.7&quot;</span> key=(null)</code></pre></div><p>原来是被父进程搞死了。。。</p><h2 id="7-查看gunicorn日志"><a href="#7-查看gunicorn日志" class="headerlink" title="7. 查看gunicorn日志"></a>7. 查看gunicorn日志</h2><p>进入supervisord控制台，通过<code>tail -f </code> 打印 <code>gunicorn</code>进程的输出。</p><div class="code-wrapper"><pre><code class="hljs less"><span class="hljs-selector-attr">[CRITICAL]</span> <span class="hljs-selector-tag">WORKER</span> <span class="hljs-selector-tag">TIMEOUT</span> (<span class="hljs-attribute">pid</span>:<span class="hljs-number">15577</span>)<span class="hljs-selector-attr">[INFO]</span> <span class="hljs-selector-tag">Worker</span> <span class="hljs-selector-tag">exiting</span> (<span class="hljs-attribute">pid</span>: <span class="hljs-number">15577</span>)<span class="hljs-selector-attr">[INFO]</span> <span class="hljs-selector-tag">Booting</span> <span class="hljs-selector-tag">worker</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">pid</span>: <span class="hljs-selector-tag">15646</span></code></pre></div><p><code>timeout</code>…原因就是最开始猜测的超时问题。</p><p><code>gunicorn</code> 给子进程的执行时间就有30秒，如果超过这个限制就会被父进程kill。可是timeout的超时配置并不生效。。。</p><h2 id="8-最终解决方案"><a href="#8-最终解决方案" class="headerlink" title="8.最终解决方案"></a>8.最终解决方案</h2><p><code>Gunicorn</code> 运行命令增加 <code>-k gevent</code> 配置</p><p><code>Gunicorn</code> 是 <code>pre-fork</code> 模型，<code>worker</code> 默认是 <code>sync</code> 改为 <code>gevent</code></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gunicorn</tag>
      
      <tag>timeout</tag>
      
      <tag>redash</tag>
      
      <tag>超时</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go数据结构之数组与切片</title>
    <link href="/golang/datastruct-arrayslice/"/>
    <url>/golang/datastruct-arrayslice/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数组的长度是声明的时候就固定好的，后面不可能变大，而且长度和容量相等。</p><p>切片的长度和容量后面可以随着元素增多而增长，但是容量不可能小于长度。</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="声明-amp-初始化"><a href="#声明-amp-初始化" class="headerlink" title="声明&amp;初始化"></a>声明&amp;初始化</h3><p>在 Go 中声明即初始化，如果在声明的时候没有初始化值，那么就会赋值为声明类型的「零值」。</p><div class="code-wrapper"><pre><code class="hljs reasonml">func <span class="hljs-constructor">TestDemo1(<span class="hljs-params">t</span> <span class="hljs-operator">*</span><span class="hljs-params">testing</span>.T)</span> &#123;<span class="hljs-comment">// 数组</span>var array1 <span class="hljs-literal">[<span class="hljs-number">5</span>]</span><span class="hljs-built_in">int</span>        <span class="hljs-comment">// 只需设置长度，后面不可变</span>var array2 = <span class="hljs-keyword">new</span>(<span class="hljs-literal">[<span class="hljs-number">5</span>]</span><span class="hljs-built_in">int</span>) <span class="hljs-comment">// 返回指针</span><span class="hljs-comment">// 切片</span>var slice1 <span class="hljs-literal">[]</span><span class="hljs-built_in">int</span>var slice2 = make(<span class="hljs-literal">[]</span><span class="hljs-built_in">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 设置长度、容量，后面可变</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array1 val:&quot;</span>, <span class="hljs-params">array1</span>)</span>      <span class="hljs-comment">// [0 0 0 0 0]</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array1 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">array1</span>)</span>) <span class="hljs-comment">// 5</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array1 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">array1</span>)</span>) <span class="hljs-comment">// 5</span>fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;&quot;</span>)</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array2 val:&quot;</span>, <span class="hljs-params">array2</span>)</span>      <span class="hljs-comment">// &amp;[0 0 0 0 0]</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array2 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">array2</span>)</span>) <span class="hljs-comment">// 5</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array2 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">array2</span>)</span>) <span class="hljs-comment">// 5</span>fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;&quot;</span>)</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice1 val:&quot;</span>, <span class="hljs-params">slice1</span>)</span>      <span class="hljs-comment">// []</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice1 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">slice1</span>)</span>) <span class="hljs-comment">// 0</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice1 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">slice1</span>)</span>) <span class="hljs-comment">// 0</span>fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;&quot;</span>)</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice2 val:&quot;</span>, <span class="hljs-params">slice2</span>)</span>      <span class="hljs-comment">// [0 0 0 0 0]</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice2 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">slice2</span>)</span>) <span class="hljs-comment">// 5</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice2 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">slice2</span>)</span>) <span class="hljs-comment">// 5</span>&#125;</code></pre></div><p>在声明的时候就初始化：</p><div class="code-wrapper"><pre><code class="hljs reasonml">func <span class="hljs-constructor">TestDemo2(<span class="hljs-params">t</span> <span class="hljs-operator">*</span><span class="hljs-params">testing</span>.T)</span> &#123;<span class="hljs-comment">// 数组</span>var array1 = <span class="hljs-literal">[<span class="hljs-number">5</span>]</span><span class="hljs-built_in">int</span>&#123;<span class="hljs-number">4</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">5</span>&#125;var array2 = <span class="hljs-literal">[<span class="hljs-operator">...</span>]</span><span class="hljs-built_in">int</span>&#123;<span class="hljs-number">4</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">5</span>&#125;<span class="hljs-comment">// 切片</span>var slice1 = <span class="hljs-literal">[]</span><span class="hljs-built_in">int</span>&#123;<span class="hljs-number">4</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">5</span>&#125;var slice2 = array1<span class="hljs-literal">[:]</span> <span class="hljs-comment">// 从数组截取来的切片</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array1 val:&quot;</span>, <span class="hljs-params">array1</span>)</span>      <span class="hljs-comment">// [0 0 5 0 1]</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array1 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">array1</span>)</span>) <span class="hljs-comment">// 5</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array1 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">array1</span>)</span>) <span class="hljs-comment">// 5</span>fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;&quot;</span>)</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array2 val:&quot;</span>, <span class="hljs-params">array2</span>)</span>      <span class="hljs-comment">// [0 0 5 0 1]</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array2 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">array2</span>)</span>) <span class="hljs-comment">// 5</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array2 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">array2</span>)</span>) <span class="hljs-comment">// 5</span>fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;&quot;</span>)</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice1 val:&quot;</span>, <span class="hljs-params">slice1</span>)</span>      <span class="hljs-comment">// [0 0 5 0 1]</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice1 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">slice1</span>)</span>) <span class="hljs-comment">// 5</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice1 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">slice1</span>)</span>) <span class="hljs-comment">// 5</span>fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;&quot;</span>)</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice2 val:&quot;</span>, <span class="hljs-params">slice2</span>)</span>      <span class="hljs-comment">// [0 0 5 0 1]</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice2 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">slice2</span>)</span>) <span class="hljs-comment">// 5</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice2 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">slice2</span>)</span>) <span class="hljs-comment">// 5</span>&#125;</code></pre></div><h3 id="添加-amp-更新元素值"><a href="#添加-amp-更新元素值" class="headerlink" title="添加&amp;更新元素值"></a>添加&amp;更新元素值</h3><p>数组因为长度固定，且的值都是初始化好了的，所以只有更新。</p><p>切片更新操作和数据一样，只不过新增元素只能通过 append() 方法。</p><blockquote><p>append()：将元素追加大切片的末尾，如果容量不够，会进行扩容。</p></blockquote><div class="code-wrapper"><pre><code class="hljs reasonml">func <span class="hljs-constructor">TestDemo3(<span class="hljs-params">t</span> <span class="hljs-operator">*</span><span class="hljs-params">testing</span>.T)</span> &#123;<span class="hljs-comment">// 数组</span>var array1 = <span class="hljs-literal">[<span class="hljs-number">5</span>]</span><span class="hljs-built_in">int</span>&#123;<span class="hljs-number">4</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">5</span>&#125;array1<span class="hljs-literal">[<span class="hljs-number">0</span>]</span> = <span class="hljs-number">100</span> <span class="hljs-comment">// 更新</span>array1<span class="hljs-literal">[<span class="hljs-number">4</span>]</span> = <span class="hljs-number">100</span> <span class="hljs-comment">// 更新</span><span class="hljs-comment">// 切片</span>var slice1 = <span class="hljs-literal">[]</span><span class="hljs-built_in">int</span>&#123;<span class="hljs-number">4</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">5</span>&#125;array1<span class="hljs-literal">[<span class="hljs-number">4</span>]</span> = <span class="hljs-number">100</span> <span class="hljs-comment">// 更新</span><span class="hljs-comment">//array1[5] = 100 // 报错</span>slice1 = append(slice1, <span class="hljs-number">1</span>) <span class="hljs-comment">// 切片增加元素只能使用此方法</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array1 val:&quot;</span>, <span class="hljs-params">array1</span>)</span>      <span class="hljs-comment">// [100 0 5 0 100]</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array1 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">array1</span>)</span>) <span class="hljs-comment">// 5</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;array1 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">array1</span>)</span>) <span class="hljs-comment">// 5</span>fmt.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;&quot;</span>)</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice1 val:&quot;</span>, <span class="hljs-params">slice1</span>)</span>      <span class="hljs-comment">// [0 0 5 0 1 1]</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice1 len:&quot;</span>, <span class="hljs-params">len</span>(<span class="hljs-params">slice1</span>)</span>) <span class="hljs-comment">// 6</span>t.<span class="hljs-constructor">Log(<span class="hljs-string">&quot;slice1 cap:&quot;</span>, <span class="hljs-params">cap</span>(<span class="hljs-params">slice1</span>)</span>) <span class="hljs-comment">// 10</span>&#125;</code></pre></div><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>数组与切片，都可以使用表达式截取，截取之后的数据它的类型为切片。</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-keyword">func</span> TestDemo4(t *testing.T) &#123;array1 := [<span class="hljs-number">10</span>]int&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;slice1 := array1[<span class="hljs-number">3</span>:]              <span class="hljs-regexp">//</span> 从 index <span class="hljs-number">3</span> 取到 index endt.Log(<span class="hljs-string">&quot;slice1 val:&quot;</span>, slice1)      <span class="hljs-regexp">//</span> [<span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span>]t.Log(<span class="hljs-string">&quot;slice1 len:&quot;</span>, len(slice1)) <span class="hljs-regexp">//</span> <span class="hljs-number">7</span>t.Log(<span class="hljs-string">&quot;slice1 cap:&quot;</span>, cap(slice1)) <span class="hljs-regexp">//</span> <span class="hljs-number">7</span>fmt.Println(<span class="hljs-string">&quot;&quot;</span>)slice2 := array1[<span class="hljs-number">3</span>:<span class="hljs-number">4</span>]             <span class="hljs-regexp">//</span> 从 index <span class="hljs-number">3</span> 取到 index <span class="hljs-number">4</span>t.Log(<span class="hljs-string">&quot;slice2 val:&quot;</span>, slice2)      <span class="hljs-regexp">//</span> [<span class="hljs-number">3</span>]t.Log(<span class="hljs-string">&quot;slice2 len:&quot;</span>, len(slice2)) <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>t.Log(<span class="hljs-string">&quot;slice2 cap:&quot;</span>, cap(slice2)) <span class="hljs-regexp">//</span> <span class="hljs-number">7</span>fmt.Println(<span class="hljs-string">&quot;&quot;</span>)slice3 := array1[<span class="hljs-number">3</span>:<span class="hljs-number">6</span>:<span class="hljs-number">6</span>]           <span class="hljs-regexp">//</span> 从 index <span class="hljs-number">3</span> 取到 index <span class="hljs-number">6</span>，容量取到 index <span class="hljs-number">6</span>t.Log(<span class="hljs-string">&quot;slice3 val:&quot;</span>, slice3)      <span class="hljs-regexp">//</span> [<span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span>]t.Log(<span class="hljs-string">&quot;slice3 len:&quot;</span>, len(slice3)) <span class="hljs-regexp">//</span> <span class="hljs-number">3</span>t.Log(<span class="hljs-string">&quot;slice3 cap:&quot;</span>, cap(slice3)) <span class="hljs-regexp">//</span> <span class="hljs-number">3</span>fmt.Println(<span class="hljs-string">&quot;&quot;</span>)slice4 := array1[<span class="hljs-number">3</span>:<span class="hljs-number">6</span>:<span class="hljs-number">9</span>]           <span class="hljs-regexp">//</span> 从 index <span class="hljs-number">3</span> 取到 index <span class="hljs-number">6</span>，容量取到 index <span class="hljs-number">9</span>t.Log(<span class="hljs-string">&quot;slice4 val:&quot;</span>, slice4)      <span class="hljs-regexp">//</span> [<span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">5</span>]t.Log(<span class="hljs-string">&quot;slice4 len:&quot;</span>, len(slice4)) <span class="hljs-regexp">//</span> <span class="hljs-number">3</span>t.Log(<span class="hljs-string">&quot;slice4 cap:&quot;</span>, cap(slice4)) <span class="hljs-regexp">//</span> <span class="hljs-number">6</span>&#125;</code></pre></div><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>使用 for、range</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo5</span><span class="hljs-params">(t *testing.T)</span></span> &#123;array1 := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;slice1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>)<span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> array1 &#123;fmt.Println(k, <span class="hljs-string">&quot;-&quot;</span>, v)&#125;fmt.Println()<span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> slice1 &#123;fmt.Println(k, <span class="hljs-string">&quot;-&quot;</span>, v)&#125;&#125;</code></pre></div><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>数组与数组可以使用 == 比较，不能与 nil 比较</p><p>切片与切片不能使用 == 比较，可以使用 reflect.DeepEqual 比较，可以与 nil 比较</p><div class="code-wrapper"><pre><code class="hljs jboss-cli">func TestDemo6<span class="hljs-params">(t *testing.T)</span> &#123;array1 := [<span class="hljs-string">...</span>]int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 4&#125;array2 := [<span class="hljs-string">...</span>]int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 9&#125;array3 := [<span class="hljs-string">...</span>]int&#123;9, 1, 7, 3, 0, 5, 6, 2, 8, 9&#125;t.Logf<span class="hljs-params">(&quot;<span class="hljs-attr">array1</span> == array2 %t\n&quot;, <span class="hljs-attr">array1</span> == array2)</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span>t.Logf<span class="hljs-params">(&quot;<span class="hljs-attr">array2</span> == array3 %t\n&quot;, <span class="hljs-attr">array2</span> == array3)</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span><span class="hljs-string">//t.Logf</span><span class="hljs-params">(&quot;%t\n&quot;, <span class="hljs-attr">array2</span> == nil)</span> <span class="hljs-string">//</span> 会报错，数组不能与nil比slice1 := make<span class="hljs-params">([]int, 5, 5)</span>var slice2 []intslice3 := []int&#123;4: 0&#125;<span class="hljs-string">//</span> t.Logf<span class="hljs-params">(&quot;%t\n&quot;, <span class="hljs-attr">slice1</span> == slice2)</span> <span class="hljs-string">//</span> 会报错，切片与切片不能比t.Logf<span class="hljs-params">(&quot;<span class="hljs-attr">slice1</span> == nil %t\n&quot;, <span class="hljs-attr">slice1</span> == nil)</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span>t.Logf<span class="hljs-params">(&quot;<span class="hljs-attr">slice2</span> == nil %t\n&quot;, <span class="hljs-attr">slice2</span> == nil)</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span>t.Logf<span class="hljs-params">(&quot;<span class="hljs-attr">slice3</span> == nil %t\n&quot;, <span class="hljs-attr">slice3</span> == nil)</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span>t.Logf<span class="hljs-params">(&quot;<span class="hljs-attr">slice1</span> == slice2 %t\n&quot;, reflect.DeepEqual(slice1, slice2)</span>) <span class="hljs-string">//</span> <span class="hljs-literal">false</span>t.Logf<span class="hljs-params">(&quot;<span class="hljs-attr">slice2</span> == slice3 %t\n&quot;, reflect.DeepEqual(slice2, slice3)</span>) <span class="hljs-string">//</span> <span class="hljs-literal">false</span>t.Logf<span class="hljs-params">(&quot;<span class="hljs-attr">slice1</span> == slice3 %t\n&quot;, reflect.DeepEqual(slice1, slice3)</span>) <span class="hljs-string">//</span> <span class="hljs-literal">true</span>&#125;</code></pre></div><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>需使用 append()、切片表达式 结合来完成</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo7</span><span class="hljs-params">(t *testing.T)</span></span> &#123;slice1 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;slice1 = <span class="hljs-built_in">append</span>(slice1[:<span class="hljs-number">2</span>], slice1[<span class="hljs-number">3</span>:]...)t.Log(slice1)&#125;</code></pre></div><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="数组与切片的关系"><a href="#数组与切片的关系" class="headerlink" title="数组与切片的关系"></a>数组与切片的关系</h3><p><strong>数组为值类型，切片为引用类型</strong>，他们又有何关系呢？</p><p>程序示例：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo8</span><span class="hljs-params">(t *testing.T)</span></span> &#123;array1 := [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;slice1 := array1[:]t.Log(<span class="hljs-string">&quot;slice1 val:&quot;</span>, slice1)      <span class="hljs-comment">// [9 1 7 3 0 5 6 2 8 4]</span>t.Log(<span class="hljs-string">&quot;slice1 len:&quot;</span>, <span class="hljs-built_in">len</span>(slice1)) <span class="hljs-comment">// 10</span>t.Log(<span class="hljs-string">&quot;slice1 cap:&quot;</span>, <span class="hljs-built_in">cap</span>(slice1)) <span class="hljs-comment">// 10</span>array1[<span class="hljs-number">9</span>] = <span class="hljs-number">96969696</span> <span class="hljs-comment">// array1 的修改会影响到 slice1</span>fmt.Println(<span class="hljs-string">&quot;&quot;</span>)t.Log(<span class="hljs-string">&quot;slice1 val:&quot;</span>, slice1)      <span class="hljs-comment">// [9 1 7 3 0 5 6 2 8 96969696]</span>t.Log(<span class="hljs-string">&quot;slice1 len:&quot;</span>, <span class="hljs-built_in">len</span>(slice1)) <span class="hljs-comment">// 10</span>t.Log(<span class="hljs-string">&quot;slice1 cap:&quot;</span>, <span class="hljs-built_in">cap</span>(slice1)) <span class="hljs-comment">// 10</span>&#125;</code></pre></div><p>在这个示例程序中，可以说 slice1 是 array1 的引用。</p><p>不光是在示例程序中，这种在数组上通过表达式截取出的切片，为数组的引用，就算在程序中，直接声明一个新切片（var slice1 []int），在切片的底层实现，其实也是引用了一个数组。</p><p>他们的关系就是：<strong>数组是切片的底层实现，切片是数组的引用。</strong></p><h3 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h3><p>在示例程序 TestDemo8 中，slice1 会一直引用 array1 么？</p><p>一般情况下是这样，但有种情况下引用会发生变化，就是在 slice 发生扩容的情况下</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo9</span><span class="hljs-params">(t *testing.T)</span></span> &#123;array1 := [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;slice1 := array1[:] <span class="hljs-comment">// 从 array1 截取出 slice1</span>t.Log(<span class="hljs-string">&quot;slice1 val:&quot;</span>, slice1)      <span class="hljs-comment">// [9 1 7 3 0 5 6 2 8 4]</span>t.Log(<span class="hljs-string">&quot;slice1 len:&quot;</span>, <span class="hljs-built_in">len</span>(slice1)) <span class="hljs-comment">// 10</span>t.Log(<span class="hljs-string">&quot;slice1 cap:&quot;</span>, <span class="hljs-built_in">cap</span>(slice1)) <span class="hljs-comment">// 10</span>slice1 = <span class="hljs-built_in">append</span>(slice1, <span class="hljs-number">9</span>) <span class="hljs-comment">// 进行扩容后，slice1 指向了新的底层数组，不在是 array1 的引用</span>array1[<span class="hljs-number">9</span>] = <span class="hljs-number">96969696</span>fmt.Println(<span class="hljs-string">&quot;&quot;</span>)t.Log(<span class="hljs-string">&quot;slice1 val:&quot;</span>, slice1)      <span class="hljs-comment">// [9 1 7 3 0 5 6 2 8 4 9]</span>t.Log(<span class="hljs-string">&quot;slice1 len:&quot;</span>, <span class="hljs-built_in">len</span>(slice1)) <span class="hljs-comment">// 11</span>t.Log(<span class="hljs-string">&quot;slice1 cap:&quot;</span>, <span class="hljs-built_in">cap</span>(slice1)) <span class="hljs-comment">// 20</span>&#125;</code></pre></div><p>当切片添加新元素，发现容量不够时，会开辟一个新的底层数组，然后把旧数组的数据和添加的新元素一并拷贝到新数组中。</p><h4 id="扩容策略："><a href="#扩容策略：" class="headerlink" title="扩容策略："></a>扩容策略：</h4><ul><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）</li><li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）</li><li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）</li></ul><h3 id="深复制"><a href="#深复制" class="headerlink" title="深复制"></a>深复制</h3><p>靠扩容解决引用问题，显得不是那么优雅。</p><p>可以使用 copy() 进行深复制</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo10</span><span class="hljs-params">(t *testing.T)</span></span> &#123;array1 := [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;<span class="hljs-keyword">var</span> slice1 = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<span class="hljs-built_in">copy</span>(slice1, array1[:]) <span class="hljs-comment">// 深复制，slice1 不会引用 array1</span>array1[<span class="hljs-number">9</span>] = <span class="hljs-number">96969696</span>t.Log(<span class="hljs-string">&quot;slice1 val:&quot;</span>, slice1)      <span class="hljs-comment">// [9 1 7 3 0 5 6 2 8 4]</span>t.Log(<span class="hljs-string">&quot;slice1 len:&quot;</span>, <span class="hljs-built_in">len</span>(slice1)) <span class="hljs-comment">// 10</span>t.Log(<span class="hljs-string">&quot;slice1 cap:&quot;</span>, <span class="hljs-built_in">cap</span>(slice1)) <span class="hljs-comment">// 10</span>fmt.Println(<span class="hljs-string">&quot;&quot;</span>)t.Log(<span class="hljs-string">&quot;array1 val:&quot;</span>, array1)      <span class="hljs-comment">// [9 1 7 3 0 5 6 2 8 96969696]</span>t.Log(<span class="hljs-string">&quot;array1 len:&quot;</span>, <span class="hljs-built_in">len</span>(array1)) <span class="hljs-comment">// 10</span>t.Log(<span class="hljs-string">&quot;array1 cap:&quot;</span>, <span class="hljs-built_in">cap</span>(array1)) <span class="hljs-comment">// 10</span>&#125;</code></pre></div><h3 id="传递"><a href="#传递" class="headerlink" title="传递"></a>传递</h3><p>切片，如果不使用 copy() 进行深复制出一个新的切片，直接传递过去的切片底层还是同一个数组，当然，append() 发生了扩容之后，就不会是同一个数组了。</p><p>数组，直接传递会变成两个数组，如果运用了指针，会指向同一个。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo11</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-comment">// 切片，底层引用的还是同一个数组</span>slice1 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v []<span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-comment">//v = append(v, 20) // 扩容后底层数组就变了</span>v[<span class="hljs-number">0</span>] = <span class="hljs-number">99999</span>t.Log(v)&#125;(slice1)time.Sleep(<span class="hljs-number">1</span> * time.Second)t.Log(<span class="hljs-string">&quot;slice1&quot;</span>, slice1) <span class="hljs-comment">// slice1 [99999 1 7 3 0 5 6 2 8 4]</span>fmt.Println()<span class="hljs-comment">// 切片，copy() 深复制后，底层不是同一个数组</span>slice2 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;slice2Copy := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<span class="hljs-built_in">copy</span>(slice2Copy, slice2)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v []<span class="hljs-keyword">int</span>)</span></span> &#123;v[<span class="hljs-number">0</span>] = <span class="hljs-number">99999</span>&#125;(slice2Copy)time.Sleep(<span class="hljs-number">1</span> * time.Second)t.Log(<span class="hljs-string">&quot;slice2&quot;</span>, slice2) <span class="hljs-comment">// slice2 [9 1 7 3 0 5 6 2 8 4]</span>fmt.Println()<span class="hljs-comment">// 数组，不是同一个</span>array1 := [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v [10]<span class="hljs-keyword">int</span>)</span></span> &#123;v[<span class="hljs-number">0</span>] = <span class="hljs-number">99999</span>&#125;(array1)time.Sleep(<span class="hljs-number">1</span> * time.Second)t.Log(<span class="hljs-string">&quot;array1&quot;</span>, array1) <span class="hljs-comment">// array1 [9 1 7 3 0 5 6 2 8 4]</span>fmt.Println()<span class="hljs-comment">// 数组，同一个</span>array2 := [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v *[10]<span class="hljs-keyword">int</span>)</span></span> &#123;v[<span class="hljs-number">0</span>] = <span class="hljs-number">99999</span>&#125;(&amp;array2)time.Sleep(<span class="hljs-number">1</span> * time.Second)t.Log(<span class="hljs-string">&quot;array2&quot;</span>, array2) <span class="hljs-comment">// array2 [99999 1 7 3 0 5 6 2 8 4]</span>fmt.Println()<span class="hljs-comment">// 数组 同一个</span>array3 := <span class="hljs-built_in">new</span>([<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v *[10]<span class="hljs-keyword">int</span>)</span></span> &#123;v[<span class="hljs-number">0</span>] = <span class="hljs-number">99999</span>&#125;(array3)time.Sleep(<span class="hljs-number">1</span> * time.Second)t.Log(<span class="hljs-string">&quot;array3&quot;</span>, array3) <span class="hljs-comment">// array3 &amp;[99999 0 0 0 0 0 0 0 0 0]</span>&#125;</code></pre></div><p>效果和下面一样</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo12</span><span class="hljs-params">(t *testing.T)</span></span> &#123;array1 := [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;array2 := array1array2[<span class="hljs-number">0</span>] = <span class="hljs-number">999</span>t.Log(<span class="hljs-string">&quot;array1&quot;</span>, array1) <span class="hljs-comment">// array1 [9 1 7 3 0 5 6 2 8 4]</span>t.Log(<span class="hljs-string">&quot;array2&quot;</span>, array2) <span class="hljs-comment">// array2 [999 1 7 3 0 5 6 2 8 4]</span>fmt.Println()slice1 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;slice2 := slice1slice2[<span class="hljs-number">0</span>] = <span class="hljs-number">999</span>t.Log(<span class="hljs-string">&quot;slice1&quot;</span>, slice1) <span class="hljs-comment">// slice1 [999 1 7 3 0 5 6 2 8 4]</span>t.Log(<span class="hljs-string">&quot;slice2&quot;</span>, slice2) <span class="hljs-comment">// slice2 [999 1 7 3 0 5 6 2 8 4]</span>&#125;</code></pre></div><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>一段连续的内存空间。</p><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>make 只能用于 slice、map、channel，返回的初始化后的（非零）值。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul><li>切片</li><li>字典</li><li>通道</li><li>函数</li></ul><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><ul><li>数组</li><li>基础数据类型</li><li>结构体类型</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>切片是数组的引用，数组是切片的底层实现。</li><li>数组的长度(len)等于容量(cap)，切片的长度(len)小于等于容量(cap)。</li><li>数组声明的时候默认就会初始化，值为类型的「零值」；切片声明的时候，如果不初始化，值是 nil。</li><li>使用 copy() 深复制解决引用问题。</li></ol><p><a href="https://github.com/zuoshuwen/go-example/blob/master/e005/a01_test.go">文章示例代码</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>切片</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程之传统同步—(3)原子操作</title>
    <link href="/golang/ipc-atomic/"/>
    <url>/golang/ipc-atomic/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前文章中介绍的互斥锁虽然能够保证同串行化，但是却保证不了执行过程中的中断。<br>要么成功、要么失败，没有中断的情况，我们叫它叫原子性，这种由硬件 CPU 提供支持的特性，是非常可靠的。</p><p><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C">百度百科</a>上关于原子操作的介绍。</p><a id="more"></a><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>由 sync/atomic 包提供操作支持。</p><h3 id="加法（add）"><a href="#加法（add）" class="headerlink" title="加法（add）"></a>加法（add）</h3><p>实现累加</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo1</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> counter <span class="hljs-keyword">int64</span> = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;atomic.AddInt64(&amp;counter, <span class="hljs-number">1</span>)&#125;()&#125;time.Sleep(<span class="hljs-number">2</span> * time.Second)log.Println(<span class="hljs-string">&quot;counter:&quot;</span>, atomic.LoadInt64(&amp;counter))&#125;</code></pre></div><p>结果</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">=== RUN   TestDemo1</span>2020/10/11 00:24:56 counter: 100<span class="hljs-bullet">--- </span>PASS: TestDemo1 (2.00s)PASS</code></pre></div><h3 id="减法（add）"><a href="#减法（add）" class="headerlink" title="减法（add）"></a>减法（add）</h3><p>对于做减法，是没有直接提供的方法的，而 Add（-1）这种是不能对 uint 类型使用的，可以通过补码的方式实现</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo2</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> counter <span class="hljs-keyword">uint64</span> = <span class="hljs-number">100</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;atomic.AddUint64(&amp;counter, ^<span class="hljs-keyword">uint64</span>(-(<span class="hljs-number">-1</span>)<span class="hljs-number">-1</span>))&#125;()&#125;time.Sleep(<span class="hljs-number">2</span> * time.Second)log.Println(<span class="hljs-string">&quot;counter:&quot;</span>, atomic.LoadUint64(&amp;counter))&#125;</code></pre></div><p>结果</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">=== RUN   TestDemo2</span>2020/10/11 00:32:05 counter: 0<span class="hljs-bullet">--- </span>PASS: TestDemo2 (2.00s)PASS</code></pre></div><h3 id="比较并交换（compare-and-swap，简称-CAS）"><a href="#比较并交换（compare-and-swap，简称-CAS）" class="headerlink" title="比较并交换（compare and swap，简称 CAS）"></a>比较并交换（compare and swap，简称 CAS）</h3><p>并发编程中，在没有使用互斥锁的前提下，对共享数据先取出做判断，再根据判断的结果做后续操作，必然是会出问题的，使用 CAS 可以避免这种问题。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo3</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> first <span class="hljs-keyword">int64</span> = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10000</span>; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> atomic.CompareAndSwapInt64(&amp;first, <span class="hljs-number">0</span>, <span class="hljs-keyword">int64</span>(i)) &#123;log.Println(<span class="hljs-string">&quot;抢先运行的是 goroutine&quot;</span>, i)&#125;&#125;(i)&#125;time.Sleep(<span class="hljs-number">2</span> * time.Second)log.Println(<span class="hljs-string">&quot;num:&quot;</span>, atomic.LoadInt64(&amp;first))&#125;</code></pre></div><p>结果</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">=== RUN   TestDemo3</span>2020/10/11 00:42:10 抢先运行的是 goroutine 32020/10/11 00:42:12 num: 3<span class="hljs-bullet">--- </span>PASS: TestDemo3 (2.01s)PASS</code></pre></div><h3 id="加载（load）"><a href="#加载（load）" class="headerlink" title="加载（load）"></a>加载（load）</h3><p>加载操作在进行时只会有一个，不会有其它的读写操作同时进行。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo4</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> counter <span class="hljs-keyword">int64</span> = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;atomic.AddInt64(&amp;counter, <span class="hljs-number">1</span>)log.Println(<span class="hljs-string">&quot;counter:&quot;</span>, atomic.LoadInt64(&amp;counter))&#125;()&#125;time.Sleep(<span class="hljs-number">2</span> * time.Second)&#125;</code></pre></div><h3 id="存储（store）"><a href="#存储（store）" class="headerlink" title="存储（store）"></a>存储（store）</h3><p>存储操作在进行时只会有一个，不会有其它的读写操作同时进行。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo5</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> counter <span class="hljs-keyword">int64</span> = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;atomic.StoreInt64(&amp;counter, <span class="hljs-keyword">int64</span>(i))log.Println(<span class="hljs-string">&quot;counter:&quot;</span>, atomic.LoadInt64(&amp;counter))&#125;(i)&#125;time.Sleep(<span class="hljs-number">2</span> * time.Second)&#125;</code></pre></div><h3 id="交换（swap）"><a href="#交换（swap）" class="headerlink" title="交换（swap）"></a>交换（swap）</h3><p>swap 方法返回被替换之前的旧值。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo6</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> counter <span class="hljs-keyword">int64</span> = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;log.Println(<span class="hljs-string">&quot;counter old:&quot;</span>, atomic.SwapInt64(&amp;counter, <span class="hljs-keyword">int64</span>(i)))&#125;(i)&#125;time.Sleep(<span class="hljs-number">2</span> * time.Second)&#125;</code></pre></div><p>结果</p><div class="code-wrapper"><pre><code class="hljs groovy">=== RUN   TestDemo6<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">0</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">9</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">5</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">1</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">2</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">3</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">6</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">4</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">7</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">43</span>:<span class="hljs-number">36</span> counter <span class="hljs-attr">old:</span> <span class="hljs-number">0</span>--- <span class="hljs-attr">PASS:</span> TestDemo6 (<span class="hljs-number">2.00</span>s)PASS</code></pre></div><h3 id="原子值（value）"><a href="#原子值（value）" class="headerlink" title="原子值（value）"></a>原子值（value）</h3><p>value是一个结构体，内部值定义为 interface{}，所以它是可以接受任何类型的值。</p><p>第一次赋值的时候，原子值的类型就确认了，后面不能赋值其它类型的值。</p><div class="code-wrapper"><pre><code class="hljs reasonml">func <span class="hljs-constructor">TestDemo7(<span class="hljs-params">t</span> <span class="hljs-operator">*</span><span class="hljs-params">testing</span>.T)</span> &#123;var value atomic.Valuevar counter uint64 = <span class="hljs-number">1</span>value.<span class="hljs-constructor">Store(<span class="hljs-params">counter</span>)</span>log.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;counter:&quot;</span>, <span class="hljs-params">value</span>.Load()</span>)value.<span class="hljs-constructor">Store(<span class="hljs-params">uint64</span>(10)</span>)log.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;counter:&quot;</span>, <span class="hljs-params">value</span>.Load()</span>)value.<span class="hljs-constructor">Store(100)</span> <span class="hljs-comment">// 引发 panic</span>log.<span class="hljs-constructor">Println(<span class="hljs-string">&quot;counter:&quot;</span>, <span class="hljs-params">value</span>.Load()</span>)time.<span class="hljs-constructor">Sleep(2 <span class="hljs-operator">*</span> <span class="hljs-params">time</span>.Second)</span>&#125;</code></pre></div><p>结果</p><div class="code-wrapper"><pre><code class="hljs awk">=== RUN   TestDemo7<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">10</span>:<span class="hljs-number">14</span>:<span class="hljs-number">58</span> counter: <span class="hljs-number">0</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">11</span> <span class="hljs-number">10</span>:<span class="hljs-number">14</span>:<span class="hljs-number">58</span> counter: <span class="hljs-number">10</span>--- FAIL: TestDemo7 (<span class="hljs-number">0.00</span>s)panic: sync/atomic: store of inconsistently typed value into Value [recovered]panic: sync/atomic: store of inconsistently typed value into Value                ...Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">1</span></code></pre></div><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="无锁编程"><a href="#无锁编程" class="headerlink" title="无锁编程"></a>无锁编程</h3><p><em>此处暂时先介绍一下，后面有机会出文章再一起学习进步。</em></p><p>放弃互斥锁，采用原子操作，常见方法有以下几种：</p><h4 id="针对计数器"><a href="#针对计数器" class="headerlink" title="针对计数器"></a>针对计数器</h4><p>可以使用例如上面介绍的 Add 方法。</p><h4 id="单生产、消费者"><a href="#单生产、消费者" class="headerlink" title="单生产、消费者"></a>单生产、消费者</h4><p>单生产者、单消费者可以做到免锁访问环形缓冲区（Ring Buffer）。<br>比如，Linux kernel 中的 kfifo 的实现。</p><h4 id="RCU（Read-Copy-Update）"><a href="#RCU（Read-Copy-Update）" class="headerlink" title="RCU（Read Copy Update）"></a>RCU（Read Copy Update）</h4><p>新旧副本切换机制，对于旧副本可以采用延迟释放的做法。</p><h4 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare And Swap）"></a>CAS（Compare And Swap）</h4><p>如无锁栈，无锁队列等待</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>原子操作性能是高于互斥锁的，但带来的复杂性也会提高，真正用好并不容易。</li><li>互斥锁、条件变量，方法内部的实现也都用到了原子操作，特别是CAS。</li></ol><p><a href="https://github.com/zuoshuwen/go-example/blob/master/e003/a01_test.go">文章示例代码</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同步</tag>
      
      <tag>原子操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程之传统同步—(2)条件变量</title>
    <link href="/golang/ipc-cond/"/>
    <url>/golang/ipc-cond/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>回顾上篇文章 <a href="/golang/ipc-mutex/" title="Go并发编程之传统同步—(1)互斥锁">Go并发编程之传统同步—(1)互斥锁</a> 其中说到，同步最终是为了达到以下两种目的：</p><blockquote><ul><li><strong>维持共享数据一致性，并发安全</strong></li><li><strong>控制流程管理，更好的协同工作</strong></li></ul></blockquote><p>示例程序通过使用互斥锁，达到了数据一致性目的，那么流程管理应该怎么做呢？</p><a id="more"></a><h2 id="传统同步"><a href="#传统同步" class="headerlink" title="传统同步"></a>传统同步</h2><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>上篇文章的示例程序，仅仅实现了累加功能，但在现实的工作场景中，需求往往不可能这么简单，现在扩展一下这个程序，给它加上累减的功能。</p><p>加上了累减的示例程序，可以抽象的理解为一个固定容量的“储水池”，可以注水、排水。</p><h4 id="仅用互斥锁"><a href="#仅用互斥锁" class="headerlink" title="仅用互斥锁"></a>仅用互斥锁</h4><p>当水注满以后，停止注水，开始排水，当水排空以后，开始注水，反反复复…</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo1</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> mut sync.MutexmaxSize := <span class="hljs-number">10</span>counter := <span class="hljs-number">0</span><span class="hljs-comment">// 排水口</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> &#123;mut.Lock()<span class="hljs-keyword">if</span> counter == maxSize &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; maxSize; i++ &#123;counter--log.Printf(<span class="hljs-string">&quot;OUTPUT counter = %d&quot;</span>, counter)&#125;&#125;mut.Unlock()time.Sleep(<span class="hljs-number">1</span> * time.Second)&#125;&#125;()<span class="hljs-comment">// 注水口</span><span class="hljs-keyword">for</span> &#123;mut.Lock()<span class="hljs-keyword">if</span> counter == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; maxSize; i++ &#123;counter++log.Printf(<span class="hljs-string">&quot; INPUT counter = %d&quot;</span>, counter)&#125;&#125;mut.Unlock()time.Sleep(<span class="hljs-number">1</span> * time.Second)&#125;&#125;</code></pre></div><p>结果</p><div class="code-wrapper"><pre><code class="hljs awk">=== RUN   TestDemo1                ···<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">13</span>:<span class="hljs-number">52</span>:<span class="hljs-number">50</span>  INPUT counter = <span class="hljs-number">8</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">13</span>:<span class="hljs-number">52</span>:<span class="hljs-number">50</span>  INPUT counter = <span class="hljs-number">9</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">13</span>:<span class="hljs-number">52</span>:<span class="hljs-number">50</span>  INPUT counter = <span class="hljs-number">10</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">13</span>:<span class="hljs-number">52</span>:<span class="hljs-number">50</span> OUTPUT counter = <span class="hljs-number">9</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">13</span>:<span class="hljs-number">52</span>:<span class="hljs-number">50</span> OUTPUT counter = <span class="hljs-number">8</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">13</span>:<span class="hljs-number">52</span>:<span class="hljs-number">50</span> OUTPUT counter = <span class="hljs-number">7</span>                ···</code></pre></div><p>看着没有什么问题，一切正常，但就是这样工作的策略效率太低。</p><h4 id="优化互斥锁"><a href="#优化互斥锁" class="headerlink" title="优化互斥锁"></a>优化互斥锁</h4><p>优化策略，不用等注满水再排水，也不用放空之后，再注水，注水口和排水口一起工作。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo2</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> mut sync.MutexmaxSize := <span class="hljs-number">10</span>counter := <span class="hljs-number">0</span><span class="hljs-comment">// 排水口</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> &#123;mut.Lock()<span class="hljs-keyword">if</span> counter != <span class="hljs-number">0</span> &#123;counter--&#125;log.Printf(<span class="hljs-string">&quot;OUTPUT counter = %d&quot;</span>, counter)mut.Unlock()time.Sleep(<span class="hljs-number">5</span> * time.Second) <span class="hljs-comment">// 为了演示效果，睡眠5秒</span>&#125;&#125;()<span class="hljs-comment">// 注水口</span><span class="hljs-keyword">for</span> &#123;mut.Lock()<span class="hljs-keyword">if</span> counter != maxSize &#123;counter++&#125;log.Printf(<span class="hljs-string">&quot; INPUT counter = %d&quot;</span>, counter)mut.Unlock()time.Sleep(<span class="hljs-number">1</span> * time.Second) <span class="hljs-comment">// 为了演示效果，睡眠1秒</span>&#125;&#125;</code></pre></div><p>结果</p><div class="code-wrapper"><pre><code class="hljs awk">=== RUN   TestDemo2                ···<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">46</span>  INPUT counter = <span class="hljs-number">7</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">47</span>  INPUT counter = <span class="hljs-number">8</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">48</span> OUTPUT counter = <span class="hljs-number">7</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">48</span>  INPUT counter = <span class="hljs-number">8</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">49</span>  INPUT counter = <span class="hljs-number">9</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">50</span>  INPUT counter = <span class="hljs-number">10</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">51</span>  INPUT counter = <span class="hljs-number">10</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">52</span>  INPUT counter = <span class="hljs-number">10</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">53</span> OUTPUT counter = <span class="hljs-number">9</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">53</span>  INPUT counter = <span class="hljs-number">10</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">54</span>  INPUT counter = <span class="hljs-number">10</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">55</span>  INPUT counter = <span class="hljs-number">10</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">56</span>  INPUT counter = <span class="hljs-number">10</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">57</span>  INPUT counter = <span class="hljs-number">10</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">58</span> OUTPUT counter = <span class="hljs-number">9</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">58</span>  INPUT counter = <span class="hljs-number">10</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">11</span>:<span class="hljs-number">59</span>  INPUT counter = <span class="hljs-number">10</span>                ···</code></pre></div><p>通过日志输出，可以看到程序达到了需求，运作正常。</p><p>但是，通过日志输出发现，当排水口效率低下的时候，注水口一直在轮询，这里频繁的上锁操作造成的开销很是浪费。</p><h4 id="条件变量：单发通知"><a href="#条件变量：单发通知" class="headerlink" title="条件变量：单发通知"></a>条件变量：单发通知</h4><p>那有没有什么好的办法，省去不必要的轮询？如果注水口和排水口能互相“通知”就好了！这个功能，<strong>条件变量</strong>可以做到。</p><p>条件变量总是与互斥锁组合使用，除了可以使用 Lock、Unlock，还有如下三个方法：</p><blockquote><ul><li>Wait 等待通知</li><li>Signal 单发通知</li><li>Broadcast 广播通知</li></ul></blockquote><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-keyword">func</span> TestDemo3(t *testing.T) &#123;cond := sync.NewCond(new(sync.Mutex)) <span class="hljs-regexp">//</span> 初始化条件变量maxSize := <span class="hljs-number">10</span>counter := <span class="hljs-number">0</span><span class="hljs-regexp">//</span> 排水口go <span class="hljs-keyword">func</span>() &#123;<span class="hljs-keyword">for</span> &#123;cond.L.Lock() <span class="hljs-regexp">//</span> 上锁<span class="hljs-keyword">if</span> counter == <span class="hljs-number">0</span> &#123; <span class="hljs-regexp">//</span> 没水了cond.Wait() <span class="hljs-regexp">//</span> 啥时候来水？等通知！&#125;counter--log.Printf(<span class="hljs-string">&quot;OUTPUT counter = %d&quot;</span>, counter)cond.Signal() <span class="hljs-regexp">//</span> 单发通知：已排水cond.L.Unlock() <span class="hljs-regexp">//</span> 解锁time.Sleep(<span class="hljs-number">5</span> * time.Second) <span class="hljs-regexp">//</span> 为了演示效果，睡眠<span class="hljs-number">5</span>秒&#125;&#125;()<span class="hljs-regexp">//</span> 注水口<span class="hljs-keyword">for</span> &#123;cond.L.Lock() <span class="hljs-regexp">//</span> 上锁<span class="hljs-keyword">if</span> counter == maxSize &#123; <span class="hljs-regexp">//</span> 水满了cond.Wait() <span class="hljs-regexp">//</span> 啥时候排水？等待通知！&#125;counter++log.Printf(<span class="hljs-string">&quot; INPUT counter = %d&quot;</span>, counter)cond.Signal() <span class="hljs-regexp">//</span> 单发通知：已来水cond.L.Unlock() <span class="hljs-regexp">//</span> 解锁time.Sleep(<span class="hljs-number">1</span> * time.Second) <span class="hljs-regexp">//</span> 为了演示效果，睡眠<span class="hljs-number">1</span>秒&#125;&#125;</code></pre></div><p>结果</p><div class="code-wrapper"><pre><code class="hljs awk">=== RUN   TestDemo3                ···<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">22</span>  INPUT counter = <span class="hljs-number">7</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">23</span>  INPUT counter = <span class="hljs-number">8</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">24</span> OUTPUT counter = <span class="hljs-number">7</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">24</span>  INPUT counter = <span class="hljs-number">8</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">25</span>  INPUT counter = <span class="hljs-number">9</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">26</span>  INPUT counter = <span class="hljs-number">10</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">29</span> OUTPUT counter = <span class="hljs-number">9</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">29</span>  INPUT counter = <span class="hljs-number">10</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">34</span> OUTPUT counter = <span class="hljs-number">9</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">06</span> <span class="hljs-number">14</span>:<span class="hljs-number">51</span>:<span class="hljs-number">34</span>  INPUT counter = <span class="hljs-number">10</span>                ···</code></pre></div><p>通过日志输出，可以看出来，注水口没有一直轮询了，而是等到排水口发通知后，再进行注水，注水口一直再等排水口。那么新的问题又来了，如何提高排水口的效率呢？</p><h4 id="条件变量：广播通知"><a href="#条件变量：广播通知" class="headerlink" title="条件变量：广播通知"></a>条件变量：广播通知</h4><p>多制造出一个排水口，提高排水效率。</p><p>那就不能继续使用单发通知了（Signal），因为单发通知只会通知到一个等待（Wait），针对多等待的这种情况，就需要使用广播通知（Broadcast）。</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-keyword">func</span> TestDemo4(t *testing.T) &#123;cond := sync.NewCond(new(sync.Mutex)) <span class="hljs-regexp">//</span> 初始化条件变量maxSize := <span class="hljs-number">10</span>counter := <span class="hljs-number">0</span><span class="hljs-regexp">//</span> 排水口 <span class="hljs-number">1</span>go <span class="hljs-keyword">func</span>() &#123;<span class="hljs-keyword">for</span> &#123;cond.L.Lock() <span class="hljs-regexp">//</span> 上锁<span class="hljs-keyword">if</span> counter == <span class="hljs-number">0</span> &#123; <span class="hljs-regexp">//</span> 没水了<span class="hljs-regexp">//</span><span class="hljs-keyword">for</span> counter == <span class="hljs-number">0</span> &#123; <span class="hljs-regexp">//</span> 没水了cond.Wait() <span class="hljs-regexp">//</span> 啥时候来水？等通知！&#125;counter--log.Printf(<span class="hljs-string">&quot;OUTPUT A counter = %d&quot;</span>, counter)cond.Broadcast() <span class="hljs-regexp">//</span> 单发通知：已排水cond.L.Unlock() <span class="hljs-regexp">//</span> 解锁<span class="hljs-regexp">//</span>time.Sleep(<span class="hljs-number">2</span> * time.Second) <span class="hljs-regexp">//</span> 为了演示效果，睡眠<span class="hljs-number">5</span>秒&#125;&#125;()<span class="hljs-regexp">//</span> 排水口 <span class="hljs-number">2</span>go <span class="hljs-keyword">func</span>() &#123;<span class="hljs-keyword">for</span> &#123;cond.L.Lock() <span class="hljs-regexp">//</span> 上锁<span class="hljs-keyword">if</span> counter == <span class="hljs-number">0</span> &#123; <span class="hljs-regexp">//</span> 没水了<span class="hljs-regexp">//</span><span class="hljs-keyword">for</span> counter == <span class="hljs-number">0</span> &#123; <span class="hljs-regexp">//</span> 没水了cond.Wait() <span class="hljs-regexp">//</span> 啥时候来水？等通知！&#125;counter--log.Printf(<span class="hljs-string">&quot;OUTPUT B counter = %d&quot;</span>, counter)cond.Broadcast() <span class="hljs-regexp">//</span> 单发通知：已排水cond.L.Unlock() <span class="hljs-regexp">//</span> 解锁<span class="hljs-regexp">//</span>time.Sleep(<span class="hljs-number">2</span> * time.Second) <span class="hljs-regexp">//</span> 为了演示效果，睡眠<span class="hljs-number">5</span>秒&#125;&#125;()<span class="hljs-regexp">//</span> 注水口<span class="hljs-keyword">for</span> &#123;cond.L.Lock() <span class="hljs-regexp">//</span> 上锁<span class="hljs-keyword">if</span> counter == maxSize &#123; <span class="hljs-regexp">//</span> 水满了<span class="hljs-regexp">//</span><span class="hljs-keyword">for</span> counter == maxSize &#123; <span class="hljs-regexp">//</span> 水满了cond.Wait() <span class="hljs-regexp">//</span> 啥时候排水？等待通知！&#125;counter++log.Printf(<span class="hljs-string">&quot; INPUT   counter = %d&quot;</span>, counter)cond.Broadcast() <span class="hljs-regexp">//</span> 单发通知：已来水cond.L.Unlock() <span class="hljs-regexp">//</span> 解锁<span class="hljs-regexp">//</span>time.Sleep(<span class="hljs-number">1</span> * time.Second) <span class="hljs-regexp">//</span> 为了演示效果，睡眠<span class="hljs-number">1</span>秒&#125;&#125;</code></pre></div><p>结果</p><div class="code-wrapper"><pre><code class="hljs awk">=== RUN   TestDemo4                ···<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">30</span> OUTPUT B counter = <span class="hljs-number">2</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">30</span> OUTPUT B counter = <span class="hljs-number">1</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">30</span> OUTPUT B counter = <span class="hljs-number">0</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">30</span> OUTPUT A counter = -<span class="hljs-number">1</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">30</span> OUTPUT A counter = -<span class="hljs-number">2</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">30</span> OUTPUT A counter = -<span class="hljs-number">3</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">30</span> OUTPUT A counter = -<span class="hljs-number">4</span>                ···<span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">31</span> OUTPUT B counter = -<span class="hljs-number">7605</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">31</span>  INPUT   counter = -<span class="hljs-number">7604</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">31</span> OUTPUT A counter = -<span class="hljs-number">7605</span><span class="hljs-number">2020</span><span class="hljs-regexp">/10/</span><span class="hljs-number">07</span> <span class="hljs-number">20</span>:<span class="hljs-number">57</span>:<span class="hljs-number">31</span> OUTPUT A counter = -<span class="hljs-number">7606</span>                ···</code></pre></div><p>通过日志输出可以看到，刚开始的时候还很正常，到后面的时候就变成负值了，一直在负增长，What？</p><p>在 <a href="/golang/ipc-mutex/" title="Go并发编程之传统同步—(1)互斥锁">Go并发编程之传统同步—(1)互斥锁</a> 文章中，程序因为没有加上互斥锁，出现过 counter 值异常的情况。</p><p>但这次程序这次加了互斥锁，按理说形成了一个临界区应该是没有问题了，所以问题应该不是出在临界区上，难道问题出在 <strong>Wait</strong> 上？</p><p>通过IDE<strong>追踪一下Wait的源码</strong></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span> <span class="hljs-title">Wait</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 检查 c 是否是被复制的，如果是就 panic</span>c.checker.check()<span class="hljs-comment">// 将当前 goroutine 加入等待队列</span>t := runtime_notifyListAdd(&amp;c.notify)c.L.Unlock()<span class="hljs-comment">// 等待当前 goroutine 被唤醒</span>runtime_notifyListWait(&amp;c.notify, t)c.L.Lock()&#125;</code></pre></div><p>原来 Wait 内部的执行流程是，先执行了解锁，然后进入等待状态，接到通知之后，再执行加锁操作。</p><p>那按照这个代码逻辑结合输出日志，走一程序遍流程，看看能不能复现出 counter 为负值的情况：</p><blockquote><ol><li><p>注水口将 counter 累加到 10 之后，发送广播通知（Broadcast）。</p></li><li><p>goroutine A 在“第1步”之前的时候进入了等待通知（Wait），现在接收到了广播通知（Broadcast），从 runtime_notifyListWait() 返回，并且成功执行了加锁（Lock）操作。</p></li><li><p>goroutine B 在“第1步”之前的时候进入了等待通知（Wait），现在接收到了广播通知（Broadcast），从 runtime_notifyListWait() 返回，在执行加锁（Lock）操作的时候，发现 goroutine A 先抢占了临界区，所以一直阻塞在 c.L.Lock()。</p></li><li><p>goroutine A 虽然完成任务后会释放锁，但是每次也成功将锁抢占，所以就这样 一直将 counter 减到了 0，然后发送广播通知（Broadcast）、解锁（Unlock）。</p></li><li><p>goroutine B 在 goroutine A 解锁后，成功获得锁并从 Lock 方法中返回，接下来跳出 Wait 方法、跳出 if 判断，执行 counter–（0–），这时候 counter 的值是 -1</p></li></ol></blockquote><p>图示</p><p><img src="/images/golang/ipc-cond-01.jpg" alt="ipc-cond-01"></p><p>问题就出现在第五步，只要 goroutine B 加锁成功的时候，再判断一下 counter 是否为 0 就好了。</p><p>所以将 if counter == 0 改成 for counter == 0，这样上面的“第五步”就变成了</p><blockquote><p>5.goroutine B 在 goroutine A 解锁后，成功加锁（Lock）并从阻塞总返回，接下来跳出 Wait 方法、再次进入 for 循环，判断 counter == 0 结果为真，再次进入等待（Wait）。</p></blockquote><p>代码做出相应的修改后，再执行看结果，没有问题了。</p><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><h3 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h3><p>等待通知（Wait）肯定是要在临界区里面的，那发送通知（Signal、Broadcast）在哪里更好呢？</p><div class="code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Luck</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-title">Wait</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-title">Broadcast</span><span class="hljs-params">()</span></span><span class="hljs-comment">// Signal()</span><span class="hljs-function"><span class="hljs-title">Unlock</span><span class="hljs-params">()</span></span><span class="hljs-comment">// 或者</span><span class="hljs-function"><span class="hljs-title">Luck</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-title">Wait</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-title">Unlock</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-title">Broadcast</span><span class="hljs-params">()</span></span><span class="hljs-comment">// Signal()</span><span class="hljs-comment">// 两种写法都不会报错 </span></code></pre></div><p>在 go 的发送通知方法（Broadcast、Signal）上有这么一段话：</p><blockquote><p>// It is allowed but not required for the caller to hold c.L<br>// during the call.</p></blockquote><p>在我以往的 C 多线程开发的时候，发送通知总是在锁中的：</p><div class="code-wrapper"><pre><code class="hljs reasonml">pthread<span class="hljs-constructor">_mutex_lock(&amp;<span class="hljs-params">thread</span>-&gt;<span class="hljs-params">mutex</span>)</span>;<span class="hljs-comment">//              ...</span>pthread<span class="hljs-constructor">_cond_signal(&amp;<span class="hljs-params">thread</span>-&gt;<span class="hljs-params">cond</span>)</span>;pthread<span class="hljs-constructor">_mutex_unlock(&amp;<span class="hljs-params">thread</span>-&gt;<span class="hljs-params">mutex</span>)</span>;</code></pre></div><p>在 <a href="https://linux.die.net/man/3/pthread_cond_signal">man</a> 手册中有写到：</p><blockquote><p>The pthread_cond_broadcast() or pthread_cond_signal() functions may be called by a thread whether or not it currently owns the mutex that threads calling pthread_cond_wait() or pthread_cond_timedwait() have associated with the condition variable during their waits; however, if predictable scheduling behavior is required, then that mutex shall be locked by the thread calling pthread_cond_broadcast() or pthread_cond_signal().</p></blockquote><p>个人对此并没有什么见解，就不乱下定论了，有想法的小伙伴可以在文章下面留言，一起讨论。</p><h3 id="等待通知"><a href="#等待通知" class="headerlink" title="等待通知"></a>等待通知</h3><p>消息通知是有即时性的，如果没有 goroutine 在等待通知，那么这次通知直接被丢弃。</p><h3 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h3><p><a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/fifo.go">https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/client-go/tools/cache/fifo.go</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Wait() 内会执行解锁、等待、加锁。</li><li>Wait() 必须在 for 循环里面。</li><li>Wait() 方法会把当前的 goroutine 添加到通知队列的队尾。</li><li>单发通知，唤醒通知队列第一个排队的 goroutine。</li><li>广播通知，唤醒通知队列里面全部的 goroutine。</li><li>程序示例只是为了演示效果，实际的开发中，生产者和消费者应该是异步消费，不应该使用同一个互斥锁。</li></ol><p><a href="https://github.com/zuoshuwen/go-example/blob/master/e002/a01_test.go">文章示例代码</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同步</tag>
      
      <tag>条件变量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go并发编程之传统同步—(1)互斥锁</title>
    <link href="/golang/ipc-mutex/"/>
    <url>/golang/ipc-mutex/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先回顾一下，在 C 或者其它编程语言的并发编程中，主要存在两种<strong>通信</strong>（IPC）：</p><blockquote><ul><li><strong>进程间通信</strong>：管道、消息队列、信号等</li><li><strong>线程间通信</strong>：互斥锁、条件变量等</li></ul></blockquote><p>利用以上通信手段采取的同步措施，最终是为了达到以下两种目的：</p><blockquote><ul><li><strong>维持共享数据一致性，并发安全</strong></li><li><strong>控制流程管理，更好的协同工作</strong></li></ul></blockquote><p>Go语言中除了保留了传统的同步支持，还提供了特有的 CSP 并发编程模型。</p><span id="more"></span><h2 id="传统同步"><a href="#传统同步" class="headerlink" title="传统同步"></a>传统同步</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>接下来通过一个“做累加”的示例程序，展示<strong>竞争状态</strong>（race condition）。</p><h4 id="不加锁"><a href="#不加锁" class="headerlink" title="不加锁"></a>不加锁</h4><p>开启 5000 个 goroutine，让每个 goroutine 给 counter 加 1，最终在所有 goroutine 都完成任务时 counter 的值应该为 5000，先试下不加锁的示例程序表现如何</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo1</span><span class="hljs-params">(t *testing.T)</span></span> &#123;counter := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;counter++&#125;()&#125;time.Sleep(<span class="hljs-number">1</span> * time.Second)t.Logf(<span class="hljs-string">&quot;counter = %d&quot;</span>, counter)&#125;</code></pre></div><p>结果</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">=== RUN   TestDemo1</span><span class="hljs-code">    a1_test.go:18: counter = 4663</span><span class="hljs-bullet">--- </span>PASS: TestDemo1 (1.00s)PASS</code></pre></div><p>多试几次，结果一直是小于 5000 的不定值。<br>竞争状态下程序行为的图像表示<br><img src="/images/golang/ipc-mutex-01.jpg" alt="ipc-mutex-01"></p><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><p>将刚刚的代码稍作改动</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo2</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> mut sync.Mutex <span class="hljs-comment">// 声明锁</span>counter := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;mut.Lock() <span class="hljs-comment">// 加锁</span>counter++mut.Unlock() <span class="hljs-comment">// 解锁</span>&#125;()&#125;time.Sleep(<span class="hljs-number">1</span> * time.Second)t.Logf(<span class="hljs-string">&quot;counter = %d&quot;</span>, counter)&#125;</code></pre></div><p>结果</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">=== RUN   TestDemo2</span><span class="hljs-code">    a1_test.go:35: counter = 5000</span><span class="hljs-bullet">--- </span>PASS: TestDemo2 (1.01s)PASS</code></pre></div><p>counter = 5000，返回的结果对了。</p><p>这就是<strong>互斥锁</strong>，在代码上创建一个<strong>临界区</strong>（critical section），保证串行操作（同一时间只有一个 goroutine 执行临界区代码）。</p><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>那么互斥锁是怎么串行的呢？把每一步的执行过程打印出来看下</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo3</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> mut sync.Mutexcounter := <span class="hljs-number">0</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;mut.Lock()log.Println(<span class="hljs-string">&quot;goroutine B Lock&quot;</span>)counter = <span class="hljs-number">1</span>log.Println(<span class="hljs-string">&quot;goroutine B counter =&quot;</span>, counter)time.Sleep(<span class="hljs-number">5</span> * time.Second)mut.Unlock()log.Println(<span class="hljs-string">&quot;goroutine B Unlock&quot;</span>)&#125;()time.Sleep(<span class="hljs-number">1</span> * time.Second)mut.Lock()log.Println(<span class="hljs-string">&quot;goroutine A Lock&quot;</span>)counter = <span class="hljs-number">2</span>log.Println(<span class="hljs-string">&quot;goroutine A counter =&quot;</span>, counter)mut.Unlock()log.Println(<span class="hljs-string">&quot;goroutine A Unlock&quot;</span>)&#125;</code></pre></div><p>结果</p><div class="code-wrapper"><pre><code class="hljs awk">=== RUN   TestDemo3<span class="hljs-number">2020</span><span class="hljs-regexp">/09/</span><span class="hljs-number">30</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span>:<span class="hljs-number">00</span> goroutine B Lock<span class="hljs-number">2020</span><span class="hljs-regexp">/09/</span><span class="hljs-number">30</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span>:<span class="hljs-number">00</span> goroutine B counter = <span class="hljs-number">1</span><span class="hljs-number">2020</span><span class="hljs-regexp">/09/</span><span class="hljs-number">30</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span>:<span class="hljs-number">05</span> goroutine B Unlock<span class="hljs-number">2020</span><span class="hljs-regexp">/09/</span><span class="hljs-number">30</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span>:<span class="hljs-number">05</span> goroutine A Lock<span class="hljs-number">2020</span><span class="hljs-regexp">/09/</span><span class="hljs-number">30</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span>:<span class="hljs-number">05</span> goroutine A counter = <span class="hljs-number">2</span><span class="hljs-number">2020</span><span class="hljs-regexp">/09/</span><span class="hljs-number">30</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span>:<span class="hljs-number">05</span> goroutine A Unlock--- PASS: TestDemo3 (<span class="hljs-number">5.00</span>s)PASS</code></pre></div><p>通过每个操作记录下来的时间可以看出，goroutine A 的 Lock 一直阻塞到了 goroutine B 的 Unlock。<br><img src="/images/golang/ipc-mutex-02.jpg" alt="ipc-mutex-01"></p><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>这时候有个疑问，那 goroutine B 上的锁，goroutine A 能解锁吗？修改一下刚才的代码，试一下</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo5</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> mut sync.Mutexcounter := <span class="hljs-number">0</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;mut.Lock()log.Println(<span class="hljs-string">&quot;goroutine B Lock&quot;</span>)counter = <span class="hljs-number">1</span>log.Println(<span class="hljs-string">&quot;goroutine B counter =&quot;</span>, counter)time.Sleep(<span class="hljs-number">5</span> * time.Second)<span class="hljs-comment">//mut.Unlock()</span><span class="hljs-comment">//log.Println(&quot;goroutine B Unlock&quot;)</span>&#125;()time.Sleep(<span class="hljs-number">1</span> * time.Second)mut.Unlock()log.Println(<span class="hljs-string">&quot;goroutine A Unlock&quot;</span>)counter = <span class="hljs-number">2</span>log.Println(<span class="hljs-string">&quot;goroutine A counter =&quot;</span>, counter)time.Sleep(<span class="hljs-number">2</span> * time.Second)&#125;</code></pre></div><p>结果</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">=== RUN   TestDemo5</span>2020/09/30 22:15:03 goroutine B Lock2020/09/30 22:15:03 goroutine B counter = 12020/09/30 22:15:04 goroutine A Unlock2020/09/30 22:15:04 goroutine A counter = 2<span class="hljs-bullet">--- </span>PASS: TestDemo5 (3.01s)PASS</code></pre></div><p>测试通过，未报错，counter 的值也被成功修改，证明B上的锁，是可以被A解开的。</p><p>再进一步，goroutine A 不解锁，直接修改已经被 goroutine B 锁住的 counter 的值可以吗？试一下</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDemo6</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> mut sync.Mutexcounter := <span class="hljs-number">0</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;mut.Lock()log.Println(<span class="hljs-string">&quot;goroutine B Lock&quot;</span>)counter = <span class="hljs-number">1</span>log.Println(<span class="hljs-string">&quot;goroutine B counter =&quot;</span>, counter)time.Sleep(<span class="hljs-number">5</span> * time.Second)mut.Unlock()log.Println(<span class="hljs-string">&quot;goroutine B Unlock&quot;</span>)&#125;()time.Sleep(<span class="hljs-number">1</span> * time.Second)<span class="hljs-comment">//log.Println(&quot;goroutine A Unlock&quot;)</span><span class="hljs-comment">//mut.Unlock()</span>counter = <span class="hljs-number">2</span>log.Println(<span class="hljs-string">&quot;goroutine A counter =&quot;</span>, counter)time.Sleep(<span class="hljs-number">10</span> * time.Second)&#125;</code></pre></div><p>结果</p><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-section">=== RUN   TestDemo6</span>2020/09/30 22:15:43 goroutine B Lock2020/09/30 22:15:43 goroutine B counter = 12020/09/30 22:15:44 goroutine A counter = 22020/09/30 22:15:48 goroutine B Unlock<span class="hljs-bullet">--- </span>PASS: TestDemo6 (11.00s)PASS</code></pre></div><p>测试通过，未报错，证明B上的锁，A可以不用解锁直接改。</p><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h3 id="锁的两种通常处理方式"><a href="#锁的两种通常处理方式" class="headerlink" title="锁的两种通常处理方式"></a>锁的两种通常处理方式</h3><ul><li>一种是没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁叫做<strong>自旋锁</strong>，它不用将线程阻塞起来(NON-BLOCKING)；</li><li>还有一种处理方式就是把自己阻塞起来，等待重新调度请求，这种叫做互斥锁。</li></ul><h3 id="饥饿模式"><a href="#饥饿模式" class="headerlink" title="饥饿模式"></a>饥饿模式</h3><p>当互斥锁不断地试图获得一个永远无法获得的锁时，它可能会遇到饥饿问题。<br>在版本1.9中，Go通过添加一个新的饥饿模式来解决先前的问题，所有等待锁定超过一毫秒的 goroutine，也称为有界等待，将被标记为饥饿。当标记为饥饿时，解锁方法现在将把锁直接移交给第一位等待着。</p><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁和上面的多也差不多，有这么几种情况</p><ul><li>在写锁已被锁定的情况下试图锁定写锁，会阻塞当前的 goroutine。</li><li>在写锁已被锁定的情况下试图锁定读锁，会阻塞当前的 goroutine。</li><li>在读锁已被锁定的情况下试图锁定写锁，会阻塞当前的 goroutine。</li><li>在读锁已被锁定的情况下试图锁定读锁，不会阻塞当前的 goroutine。</li></ul><h3 id="panic错误"><a href="#panic错误" class="headerlink" title="panic错误"></a>panic错误</h3><p>无论是互斥锁还是读写锁在程序运行时一定是成对的，不然就会引发不可恢复的panic。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>锁一定要用对地方，特别是要注意Lock产生的阻塞对性能的影响。</li><li>在各种程序的逻辑分支下，都要确保锁的成对出现。</li><li>读写锁是对互斥锁的一个扩展，提高了程序的可读性。</li><li>临界区是需要每个 goroutine 主动遵守的，说白了就是每个 goroutine 的代码都存在 Lock。</li></ol><p><a href="https://github.com/zuoshuwen/go-example/blob/master/e001/a01_test.go">文章示例代码</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>同步</tag>
      
      <tag>互斥锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式共识算法Raft实现之Etcd</title>
    <link href="/etcd/a/"/>
    <url>/etcd/a/</url>
    
    <content type="html"><![CDATA[<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="https://etcd.io/docs/">etcd doc</a><br><a href="https://hardcore.feishu.cn/docs/doccnMRVFcMWn1zsEYBrbsDf8De#">Raft -论文导读 与 ETCD源码解读</a><br><a href="https://www.zhihu.com/column/c_1382353468817117184">etcd-源码学习</a><br><a href="https://lessisbetter.site/tags/Raft/">Etcd Raft架构设计和源码剖析</a></p><h2 id="raft"><a href="#raft" class="headerlink" title="raft"></a>raft</h2><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><h2 id="docker-image"><a href="#docker-image" class="headerlink" title="docker image"></a>docker image</h2><p><a href="https://registry.hub.docker.com/r/bitnami/etcd">https://registry.hub.docker.com/r/bitnami/etcd</a></p><h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><p><a href="https://www.huweihuang.com/kubernetes-notes/etcd/etcdctl-v3.html">www.huweihuang.com</a><br><a href="https://segmentfault.com/a/1190000040203666">GO 中 ETCD 的编码案例分享</a><br><a href="https://doczhcn.gitbook.io/etcd/index/index-1/configuration">配置</a><br><a href="https://doczhcn.gitbook.io/etcd/index/index-1/container">在容器内运行 etcd 集群</a><br><a href="https://doczhcn.gitbook.io/etcd/index/index-1/clustering">搭建 etcd 集群</a><br><a href="https://zhuanlan.zhihu.com/p/260019277">ubuntu+docker搭建etcd集群</a><br><a href="https://github.com/zuoshuwen/example/etcd">docker example etcd</a></p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>etcd</tag>
      
      <tag>raft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go系列文章索引</title>
    <link href="/golang/a/"/>
    <url>/golang/a/</url>
    
    <content type="html"><![CDATA[<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="http://gk.link/a/10txP">极客时间《GO并发编程实战课》</a><br><a href="http://gk.link/a/10txQ">极客时间《Go语言从入门到实战》</a><br><a href="http://gk.link/a/10txR">极客时间《Go语言核心36讲》</a><br><a href="http://gk.link/a/10o2G">极客时间《Go语言编程模式实战》</a><br><a href="http://gk.link/a/10sIo">极客时间《Go进阶训练营》</a><br><a href="https://learnku.com/docs/effective-go/2020">电子书《高效的 Go 编程 Effective Go》</a><br><a href="https://lessisbetter.site/">博客《Go语言充电站》</a><br><a href="https://eddycjy.com/">博客《煎鱼》</a><br><a href="https://lailin.xyz/">博客《mohuishou》</a><br><a href="http://gk.link/a/10sIo">极客时间《go进阶训练营》</a></p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><strong>参考</strong></p><p><strong>笔记</strong></p><ol><li><input type="checkbox" disabled checked="checked"><a href="/golang/datastruct-arrayslice/" title="Go数据结构之数组与切片">Go数据结构之数组与切片</a></li><li><del>Go数据结构之Map</del></li></ol><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p><strong>参考</strong></p><p><strong>笔记</strong></p><ol><li><input type="checkbox" disabled ><a href="/golang/oop/" title="Go面向对象">Go面向对象</a></li></ol><h1 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h1><p><strong>参考</strong></p><p><strong>笔记</strong></p><ol><li><input type="checkbox" disabled ><a href="/golang/scheduling/" title="GoMPG与调度">GoMPG与调度</a></li><li><input type="checkbox" disabled ><a href="/golang/memory-alloc/" title="Go内存管理、分配">Go内存管理、分配</a></li><li><input type="checkbox" disabled ><a href="/golang/memory-gc/" title="Go内存GC">Go内存GC</a></li><li><input type="checkbox" disabled ><a href="/golang/memory-leak-escape/" title="Go内存泄漏、逃逸">Go内存泄漏、逃逸</a></li></ol><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>启动 goroutine 应该在方法外，不应该在方法里面，并发行为，交给调用者。<br>搞清楚channel什么时候退出，控制这个channel的退出，并发扔给调用者，这三个关键点<br>log.Fatal()不能随便用，因为会导致defer不能执行</p><p><strong>参考</strong></p><p><strong>笔记</strong></p><ol><li><input type="checkbox" disabled checked="checked"><a href="/golang/concurrent-programme/" title="并发编程">并发编程</a></li><li><input type="checkbox" disabled checked="checked"><a href="/golang/ipc-mutex/" title="Go并发编程之传统同步—(1)互斥锁">Go并发编程之传统同步—(1)互斥锁</a></li><li><input type="checkbox" disabled checked="checked"><a href="/golang/ipc-cond/" title="Go并发编程之传统同步—(2)条件变量">Go并发编程之传统同步—(2)条件变量</a></li><li><input type="checkbox" disabled checked="checked"><a href="/golang/ipc-atomic/" title="Go并发编程之传统同步—(3)原子操作">Go并发编程之传统同步—(3)原子操作</a></li><li><input type="checkbox" disabled ><a href="/golang/ipc-waitgrouponce/" title="Go并发编程之任务协作—(1)WaitGroup、Once">Go并发编程之任务协作—(1)WaitGroup、Once</a></li><li><input type="checkbox" disabled ><a href="/golang/ipc-errgroup/" title="Go并发编程之任务协作—(1)ErrGroup">Go并发编程之任务协作—(1)ErrGroup</a></li><li><input type="checkbox" disabled ><a href="/golang/ipc-context/" title="Go并发编程之任务协作—(2)Context">Go并发编程之任务协作—(2)Context</a></li><li><input type="checkbox" disabled ><a href="/golang/ipc-map/" title="Go并发编程之数据共享—(1)Map">Go并发编程之数据共享—(1)Map</a></li><li><input type="checkbox" disabled ><a href="/golang/ipc-pool/" title="Go并发编程之数据共享—(2)Pool">Go并发编程之数据共享—(2)Pool</a></li><li><input type="checkbox" disabled ><a href="/golang/ipc-channel/" title="Go并发编程之终极武器—channel">Go并发编程之终极武器—channel</a></li><li><input type="checkbox" disabled >data race</li><li>singleflight</li></ol><h1 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h1><h1 id="项目工程"><a href="#项目工程" class="headerlink" title="项目工程"></a>项目工程</h1><p><strong>参考</strong><br><a href="https://github.com/golang-standards/project-layout/blob/master/README_zh.md">project-layout</a></p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p><strong>参考</strong><br><a href="https://lailin.xyz/post/go-training-03.html">Go错误处理最佳实践</a></p><h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><p>幂等：客户端要进行版本号创建与更新，并且按接口区分，对于同一个接口，只有在 response 返回时，才更新于接口对应的版本号。所以当用户连续两次点击的时候，还没有任何response返回，版本号肯定是一样的。</p><h3 id="gomod"><a href="#gomod" class="headerlink" title="gomod"></a>gomod</h3><p>开启了gomod 项目就不要放在 src 目录下，一定要拿出来</p><h3 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h3><p><a href="https://github.com/LyricTian/gin-admin">gin-admin</a></p><h1 id="编程模式"><a href="#编程模式" class="headerlink" title="编程模式"></a>编程模式</h1><p>选项模式</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>1.无锁编程<br>2. <a href="https://www.jianshu.com/p/1390dbf87471">Go语言学习之——if else</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文章索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系列文章索引</title>
    <link href="/distributed/a/"/>
    <url>/distributed/a/</url>
    
    <content type="html"><![CDATA[<h1 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h1><p><a href="https://hardcore.feishu.cn/docs/doccngKKrYQWSYu4Rr3puVq20wc">硬核课堂</a><br><a href="http://gk.link/a/10tCq">极客时间《分布式协议与算法实战》</a></p><h2 id="拜占庭将军"><a href="#拜占庭将军" class="headerlink" title="拜占庭将军"></a>拜占庭将军</h2><h2 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><h3 id="一致性-ACID"><a href="#一致性-ACID" class="headerlink" title="一致性 ACID"></a>一致性 ACID</h3><h3 id="可用性-BASE"><a href="#可用性-BASE" class="headerlink" title="可用性 BASE"></a>可用性 BASE</h3><h1 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h1><h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><p>Raft 算法属于 Multi-Paxos 算法，它是在兰伯特 Multi-Paxos 思想的基础上，做了一些简化和限制，比如增加了日志必须是连续的，只支持领导者、跟随者和候选人三种状态，在理解和算法实现上都相对容易许多。</p><p>Raft 算法是现在分布式系统开发首选的共识算法</p><p>如果要用一句话概括 Raft 算法，我觉得是这样的：从本质上说，Raft 算法是通过一切以领导者为准的方式，实现一系列值的共识和各节点日志的一致。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><h3 id="领导者（Leader）"><a href="#领导者（Leader）" class="headerlink" title="领导者（Leader）"></a>领导者（Leader）</h3><p>蛮不讲理的霸道总裁，一切以我为准，平常的主要工作内容就是 3 部分，处理写请求、管理日志复制和不断地发送心跳信息，通知其他节点“我是领导者，我还活着，你们现在不要发起新的选举，找个新领导者来替代我。”</p><h3 id="跟随者（Follower）"><a href="#跟随者（Follower）" class="headerlink" title="跟随者（Follower）"></a>跟随者（Follower）</h3><p>就相当于普通群众，默默地接收和处理来自领导者的消息，当等待领导者心跳信息超时的时候，就主动站出来，推荐自己当候选人。</p><h3 id="候选人（Candidate）"><a href="#候选人（Candidate）" class="headerlink" title="候选人（Candidate）"></a>候选人（Candidate）</h3><p>候选人将向其他节点发送请求投票（RequestVote）RPC 消息，通知其他节点来投票，如果赢得了大多数选票，就晋升当领导者。</p><h2 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h2><h3 id="发送心跳"><a href="#发送心跳" class="headerlink" title="发送心跳"></a>发送心跳</h3><p>Raft 算法实现了随机超时时间的特性。也就是说，每个节点等待领导者节点心跳信息的超时时间间隔是随机的。通过上面的图片你可以看到，集群中没有领导者，而节点 A 的等待超时时间最小（150ms），它会最先因为没有等到领导者的心跳信息，发生超时。<br>这个时候，节点 A 就增加自己的任期编号，并推举自己为候选人，先给自己投上一张选票，然后向其他节点发送请求投票 RPC 消息，请它们选举自己为领导者。</p><h3 id="请求投票（RequestVote）"><a href="#请求投票（RequestVote）" class="headerlink" title="请求投票（RequestVote）"></a>请求投票（RequestVote）</h3><p>RPC，是由候选人在选举期间发起，通知各节点进行投票；</p><h3 id="任期编号（term）"><a href="#任期编号（term）" class="headerlink" title="任期编号（term）"></a>任期编号（term）</h3><p>推举自己为候选人时，会增加自己的任期号；<br>发现自己的任期编号比其他节点小，那么它会立即恢复成跟随者状态，那么它会更新自己的编号到较大的编号值；<br>接收到一个包含较小的任期编号值的请求投票消息，那么它会直接拒绝这个请求；</p><h3 id="日志复制（AppendEntries）"><a href="#日志复制（AppendEntries）" class="headerlink" title="日志复制（AppendEntries）"></a>日志复制（AppendEntries）</h3><p>RPC，是由领导者发起，用来复制日志和提供心跳消息；<br>就算任期编号大的节点，如果最后一条日志项对应的任期编号小于其它节点，请求投票也会被拒绝；</p><h3 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h3><p>脑裂情况是无效状态，通过随机超时，来重新选举</p><h3 id="投票"><a href="#投票" class="headerlink" title="投票"></a>投票</h3><p>每个任期（term）只能投票一次</p><h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><h3 id="日志项"><a href="#日志项" class="headerlink" title="日志项"></a>日志项</h3><p>日志项是一种数据格式，它主要包含用户指定的数据，也就是指令（Command），还包含一些附加信息，比如索引值（Log index）、任期编号（Term）</p><h3 id="第一阶段，日志项预执行：日志复制"><a href="#第一阶段，日志项预执行：日志复制" class="headerlink" title="第一阶段，日志项预执行：日志复制"></a>第一阶段，日志项预执行：日志复制</h3><p>首先，领导者进入第一阶段，通过日志复制（AppendEntries）RPC 消息，将日志项复制到集群其他节点上。<br>接着，如果领导者接收到大多数的“复制成功”响应后，它将日志项应用到它的状态机，并返回成功给客户端。如果领导者没有接收到大多数的“复制成功”响应，那么就返回错误给客户端。</p><h3 id="第二阶段，心跳或者新的日志复制带有日志项索引值：状态机"><a href="#第二阶段，心跳或者新的日志复制带有日志项索引值：状态机" class="headerlink" title="第二阶段，心跳或者新的日志复制带有日志项索引值：状态机"></a>第二阶段，心跳或者新的日志复制带有日志项索引值：状态机</h3><p>这是 Raft 中的一个优化，领导者不直接发送消息通知其他节点应用指定日志项。因为领导者的日志复制 RPC 消息或心跳消息，包含了当前最大的，将会被提交（Commit）的日志项索引值。所以通过日志复制 RPC 消息或心跳消息，跟随者就可以知道领导者的日志提交位置信息。<br>因此，当其他节点接受领导者的心跳消息，或者新的日志复制 RPC 消息后，就会将这条日志项应用到它的状态机。而这个优化，降低了处理客户端请求的延迟，将二阶段提交优化为了一段提交，降低了一半的消息延迟。</p><h3 id="一致性维护"><a href="#一致性维护" class="headerlink" title="一致性维护"></a>一致性维护</h3><p>首先，领导者通过日志复制 RPC 的一致性检查，找到跟随者节点上，与自己相同日志项的最大索引值。也就是说，这个索引值之前的日志，领导者和跟随者是一致的，之后的日志是不一致的了。<br>然后，领导者强制跟随者更新覆盖的不一致日志项，实现日志的一致。</p><h1 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a>Gossip</h1><h1 id="Quorum"><a href="#Quorum" class="headerlink" title="Quorum"></a>Quorum</h1><h1 id="PBFT"><a href="#PBFT" class="headerlink" title="PBFT"></a>PBFT</h1><h1 id="PoW"><a href="#PoW" class="headerlink" title="PoW"></a>PoW</h1><h1 id="ZAB"><a href="#ZAB" class="headerlink" title="ZAB"></a>ZAB</h1><h1 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h1><h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><p>拜占庭容错算法<br>口信消息型<br>签名消息型<br>数字货币的区块链技术中</p><p>非拜占庭容错算法<br>解决的是分布式的系统中存在故障，但不存在恶意节点的场景下的共识问题</p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文章索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
